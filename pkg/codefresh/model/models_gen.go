// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	IsGitopsEntity()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

//  ReadModelEventPayload base interface
type ReadModelEventPayload interface {
	IsReadModelEventPayload()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations"`
	// Users that are attached to this account
	Users []*User `json:"users"`
	// Ids of all users that have account admin premission to this account
	Admins []string `json:"admins"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
	// Account security
	Security *SecurityInfo `json:"security"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token"`
}

//  AppProjectReadModelEventPayload type
type AppProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (AppProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Number of resources
	Size *int `json:"size"`
	// Revision
	Revision *string `json:"revision"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
}

func (Application) IsGitopsEntity()       {}
func (Application) IsBaseEntity()         {}
func (Application) IsProjectBasedEntity() {}
func (Application) IsEntity()             {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

//  ApplicationReadModelEventPayload type
type ApplicationReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (ApplicationReadModelEventPayload) IsReadModelEventPayload() {}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Revision
	Revision string `json:"revision"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// TBD
	Schedule string `json:"schedule"`
	// TBD
	Interval string `json:"interval"`
	// TBD
	Timezone string `json:"timezone"`
	// TBD
	Metadata string `json:"metadata"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the component
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity()         {}
func (Component) IsK8sLogicEntity()     {}
func (Component) IsProjectBasedEntity() {}
func (Component) IsEntity()             {}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

//  ComponentReadModelEventPayload type
type ComponentReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (ComponentReadModelEventPayload) IsReadModelEventPayload() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Composite Slice
type CompositeSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo []*CompositeSliceInfo `json:"pageInfo"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Infomration about a slice of a specific kind
type CompositeSliceInfo struct {
	// Key of the slice
	Key string `json:"key"`
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
}

// Pagination arguments to request kind-slice
type CompositeSlicePaginationArgs struct {
	// References a specific key
	Key string `json:"key"`
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

//  Db Entity Reference
type EntityReference struct {
	// GVK/group
	Group *string `json:"group"`
	// GVK/version
	Version *string `json:"version"`
	// GVK/kind
	Kind *string `json:"kind"`
	// Resource name
	Name *string `json:"name"`
	// Resource namespace
	Namespace *string `json:"namespace"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
	// Commit url with file
	FileURL *string `json:"fileUrl"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid"`
	// Content of the event
	Data *string `json:"data"`
	// Time
	Time *string `json:"time"`
	// Event source
	EventSource *EventSource `json:"eventSource"`
	// Event name
	EventName *string `json:"eventName"`
	// Event type
	EventType *string `json:"eventType"`
	// Account
	Account *string `json:"account"`
	// Runtime
	Runtime *string `json:"runtime"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

//  EventPayloadReadModelEventPayload type
type EventPayloadReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (EventPayloadReadModelEventPayload) IsReadModelEventPayload() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the event-source
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (EventSource) IsBaseEntity()         {}
func (EventSource) IsGitopsEntity()       {}
func (EventSource) IsProjectBasedEntity() {}
func (EventSource) IsEntity()             {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

//  EventSourceReadModelEventPayload type
type EventSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (EventSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (GenericEntity) IsGitopsEntity()       {}
func (GenericEntity) IsBaseEntity()         {}
func (GenericEntity) IsProjectBasedEntity() {}
func (GenericEntity) IsEntity()             {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// GitOps Edge
type GitOpsEdge struct {
	// Node contains the actual component data
	Node GitopsEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// GitOps Slice
type GitOpsSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork"`
	// PR comment
	Comment *GitPRComment `json:"comment"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *Repository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// PR data
	Pr *GitPr `json:"pr"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPREventPayloadData) IsEventPayloadData()          {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *Repository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha"`
	// SHA URL
	ShaURL *string `json:"shaURL"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *Repository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPushEventPayloadData) IsEventPayloadData()          {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *Repository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Release data
	Release *GitRelease `json:"release"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitReleaseEventPayloadData) IsEventPayloadData()          {}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the GitSource
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
}

func (GitSource) IsK8sLogicEntity()     {}
func (GitSource) IsBaseEntity()         {}
func (GitSource) IsProjectBasedEntity() {}
func (GitSource) IsEntity()             {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

//  GitSourceReadModelEventPayload type
type GitSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (GitSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *Repository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitUnknownEventPayloadData) IsEventPayloadData()          {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource"`
	// Repo URL
	RepoURL *string `json:"repoURL"`
	// Path
	Path *string `json:"path"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL"`
	// Git revision
	Revision *string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit web url
	CommitURL *string `json:"commitURL"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Author web profile url
	ProfileURL *string `json:"profileURL"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL"`
	// Git manifest
	GitManifest *string `json:"gitManifest"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction"`
}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// History arguments
type HistoryArgs struct {
	// History Pagination arguments
	Pagination []*CompositeSlicePaginationArgs `json:"pagination"`
	// Page Size
	PageSize *int `json:"pageSize"`
	// Sync Success - SUCCESS/FAILURE
	SyncSuccess *SyncSuccess `json:"syncSuccess"`
	// Repo
	Repo *string `json:"repo"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Unique args for retriving single entity
type NamespacedFindOneArgs struct {
	// Runtime name
	Runtime string `json:"runtime"`
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace string `json:"namespace"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName string `json:"templateName"`
	// Node children
	Children []*string `json:"children"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase"`
	// Progress
	Progress *Progress `json:"progress"`
	// Message
	Message *string `json:"message"`
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Inputs
	Inputs *string `json:"inputs"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels"`
	// Annotations
	Annotations []*StringPair `json:"annotations"`
	// Last updated
	LastUpdated *string `json:"lastUpdated"`
	// Created
	Created *string `json:"created"`
	// K8s object uid
	UID *string `json:"uid"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self"`
	// History of the pipeline
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity"`
}

func (Pipeline) IsBaseEntity()         {}
func (Pipeline) IsK8sLogicEntity()     {}
func (Pipeline) IsProjectBasedEntity() {}
func (Pipeline) IsEntity()             {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time"`
	// Committers
	Committers *int `json:"committers"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time"`
	// Executions
	Executions *int `json:"executions"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame"`
	// Success Rate stats
	SuccessRateStats *int `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *int `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *int `json:"executionsStats"`
}

//  PipelineReadModelEventPayload type
type PipelineReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (PipelineReadModelEventPayload) IsReadModelEventPayload() {}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time"`
	// Success rate
	SuccessRate *int `json:"successRate"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name"`
}

// Progress
type Progress struct {
	// Total
	Total *int `json:"total"`
	// Done
	Done *int `json:"done"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

//  ProjectReadModelEventPayload type
type ProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (ProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

//  ReadModelEventResponse
type ReadModelEventResponse struct {
	// Account ID
	AccountID string `json:"accountId"`
	// Time of event
	Time string `json:"time"`
	// Payload of event
	Payload ReadModelEventPayload `json:"payload"`
}

// Release Entity
type Release struct {
	// Release version
	Version string `json:"version"`
}

// "Repository
type Repository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// History of the runtime
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

func (Runtime) IsBaseEntity()         {}
func (Runtime) IsProjectBasedEntity() {}
func (Runtime) IsK8sLogicEntity()     {}
func (Runtime) IsEntity()             {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Cluster
	Cluster string `json:"cluster"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

//  RuntimeReadModelEventPayload type
type RuntimeReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (RuntimeReadModelEventPayload) IsReadModelEventPayload() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the sensor
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (Sensor) IsGitopsEntity()       {}
func (Sensor) IsBaseEntity()         {}
func (Sensor) IsProjectBasedEntity() {}
func (Sensor) IsEntity()             {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

//  SensorReadModelEventPayload type
type SensorReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (SensorReadModelEventPayload) IsReadModelEventPayload() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType"`
	// Display name
	DisplayName *string `json:"displayName"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message"`
}

// Lable
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context"`
}

func (SyncError) IsError() {}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount"`
	// The customers that this user is in
	Customers []Customer `json:"customers"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate"`
	// User chosen sso of active account
	Sso *string `json:"sso"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []*EventPayload `json:"eventsPayload"`
	// Pipeline refernece
	Pipeline *Pipeline `json:"pipeline"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Workflow URL
	URL *string `json:"url"`
}

func (Workflow) IsProjectBasedEntity() {}
func (Workflow) IsBaseEntity()         {}
func (Workflow) IsK8sStandardEntity()  {}
func (Workflow) IsEntity()             {}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// Command array
	Command []*string `json:"command"`
	// Args
	Args []*string `json:"args"`
	// Env map
	Env []*StringPair `json:"env"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon"`
	// Container
	Container *WorkflowContainerSpec `json:"container"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

//  WorkflowReadModelEventPayload type
type WorkflowReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (WorkflowReadModelEventPayload) IsReadModelEventPayload() {}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Pipeline filter arguments
type WorkflowStatisticsFilterArgs struct {
	// Filter pipelines from a specific pipeline
	TimeRange PipelineStatisticsFilterTimeRange `json:"timeRange"`
	// Repository name
	RepoName []*string `json:"repoName"`
	// workflow status
	Status []*WorkflowPhases `json:"status"`
	// Git Event Type
	GitEventType []*string `json:"gitEventType"`
	// Initiator
	Initiator []*string `json:"initiator"`
	// Brnach Name
	Branch []*string `json:"branch"`
	// Pipeline Name
	PipelineName []*string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace []*string `json:"pipelineNamespace"`
	// Runtime
	Runtime []*string `json:"runtime"`
}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *Progress `json:"progress"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes"`
	// Message
	Message *string `json:"message"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the workflow-template
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity()       {}
func (WorkflowTemplate) IsBaseEntity()         {}
func (WorkflowTemplate) IsProjectBasedEntity() {}
func (WorkflowTemplate) IsEntity()             {}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

//  WorkflowTemplateReadModelEventPayload type
type WorkflowTemplateReadModelEventPayload struct {
	// Type of DB entity
	EntityType *string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType *string `json:"eventType"`
	// Reference to old entity
	OldItem *EntityReference `json:"oldItem"`
	// Reference to new entity
	NewItem *EntityReference `json:"newItem"`
}

func (WorkflowTemplateReadModelEventPayload) IsReadModelEventPayload() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow filter arguments
type WorkflowsFilterArgs struct {
	// Filter workflows from a specific project
	Project *string `json:"project"`
	// Filter workflows from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter workflows from a specific namespace
	Namespace *string `json:"namespace"`
	// Filter workflows from a specific pipeline
	Pipeline *NamespacedFindOneArgs `json:"pipeline"`
	// Filter workflows from a specific repositories
	Repositories []*string `json:"repositories"`
	// Filter workflows from a specific branches
	Branches []*string `json:"branches"`
	// Filter workflows from a specific event types
	EventTypes []*string `json:"eventTypes"`
	// Filter workflows from a specific initiators
	Initiators []*string `json:"initiators"`
	// Filter workflows from a specific statuses
	Statuses []*WorkflowPhases `json:"statuses"`
	// Filter workflows from a specific start date
	StartDateFrom *string `json:"startDateFrom"`
	// Filter workflows to a specific start date
	StartDateTo *string `json:"startDateTo"`
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline time range filter possible values
type PipelineStatisticsFilterTimeRange string

const (
	PipelineStatisticsFilterTimeRangeLast30Days PipelineStatisticsFilterTimeRange = "LAST_30_DAYS"
	PipelineStatisticsFilterTimeRangeLast7Days  PipelineStatisticsFilterTimeRange = "LAST_7_DAYS"
	PipelineStatisticsFilterTimeRangeLast90Days PipelineStatisticsFilterTimeRange = "LAST_90_DAYS"
)

var AllPipelineStatisticsFilterTimeRange = []PipelineStatisticsFilterTimeRange{
	PipelineStatisticsFilterTimeRangeLast30Days,
	PipelineStatisticsFilterTimeRangeLast7Days,
	PipelineStatisticsFilterTimeRangeLast90Days,
}

func (e PipelineStatisticsFilterTimeRange) IsValid() bool {
	switch e {
	case PipelineStatisticsFilterTimeRangeLast30Days, PipelineStatisticsFilterTimeRangeLast7Days, PipelineStatisticsFilterTimeRangeLast90Days:
		return true
	}
	return false
}

func (e PipelineStatisticsFilterTimeRange) String() string {
	return string(e)
}

func (e *PipelineStatisticsFilterTimeRange) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineStatisticsFilterTimeRange(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineStatisticsFilterTimeRange", str)
	}
	return nil
}

func (e PipelineStatisticsFilterTimeRange) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline statistics sort by measure
type PipelineStatisticsSortByMeasure string

const (
	PipelineStatisticsSortByMeasureAverageDuration PipelineStatisticsSortByMeasure = "AVERAGE_DURATION"
	PipelineStatisticsSortByMeasureExecutions      PipelineStatisticsSortByMeasure = "EXECUTIONS"
)

var AllPipelineStatisticsSortByMeasure = []PipelineStatisticsSortByMeasure{
	PipelineStatisticsSortByMeasureAverageDuration,
	PipelineStatisticsSortByMeasureExecutions,
}

func (e PipelineStatisticsSortByMeasure) IsValid() bool {
	switch e {
	case PipelineStatisticsSortByMeasureAverageDuration, PipelineStatisticsSortByMeasureExecutions:
		return true
	}
	return false
}

func (e PipelineStatisticsSortByMeasure) String() string {
	return string(e)
}

func (e *PipelineStatisticsSortByMeasure) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineStatisticsSortByMeasure(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineStatisticsSortByMeasure", str)
	}
	return nil
}

func (e PipelineStatisticsSortByMeasure) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync success/failure
type SyncSuccess string

const (
	// FAILURE - when SyncStatus is OUT_OF_SYNC or UNKNOWN
	SyncSuccessFailure SyncSuccess = "FAILURE"
	// SUCCESS - when SyncStatus is SYNCED
	SyncSuccessSuccess SyncSuccess = "SUCCESS"
)

var AllSyncSuccess = []SyncSuccess{
	SyncSuccessFailure,
	SyncSuccessSuccess,
}

func (e SyncSuccess) IsValid() bool {
	switch e {
	case SyncSuccessFailure, SyncSuccessSuccess:
		return true
	}
	return false
}

func (e SyncSuccess) String() string {
	return string(e)
}

func (e *SyncSuccess) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncSuccess(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncSuccess", str)
	}
	return nil
}

func (e SyncSuccess) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// Favorable
type Favorable interface {
	IsFavorable()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	IsGitopsEntity()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Notification information kinds
type NotificationInfo interface {
	IsNotificationInfo()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

// ReadModelEventPayload base interface
type ReadModelEventPayload interface {
	IsReadModelEventPayload()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations"`
	// Users that are attached to this account
	Users []*User `json:"users"`
	// Ids of all users that have account admin premission to this account
	Admins []string `json:"admins"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
	// Account security
	Security *SecurityInfo `json:"security"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
}

// Annotation
type Annotation struct {
	// Annotation type
	Type *string `json:"type"`
	// Annotation value
	Value *string `json:"value"`
	// Annotation accountId
	AccountID *string `json:"accountId"`
	// Annotation entityId
	EntityID *string `json:"entityId"`
	// Annotation entityType
	EntityType *string `json:"entityType"`
	// Annotation key
	Key *string `json:"key"`
}

// Args to set annotation for entity
type AnnotationArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
	// Event-source issueValue
	IssueValue *IssueValue `json:"issueValue"`
	// Event-source pullRequestValue
	PullRequestValue *PullRequestValue `json:"pullRequestValue"`
}

// Application Edge
type AnnotationEdge struct {
	// Node contains the actual application data
	Node *Annotation `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter annotation
type AnnotationFilterArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
}

// Annotation Slice
type AnnotationSlice struct {
	// Annotation edges
	Edges []*AnnotationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token"`
}

// AppProjectReadModelEventPayload type
type AppProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (AppProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Number of resources
	Size *int `json:"size"`
	// Revision
	Revision *string `json:"revision"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Cluster from runtime
	Cluster *string `json:"cluster"`
	// Favorites
	Favorites []string `json:"favorites"`
}

func (Application) IsGitopsEntity()       {}
func (Application) IsBaseEntity()         {}
func (Application) IsProjectBasedEntity() {}
func (Application) IsFavorable()          {}
func (Application) IsEntity()             {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

// ApplicationField Entity
type ApplicationField struct {
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Issues
	Issues []*string `json:"issues"`
	// PullRequest
	Prs []*PullRequest `json:"prs"`
	// Committers
	Committers []*CommitterLabel `json:"committers"`
	// Build
	Builds []*Build `json:"builds"`
}

// ApplicationReadModelEventPayload type
type ApplicationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ApplicationReadModelEventPayload) IsReadModelEventPayload() {}

// Application ref
type ApplicationRef struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Is reference was cut during tree normalizing
	IsReferenceCut *bool `json:"isReferenceCut"`
}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Application filter arguments
type ApplicationsFilterArgs struct {
	// Filter applications from a specific project
	Project *string `json:"project"`
	// Filter applications from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter applications from runtime list
	Runtimes []*string `json:"runtimes"`
	// Filter applications by list of names
	Applications []*string `json:"applications"`
	// Filter applications by name fragment
	ApplicationName *string `json:"applicationName"`
	// Filter applications by status
	Statuses []*SyncStatus `json:"statuses"`
	// Filter applications by health status
	HealthStatuses []*HealthStatus `json:"healthStatuses"`
	// Filter applications by namespace
	Namespaces []*string `json:"namespaces"`
	// Filter applications by kind
	Kinds []*string `json:"kinds"`
	// Filter applications by cluster
	Clusters []*string `json:"clusters"`
	// Filter applications by favorite using userId
	UserID *string `json:"userId"`
	// Filter applications by favorite
	Favorite *bool `json:"favorite"`
}

// Application sorting arguments
type ApplicationsSortArg struct {
	// Field for sorting
	Field SortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Application relations
type AppsRelations struct {
	// Entities referencing this entity
	ReferencedBy []*ApplicationRef `json:"referencedBy"`
	// Entities referenced by this enitity
	References []*ApplicationRef `json:"references"`
}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Revision
	Revision string `json:"revision"`
	// Version
	Version string `json:"version"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage"`
	// CommitDate
	CommitDate *string `json:"commitDate"`
}

// Build Entity
type Build struct {
	// Build Id
	ID string `json:"id"`
	// PipelineRef
	Pipeline *PipelineRef `json:"pipeline"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// TBD
	Schedule string `json:"schedule"`
	// TBD
	Interval string `json:"interval"`
	// TBD
	Timezone string `json:"timezone"`
	// TBD
	Metadata string `json:"metadata"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// ChildApplicationField Entity
type ChildApplicationField struct {
	// Name
	Name string `json:"name"`
	// Repo
	Repo *string `json:"repo"`
	// Cluster
	Cluster *string `json:"cluster"`
	// Status
	Status *SyncStatus `json:"status"`
}

// ClientIP
type ClientIP struct {
	// TimeoutSeconds
	TimeoutSeconds *int `json:"timeoutSeconds"`
}

// Committer Label
type CommitterLabel struct {
	// UserName
	UserName string `json:"userName"`
	// Avatar
	Avatar string `json:"avatar"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the component
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity()         {}
func (Component) IsK8sLogicEntity()     {}
func (Component) IsProjectBasedEntity() {}
func (Component) IsEntity()             {}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// ComponentReadModelEventPayload type
type ComponentReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ComponentReadModelEventPayload) IsReadModelEventPayload() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Composite Slice
type CompositeSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo []*CompositeSliceInfo `json:"pageInfo"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Infomration about a slice of a specific kind
type CompositeSliceInfo struct {
	// Key of the slice
	Key string `json:"key"`
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
}

// Pagination arguments to request kind-slice
type CompositeSlicePaginationArgs struct {
	// References a specific key
	Key string `json:"key"`
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Deployment entity
type Deployment struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Deployment Entity
	Spec *DeploymentSpec `json:"spec"`
	// Deployment Status
	Status *DeploymentStatus `json:"status"`
}

func (Deployment) IsGitopsEntity()       {}
func (Deployment) IsBaseEntity()         {}
func (Deployment) IsProjectBasedEntity() {}
func (Deployment) IsEntity()             {}

// Container
type DeploymentContainer struct {
	// Containers
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// ImagePullPolicy
	ImagePullPolicy *ImagePullPolicy `json:"imagePullPolicy"`
}

// Deployment Edge
type DeploymentEdge struct {
	// Node contains the actual Deployment data
	Node *Deployment `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (DeploymentEdge) IsEdge() {}

//  DeploymentReadModelEventPayload type
type DeploymentReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (DeploymentReadModelEventPayload) IsReadModelEventPayload() {}

// Deployment Slice
type DeploymentSlice struct {
	// Deployment edges
	Edges []*DeploymentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (DeploymentSlice) IsSlice() {}

// Deployment Spec
type DeploymentSpec struct {
	// Template
	Template *PodTemplateSpec `json:"template"`
	// Replicas
	Replicas *int `json:"replicas"`
}

// DeploymentSpecPart
type DeploymentSpecPart struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Status
	Status *DeploymentStatus `json:"status"`
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// Deployment Status
type DeploymentStatus struct {
	// Replicas
	Replicas *int `json:"replicas"`
	// AvailableReplicas
	AvailableReplicas *int `json:"availableReplicas"`
	// ReadyReplicas
	ReadyReplicas *int `json:"readyReplicas"`
	// UnavailableReplicas
	UnavailableReplicas *int `json:"unavailableReplicas"`
	// UpdatedReplicas
	UpdatedReplicas *int `json:"updatedReplicas"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

// Db Entity Reference
type EntityReference struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
	// Commit url with file
	FileURL *string `json:"fileUrl"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid"`
	// Content of the event
	Data *string `json:"data"`
	// Time
	Time *string `json:"time"`
	// Event source
	EventSource *EventSource `json:"eventSource"`
	// Event name
	EventName *string `json:"eventName"`
	// Event type
	EventType *string `json:"eventType"`
	// Account
	Account *string `json:"account"`
	// Runtime
	Runtime *string `json:"runtime"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

// EventPayloadReadModelEventPayload type
type EventPayloadReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (EventPayloadReadModelEventPayload) IsReadModelEventPayload() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the event-source
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (EventSource) IsBaseEntity()         {}
func (EventSource) IsGitopsEntity()       {}
func (EventSource) IsProjectBasedEntity() {}
func (EventSource) IsEntity()             {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// EventSourceReadModelEventPayload type
type EventSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (EventSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Args to set favorite for entity
type FavoriteInfoArgs struct {
	// Event-source kind
	Kind string `json:"kind"`
	// Event-source group
	Group string `json:"group"`
	// Event-source group
	Version string `json:"version"`
	// Event-source runtime name
	Runtime string `json:"runtime"`
	// Event-source name
	Name string `json:"name"`
	// Event-source namespace
	Namespace *string `json:"namespace"`
}

// From State Entity
type FromState struct {
	// Services
	Services []*ServiceItem `json:"services"`
}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (GenericEntity) IsGitopsEntity()       {}
func (GenericEntity) IsBaseEntity()         {}
func (GenericEntity) IsProjectBasedEntity() {}
func (GenericEntity) IsEntity()             {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// GitOps Edge
type GitOpsEdge struct {
	// Node contains the actual component data
	Node GitopsEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// GitOps Slice
type GitOpsSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork"`
	// PR comment
	Comment *GitPRComment `json:"comment"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// PR data
	Pr *GitPr `json:"pr"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPREventPayloadData) IsEventPayloadData()          {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *WorkflowRepository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha"`
	// SHA URL
	ShaURL *string `json:"shaURL"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPushEventPayloadData) IsEventPayloadData()          {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Release data
	Release *GitRelease `json:"release"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitReleaseEventPayloadData) IsEventPayloadData()          {}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the GitSource
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Permissions to this git source
	Permissions []*Permission `json:"permissions"`
}

func (GitSource) IsK8sLogicEntity()     {}
func (GitSource) IsBaseEntity()         {}
func (GitSource) IsProjectBasedEntity() {}
func (GitSource) IsEntity()             {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git source notification
type GitSourceNotification struct {
	// Commit information that triggered sync
	Source *GitopsEntitySource `json:"source"`
	// Link to the git-source in git provider
	GsRepoLink *string `json:"gsRepoLink"`
	// Sync status
	GsSyncStatus SyncStatus `json:"gsSyncStatus"`
}

func (GitSourceNotification) IsNotificationInfo() {}

// GitSourceReadModelEventPayload type
type GitSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (GitSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitUnknownEventPayloadData) IsEventPayloadData()          {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource"`
	// Repo URL
	RepoURL *string `json:"repoURL"`
	// Path
	Path *string `json:"path"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL"`
	// Git revision
	Revision *string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit web url
	CommitURL *string `json:"commitURL"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Author web profile url
	ProfileURL *string `json:"profileURL"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL"`
	// Git manifest
	GitManifest *string `json:"gitManifest"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction"`
}

// Gitops Release Entity
type GitopsRelease struct {
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
	// History id
	HistoryID int `json:"historyId"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
}

// Release Edge
type GitopsReleaseEdge struct {
	// Node contains the actual application data
	Node *GitopsRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter release
type GitopsReleaseFilterArgs struct {
	// Runtime
	Runtime *string `json:"runtime"`
	// Name
	Name *string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
	// Kind
	Kind *string `json:"kind"`
	// HistoryId
	HistoryID *int `json:"historyId"`
}

// Gitops Release Slice
type GitopsReleaseSlice struct {
	// Release edges
	Edges []*GitopsReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// Health Error Input
type HealthErrorInput struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Message
	Message string `json:"message"`
}

// History arguments
type HistoryArgs struct {
	// History Pagination arguments
	Pagination []*CompositeSlicePaginationArgs `json:"pagination"`
	// Page Size
	PageSize *int `json:"pageSize"`
	// Sync Success - SUCCESS/FAILURE
	SyncSuccess *SyncSuccess `json:"syncSuccess"`
	// Repo
	Repo *string `json:"repo"`
}

// Image binary entity
type ImageBinary struct {
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// ImageName
	ImageName string `json:"imageName"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Branch
	Branch *string `json:"branch"`
	// Commit
	Commit *string `json:"commit"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg"`
	// CommitURL
	CommitURL *string `json:"commitURL"`
	// Git repository
	GitRepository *string `json:"gitRepository"`
	//  AccountId
	AccountID string `json:"accountId"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	// Size
	Size *int `json:"size"`
	// OS
	Os *string `json:"os"`
	// Architecture
	Architecture *string `json:"architecture"`
	// Info
	Info *string `json:"info"`
	// Image registry
	ImageRegistryDomains []*ImageRegistryType `json:"imageRegistryDomains"`
}

func (ImageBinary) IsEntity() {}

// Image Binary Edge
type ImageBinaryEdge struct {
	// Node contains the actual image binary data
	Node *ImageBinary `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageBinaryEdge) IsEdge() {}

//  ImageBinaryInput
type ImageBinaryInput struct {
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
}

//  ImageBinaryInput
type ImageBinaryOutput struct {
	//  Id
	ID string `json:"id"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
}

// Images Binary Slice
type ImageBinarySlice struct {
	// Image edges
	Edges []*ImageBinaryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageBinarySlice) IsSlice() {}

// Image Registry entity
type ImageRegistry struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	//  AccountId
	AccountID string `json:"accountId"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTag `json:"tags"`
	// Registry
	Registry *Registry `json:"registry"`
}

func (ImageRegistry) IsEntity() {}

// Image Registry Edge
type ImageRegistryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRegistry `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRegistryEdge) IsEdge() {}

//  ImageRegistryInput
type ImageRegistryInput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTagInput `json:"tags"`
	// Registry
	Registry *RegistryInput `json:"registry"`
}

//  ImageRegistryInput
type ImageRegistryOutput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTagOutput `json:"tags"`
	// Registry
	Registry *RegistryOutput `json:"registry"`
}

// Images Registry Slice
type ImageRegistrySlice struct {
	// Image registry edges
	Edges []*ImageRegistryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRegistrySlice) IsSlice() {}

// Image Repo Tag entity
type ImageRepoTag struct {
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Created Date
	Created string `json:"created"`
	// Related binaries
	Binaries []*ImageBinary `json:"binaries"`
}

func (ImageRepoTag) IsEntity() {}

// Image repo tag Edge
type ImageRepoTagEdge struct {
	// Node contains the actual image repo tag data
	Node *ImageRepoTag `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepoTagEdge) IsEdge() {}

// Image repo tags filter arguments
type ImageRepoTagFilterArgs struct {
	// Filter image repo tags by image name
	RepositoryName string `json:"repositoryName"`
	// Filter image repo tags by tag
	Tag *string `json:"tag"`
	// Filter image repo tags by registry type
	RegistryTypes []*ImageRegistryType `json:"registryTypes"`
	// Filter image repo tags by git branch
	GitBranch *string `json:"gitBranch"`
	// Filter image repo tags by git repositories
	GitRepositories []*string `json:"gitRepositories"`
}

// Images repo tag Slice
type ImageRepoTagSlice struct {
	// Image Repository edges
	Edges []*ImageRepoTagEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepoTagSlice) IsSlice() {}

// Image repository sorting arguments
type ImageRepoTagSortArg struct {
	// Field for sorting
	Field ImageRepoTagSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Image Repository entity
type ImageRepository struct {
	// Image repository name
	Name string `json:"name"`
	// Account Id
	AccountID string `json:"accountId"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// Image repository registry domain types
	RegistryDomains []*ImageRegistryType `json:"registryDomains"`
}

func (ImageRepository) IsEntity() {}

// Image Repository Edge
type ImageRepositoryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRepository `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepositoryEdge) IsEdge() {}

// Image repository filter arguments
type ImageRepositoryFilterArgs struct {
	// Filter image repositories by image repository name
	Name *string `json:"name"`
	// Filter image repositories by image repository names array
	Names []*string `json:"names"`
	// Filter image repositories by tag
	Tag *string `json:"tag"`
	// Filter image repositories by registry type
	RegistryTypes []*ImageRegistryType `json:"registryTypes"`
	// Filter image repositories by git branch
	GitBranch *string `json:"gitBranch"`
	// Filter image repositories by git repositories
	GitRepositories []*string `json:"gitRepositories"`
}

// Images Repository Slice
type ImageRepositorySlice struct {
	// Image Repository edges
	Edges []*ImageRepositoryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepositorySlice) IsSlice() {}

// Image repository sorting arguments
type ImageRepositorySortArg struct {
	// Field for sorting
	Field ImageRepositorySortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// ImageTag
type ImageTag struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagInput struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagOutput struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// Images Entity
type Images struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Issue value
type IssueValue struct {
	// Issue url
	URL string `json:"url"`
	// Issue title
	Title string `json:"title"`
	// Issue status
	Status string `json:"status"`
	// Issue assignee
	Assignee string `json:"assignee"`
}

// K8s entity id
type K8sEntityID struct {
	// name
	Name string `json:"name"`
	// namespace
	Namespace *string `json:"namespace"`
}

// Logic entity id
type LogicEntityID struct {
	// id
	ID string `json:"id"`
}

// Pipeline metric with trend
type MetricWithTrend struct {
	// Metric value
	Value int `json:"value"`
	// Percent Diff between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Reference Entity by runtime/name/namespace
type NameReferenceInput struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// retriving many entities matching name
type NamespacedFindManyArgs struct {
	// Runtime name
	Runtime string `json:"runtime"`
	// Names
	Names []string `json:"names"`
	// Namespace
	Namespace string `json:"namespace"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName string `json:"templateName"`
	// Node children
	Children []*string `json:"children"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Message
	Message *string `json:"message"`
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Inputs
	Inputs *string `json:"inputs"`
	// Outputs
	Outputs *string `json:"outputs"`
	// Script
	Script *string `json:"script"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id"`
	// Resources Duration
	ResourcesDuration *string `json:"resourcesDuration"`
	// Template Ref
	TemplateRef *string `json:"templateRef"`
	// Host node name
	HostNodeName *string `json:"hostNodeName"`
	// Template
	Template *string `json:"template"`
	// Template scope
	TemplateScope *string `json:"templateScope"`
}

// Notification source entity
type Notification struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Relevant notification info according to the notification type
	NotificationInfo NotificationInfo `json:"notificationInfo"`
	// The specific notification type, to use for the notification icon
	NotificationType *NotificationType `json:"notificationType"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Projects
	Projects []string `json:"projects"`
}

// Notification Edge
type NotificationEdge struct {
	// Node contains the actual notification data
	Node *Notification `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// NotificationReadModelEventPayload
type NotificationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
	// Payload of event
	Payload *Notification `json:"payload"`
}

func (NotificationReadModelEventPayload) IsReadModelEventPayload() {}

// Notification Slice
type NotificationSlice struct {
	// Notification edges
	Edges []*NotificationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels"`
	// Annotations
	Annotations []*StringPair `json:"annotations"`
	// Last updated
	LastUpdated *string `json:"lastUpdated"`
	// Created
	Created *string `json:"created"`
	// K8s object uid
	UID *string `json:"uid"`
	// Favorite
	Favorite *bool `json:"favorite"`
}

// Permission model
type Permission struct {
	// The user with the permission
	User *User `json:"user"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Permission inoput
type PermissionInput struct {
	// The id of the user the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self"`
	// History of the pipeline
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity"`
}

func (Pipeline) IsBaseEntity()         {}
func (Pipeline) IsK8sLogicEntity()     {}
func (Pipeline) IsProjectBasedEntity() {}
func (Pipeline) IsEntity()             {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time"`
	// Committers
	Committers *int `json:"committers"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time"`
	// Executions
	Executions *int `json:"executions"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace string `json:"pipelineNamespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame"`
	// Success Rate stats
	SuccessRateStats *MetricWithTrend `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
}

// PipelineReadModelEventPayload type
type PipelineReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (PipelineReadModelEventPayload) IsReadModelEventPayload() {}

// Pipeline Reference
type PipelineRef struct {
	// Id
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Project
	Project string `json:"project"`
	// ProjectId
	ProjectID string `json:"projectId"`
}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats"`
}

// Pipeline Step
type PipelineStepStatistics struct {
	// Step Name
	StepName *string `json:"stepName"`
	// Template Name
	TemplateName *string `json:"templateName"`
	// Workflow Template
	WorkflowTemplate *string `json:"workflowTemplate"`
	// Node Type
	NodeType *string `json:"nodeType"`
	// Step Average duration
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Step Executions count
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
	// Step Average CPU usage
	CPUStats *MetricWithTrend `json:"cpuStats"`
	// Step Average Memory
	MemoryStats *MetricWithTrend `json:"memoryStats"`
	// Step Errors count
	ErrorsCountStats *MetricWithTrend `json:"errorsCountStats"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time"`
	// Success rate
	SuccessRate *int `json:"successRate"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name"`
}

// Pod Spec
type PodSpec struct {
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// PodTemplate Spec
type PodTemplateSpec struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Spec
	Spec *PodSpec `json:"spec"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// ProjectReadModelEventPayload type
type ProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// PullRequest
type PullRequest struct {
	// Url
	URL string `json:"url"`
	// Title
	Title string `json:"title"`
	// Committers
	Committers []*CommitterLabel `json:"committers"`
}

// PullRequestCommitter
type PullRequestCommitter struct {
	// userName
	UserName string `json:"userName"`
	// avatar
	Avatar string `json:"avatar"`
}

// PullRequest value
type PullRequestValue struct {
	// url
	URL string `json:"url"`
	// title
	Title string `json:"title"`
	// committers
	Committers []*PullRequestCommitter `json:"committers"`
}

// ReadModelEventResponse
type ReadModelEventResponse struct {
	// Account ID
	AccountID string `json:"accountId"`
	// Time of event
	Time string `json:"time"`
	// Payload of event
	Payload ReadModelEventPayload `json:"payload"`
}

// Registry
type Registry struct {
	// Domain
	Domain string `json:"domain"`
	// Registry type
	Type ImageRegistryType `json:"type"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// Original Repository Prefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// RegistryInput
type RegistryInput struct {
	// Id
	ID string `json:"id"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// RegistryInput
type RegistryOutput struct {
	// Id
	ID *string `json:"id"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// Release Entity
type Release struct {
	// Release version
	Version string `json:"version"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images"`
	// Replicas
	Replicas *int `json:"replicas"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Runtime Errors Report Arguments
type ReportRuntimeErrorsArgs struct {
	// Name of the Runtime
	Runtime string `json:"runtime"`
	// Errors
	Errors []*HealthErrorInput `json:"errors"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// History of the runtime
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

func (Runtime) IsBaseEntity()         {}
func (Runtime) IsProjectBasedEntity() {}
func (Runtime) IsK8sLogicEntity()     {}
func (Runtime) IsEntity()             {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Cluster
	Cluster string `json:"cluster"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

// Runtime notification
type RuntimeNotification struct {
	// Runtime component name
	ModifiedComponent *string `json:"modifiedComponent"`
	// Sync status
	RuntimeSyncStatus *SyncStatus `json:"runtimeSyncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
}

func (RuntimeNotification) IsNotificationInfo() {}

// RuntimeReadModelEventPayload type
type RuntimeReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (RuntimeReadModelEventPayload) IsReadModelEventPayload() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the sensor
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (Sensor) IsGitopsEntity()       {}
func (Sensor) IsBaseEntity()         {}
func (Sensor) IsProjectBasedEntity() {}
func (Sensor) IsEntity()             {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// SensorReadModelEventPayload type
type SensorReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (SensorReadModelEventPayload) IsReadModelEventPayload() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Service entity
type ServiceEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// ServiceSpec
	Spec *ServiceSpec `json:"spec"`
	// Deployment Spec Part
	Deployments []*DeploymentSpecPart `json:"deployments"`
}

func (ServiceEntity) IsGitopsEntity()       {}
func (ServiceEntity) IsBaseEntity()         {}
func (ServiceEntity) IsProjectBasedEntity() {}
func (ServiceEntity) IsEntity()             {}

// Service Entity Edge
type ServiceEntityEdge struct {
	// Node contains the actual Service data
	Node *ServiceEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ServiceEntityEdge) IsEdge() {}

// Service Slice
type ServiceEntitySlice struct {
	// Service edges
	Edges []*ServiceEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ServiceEntitySlice) IsSlice() {}

// Service Item Entity
type ServiceItem struct {
	// Name
	Name *string `json:"name"`
}

// ServicePort
type ServicePort struct {
	// AppProtocol
	AppProtocol *string `json:"appProtocol"`
	// Name
	Name *string `json:"name"`
	// NodePort
	NodePort *int `json:"nodePort"`
	// Port
	Port *int `json:"port"`
	// Protocol
	Protocol *string `json:"protocol"`
	// TargetPort
	TargetPort *string `json:"targetPort"`
}

// ServiceReadModelEventPayload type
type ServiceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ServiceReadModelEventPayload) IsReadModelEventPayload() {}

// Service sorting arguments
type ServiceSortArg struct {
	// Field for sorting
	Field ServiceSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// ServiceSpec
type ServiceSpec struct {
	// AllocateLoadBalancerNodePorts
	AllocateLoadBalancerNodePorts *bool `json:"allocateLoadBalancerNodePorts"`
	// ClusterIP
	ClusterIP *string `json:"clusterIP"`
	// ClusterIPs
	ClusterIPs []*string `json:"clusterIPs"`
	// ExternalIPs
	ExternalIPs []*string `json:"externalIPs"`
	// ExternalName
	ExternalName *string `json:"externalName"`
	// ExternalTrafficPolicy
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy"`
	// HealthCheckNodePort
	HealthCheckNodePort *int `json:"healthCheckNodePort"`
	// InternalTrafficPolicy
	InternalTrafficPolicy *string `json:"internalTrafficPolicy"`
	// IpFamilies
	IPFamilies []*string `json:"ipFamilies"`
	// IpFamilyPolicy
	IPFamilyPolicy *string `json:"ipFamilyPolicy"`
	// LoadBalancerClass
	LoadBalancerClass *string `json:"loadBalancerClass"`
	// LoadBalancerIP
	LoadBalancerIP *string `json:"loadBalancerIP"`
	// LoadBalancerSourceRanges
	LoadBalancerSourceRanges []*string `json:"loadBalancerSourceRanges"`
	// Ports
	Ports []*ServicePort `json:"ports"`
	// PublishNotReadyAddresses
	PublishNotReadyAddresses *bool `json:"publishNotReadyAddresses"`
	// Selector
	Selector []*StringPair `json:"selector"`
	// SessionAffinity
	SessionAffinity *string `json:"sessionAffinity"`
	// SessionAffinityConfig
	SessionAffinityConfig *SessionAffinityConfig `json:"sessionAffinityConfig"`
	// Type
	Type *ServiceType `json:"type"`
}

// ServiceTransition Entity
type ServiceTransition struct {
	// Name
	Name *string `json:"name"`
	// From
	From *ReleaseServiceState `json:"from"`
	// To
	To *ReleaseServiceState `json:"to"`
}

// Services filter arguments
type ServicesFilterArgs struct {
	// Filter services from a specific project
	Project *string `json:"project"`
	// Filter services from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter services from a specific namespaces
	Namespace []*string `json:"namespace"`
	// Filter services from a specific application
	Application *string `json:"application"`
	// Filter services with a specific health statuses
	HealthStatus []*HealthStatus `json:"healthStatus"`
	// Filter services by name fragment
	ServiceName *string `json:"serviceName"`
}

// SessionAffinityConfig
type SessionAffinityConfig struct {
	// ClientIP
	ClientIP *ClientIP `json:"clientIP"`
}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
}

// Args to set the permissions of a specific user to a git-source
type SetGitSourcePermissionArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The new permission to set
	Permission *PermissionInput `json:"permission"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType"`
	// Display name
	DisplayName *string `json:"displayName"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message"`
}

// Lable
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context"`
}

func (SyncError) IsError() {}

// To State Entity
type ToState struct {
	// Services
	Services []*ServiceItem `json:"services"`
}

// Transition Entity
type Transition struct {
	// Services
	Services []*ServiceTransition `json:"services"`
}

// Reference Entity by uid
type UIDReferenceInput struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Unique ID
	UID string `json:"uid"`
}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// Args to update the permissions of a git-source
type UpdateGitSourcePermissionsArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The set of permissions
	Permissions []*PermissionInput `json:"permissions"`
}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount"`
	// The customers that this user is in
	Customers []Customer `json:"customers"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate"`
	// User chosen sso of active account
	Sso *string `json:"sso"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []string `json:"eventsPayload"`
	// Pipeline refernece
	Pipeline *Pipeline `json:"pipeline"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Workflow URL
	URL *string `json:"url"`
}

func (Workflow) IsProjectBasedEntity() {}
func (Workflow) IsBaseEntity()         {}
func (Workflow) IsK8sStandardEntity()  {}
func (Workflow) IsEntity()             {}

// Workflow conditions
type WorkflowConditions struct {
	// Type
	Type *string `json:"type"`
	// Status
	Status *string `json:"status"`
}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// Command array
	Command []*string `json:"command"`
	// Args
	Args []*string `json:"args"`
	// Env map
	Env []*StringPair `json:"env"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon"`
	// Container
	Container *WorkflowContainerSpec `json:"container"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// WorkflowReadModelEventPayload type
type WorkflowReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (WorkflowReadModelEventPayload) IsReadModelEventPayload() {}

// "Repository data for workflows
type WorkflowRepository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow resources duration
type WorkflowResourcesDuration struct {
	// Cpu
	CPU *int `json:"cpu"`
	// Memory
	Memory *int `json:"memory"`
}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Pipeline filter arguments
type WorkflowStatisticsFilterArgs struct {
	// Filter pipelines from a specific pipeline
	TimeRange PipelineStatisticsFilterTimeRange `json:"timeRange"`
	// Repository name
	RepoName []*string `json:"repoName"`
	// workflow status
	Status []*WorkflowPhases `json:"status"`
	// Git Event Type
	GitEventType []*string `json:"gitEventType"`
	// Initiator
	Initiator []*string `json:"initiator"`
	// Brnach Name
	Branch []*string `json:"branch"`
	// Pipeline Name
	PipelineName []*string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace []*string `json:"pipelineNamespace"`
	// Runtime
	Runtime []*string `json:"runtime"`
}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes"`
	// Message
	Message *string `json:"message"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Stored Templates
	StoredTemplates *string `json:"storedTemplates"`
	// Stored workflow template spec
	StoredWorkflowTemplateSpec *string `json:"storedWorkflowTemplateSpec"`
	// Conditions
	Conditions []*WorkflowConditions `json:"conditions"`
	// Resources duration
	ResourcesDuration *WorkflowResourcesDuration `json:"resourcesDuration"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the workflow-template
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity()       {}
func (WorkflowTemplate) IsBaseEntity()         {}
func (WorkflowTemplate) IsProjectBasedEntity() {}
func (WorkflowTemplate) IsEntity()             {}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// WorkflowTemplateReadModelEventPayload type
type WorkflowTemplateReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (WorkflowTemplateReadModelEventPayload) IsReadModelEventPayload() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow template filter arguments
type WorkflowTemplatesFilterArgs struct {
	// Filter WorkflowTemplates from a specific project
	Project *string `json:"project"`
	// Filter WorkflowTemplates from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter WorkflowTemplates by name
	Name *string `json:"name"`
	// Filter WorkflowTemplates by git source
	GitSource *string `json:"gitSource"`
}

// Workflow filter arguments
type WorkflowsFilterArgs struct {
	// Filter workflows from a specific project
	Project *string `json:"project"`
	// Filter workflows from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter workflows from a specific namespace
	Namespace *string `json:"namespace"`
	// Filter workflows filer by pipelines
	Pipelines *NamespacedFindManyArgs `json:"pipelines"`
	// Filter workflows from a specific repositories
	Repositories []*string `json:"repositories"`
	// Filter workflows from a specific branches
	Branches []*string `json:"branches"`
	// Filter workflows from a specific event types
	EventTypes []*string `json:"eventTypes"`
	// Filter workflows from a specific initiators
	Initiators []*string `json:"initiators"`
	// Filter workflows from a specific statuses
	Statuses []*WorkflowPhases `json:"statuses"`
	// Filter workflows from a specific start date
	StartDateFrom *string `json:"startDateFrom"`
	// Filter workflows to a specific start date
	StartDateTo *string `json:"startDateTo"`
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Runtime Installation error
	HealthErrorCodesRuntimeInstallationError HealthErrorCodes = "RUNTIME_INSTALLATION_ERROR"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesRuntimeInstallationError,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesRuntimeInstallationError, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image registry domain types
type ImageRegistryType string

const (
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeOther,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeOther:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification type
type NotificationType string

const (
	// Component health status is in progress
	NotificationTypeComponentHealthProgressing NotificationType = "COMPONENT_HEALTH_PROGRESSING"
	// Component health status is unhealthy
	NotificationTypeComponentHealthUnhealthy NotificationType = "COMPONENT_HEALTH_UNHEALTHY"
	// Component sync failed
	NotificationTypeComponentSyncFail NotificationType = "COMPONENT_SYNC_FAIL"
	// Component sync completed successfully
	NotificationTypeComponentSyncSuccess NotificationType = "COMPONENT_SYNC_SUCCESS"
	// Component sync is in progress
	NotificationTypeComponentSyncSyncing NotificationType = "COMPONENT_SYNC_SYNCING"
	// Git-source created
	NotificationTypeGsCreated NotificationType = "GS_CREATED"
	// Git-source sync removed
	NotificationTypeGsRemoved NotificationType = "GS_REMOVED"
	// Git-source sync failed
	NotificationTypeGsSyncFail NotificationType = "GS_SYNC_FAIL"
	// Git-source sync completed successfully
	NotificationTypeGsSyncSuccess NotificationType = "GS_SYNC_SUCCESS"
	// Git-source sync is in progress
	NotificationTypeGsSyncSyncing NotificationType = "GS_SYNC_SYNCING"
	// Runtime install failed
	NotificationTypeRuntimeInstallFail NotificationType = "RUNTIME_INSTALL_FAIL"
	// Runtime install is in progress
	NotificationTypeRuntimeInstallProgressing NotificationType = "RUNTIME_INSTALL_PROGRESSING"
	// Runtime install completed successfully
	NotificationTypeRuntimeInstallSuccess NotificationType = "RUNTIME_INSTALL_SUCCESS"
	// Runtime uninstall failed
	NotificationTypeRuntimeUninstallFail NotificationType = "RUNTIME_UNINSTALL_FAIL"
	// Runtime uninstall is in progress
	NotificationTypeRuntimeUninstallProgressing NotificationType = "RUNTIME_UNINSTALL_PROGRESSING"
	// Runtime uninstall completed successfully
	NotificationTypeRuntimeUninstallSuccess NotificationType = "RUNTIME_UNINSTALL_SUCCESS"
	// Runtime upgrade failed
	NotificationTypeRuntimeUpgradeFail NotificationType = "RUNTIME_UPGRADE_FAIL"
	// Runtime upgrade is in progress
	NotificationTypeRuntimeUpgradeProgressing NotificationType = "RUNTIME_UPGRADE_PROGRESSING"
	// Runtime upgrade completed successfully
	NotificationTypeRuntimeUpgradeSuccess NotificationType = "RUNTIME_UPGRADE_SUCCESS"
)

var AllNotificationType = []NotificationType{
	NotificationTypeComponentHealthProgressing,
	NotificationTypeComponentHealthUnhealthy,
	NotificationTypeComponentSyncFail,
	NotificationTypeComponentSyncSuccess,
	NotificationTypeComponentSyncSyncing,
	NotificationTypeGsCreated,
	NotificationTypeGsRemoved,
	NotificationTypeGsSyncFail,
	NotificationTypeGsSyncSuccess,
	NotificationTypeGsSyncSyncing,
	NotificationTypeRuntimeInstallFail,
	NotificationTypeRuntimeInstallProgressing,
	NotificationTypeRuntimeInstallSuccess,
	NotificationTypeRuntimeUninstallFail,
	NotificationTypeRuntimeUninstallProgressing,
	NotificationTypeRuntimeUninstallSuccess,
	NotificationTypeRuntimeUpgradeFail,
	NotificationTypeRuntimeUpgradeProgressing,
	NotificationTypeRuntimeUpgradeSuccess,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeComponentHealthProgressing, NotificationTypeComponentHealthUnhealthy, NotificationTypeComponentSyncFail, NotificationTypeComponentSyncSuccess, NotificationTypeComponentSyncSyncing, NotificationTypeGsCreated, NotificationTypeGsRemoved, NotificationTypeGsSyncFail, NotificationTypeGsSyncSuccess, NotificationTypeGsSyncSyncing, NotificationTypeRuntimeInstallFail, NotificationTypeRuntimeInstallProgressing, NotificationTypeRuntimeInstallSuccess, NotificationTypeRuntimeUninstallFail, NotificationTypeRuntimeUninstallProgressing, NotificationTypeRuntimeUninstallSuccess, NotificationTypeRuntimeUpgradeFail, NotificationTypeRuntimeUpgradeProgressing, NotificationTypeRuntimeUpgradeSuccess:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline time range filter possible values
type PipelineStatisticsFilterTimeRange string

const (
	PipelineStatisticsFilterTimeRangeLast30Days PipelineStatisticsFilterTimeRange = "LAST_30_DAYS"
	PipelineStatisticsFilterTimeRangeLast7Days  PipelineStatisticsFilterTimeRange = "LAST_7_DAYS"
	PipelineStatisticsFilterTimeRangeLast90Days PipelineStatisticsFilterTimeRange = "LAST_90_DAYS"
)

var AllPipelineStatisticsFilterTimeRange = []PipelineStatisticsFilterTimeRange{
	PipelineStatisticsFilterTimeRangeLast30Days,
	PipelineStatisticsFilterTimeRangeLast7Days,
	PipelineStatisticsFilterTimeRangeLast90Days,
}

func (e PipelineStatisticsFilterTimeRange) IsValid() bool {
	switch e {
	case PipelineStatisticsFilterTimeRangeLast30Days, PipelineStatisticsFilterTimeRangeLast7Days, PipelineStatisticsFilterTimeRangeLast90Days:
		return true
	}
	return false
}

func (e PipelineStatisticsFilterTimeRange) String() string {
	return string(e)
}

func (e *PipelineStatisticsFilterTimeRange) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineStatisticsFilterTimeRange(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineStatisticsFilterTimeRange", str)
	}
	return nil
}

func (e PipelineStatisticsFilterTimeRange) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline statistics sort by measure
type PipelineStatisticsSortByMeasure string

const (
	PipelineStatisticsSortByMeasureAverageDuration PipelineStatisticsSortByMeasure = "AVERAGE_DURATION"
	PipelineStatisticsSortByMeasureExecutions      PipelineStatisticsSortByMeasure = "EXECUTIONS"
)

var AllPipelineStatisticsSortByMeasure = []PipelineStatisticsSortByMeasure{
	PipelineStatisticsSortByMeasureAverageDuration,
	PipelineStatisticsSortByMeasureExecutions,
}

func (e PipelineStatisticsSortByMeasure) IsValid() bool {
	switch e {
	case PipelineStatisticsSortByMeasureAverageDuration, PipelineStatisticsSortByMeasureExecutions:
		return true
	}
	return false
}

func (e PipelineStatisticsSortByMeasure) String() string {
	return string(e)
}

func (e *PipelineStatisticsSortByMeasure) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineStatisticsSortByMeasure(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineStatisticsSortByMeasure", str)
	}
	return nil
}

func (e PipelineStatisticsSortByMeasure) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service Sorting field
type ServiceSortingField string

const (
	// Last Update
	ServiceSortingFieldLastUpdate ServiceSortingField = "lastUpdate"
	// Service Name
	ServiceSortingFieldServiceName ServiceSortingField = "serviceName"
)

var AllServiceSortingField = []ServiceSortingField{
	ServiceSortingFieldLastUpdate,
	ServiceSortingFieldServiceName,
}

func (e ServiceSortingField) IsValid() bool {
	switch e {
	case ServiceSortingFieldLastUpdate, ServiceSortingFieldServiceName:
		return true
	}
	return false
}

func (e ServiceSortingField) String() string {
	return string(e)
}

func (e *ServiceSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceSortingField", str)
	}
	return nil
}

func (e ServiceSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ServiceType
type ServiceType string

const (
	ServiceTypeClusterIP    ServiceType = "ClusterIP"
	ServiceTypeExternalName ServiceType = "ExternalName"
	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
	ServiceTypeNodePort     ServiceType = "NodePort"
)

var AllServiceType = []ServiceType{
	ServiceTypeClusterIP,
	ServiceTypeExternalName,
	ServiceTypeLoadBalancer,
	ServiceTypeNodePort,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeClusterIP, ServiceTypeExternalName, ServiceTypeLoadBalancer, ServiceTypeNodePort:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting field
type SortingField string

const (
	// healthStatus
	SortingFieldHealthStatus SortingField = "healthStatus"
	// kind
	SortingFieldKind SortingField = "kind"
	// last deployment date
	SortingFieldLastUpdated SortingField = "lastUpdated"
	// name
	SortingFieldName SortingField = "name"
	// runtime
	SortingFieldRuntime SortingField = "runtime"
	// syncStatus
	SortingFieldSyncStatus SortingField = "syncStatus"
)

var AllSortingField = []SortingField{
	SortingFieldHealthStatus,
	SortingFieldKind,
	SortingFieldLastUpdated,
	SortingFieldName,
	SortingFieldRuntime,
	SortingFieldSyncStatus,
}

func (e SortingField) IsValid() bool {
	switch e {
	case SortingFieldHealthStatus, SortingFieldKind, SortingFieldLastUpdated, SortingFieldName, SortingFieldRuntime, SortingFieldSyncStatus:
		return true
	}
	return false
}

func (e SortingField) String() string {
	return string(e)
}

func (e *SortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingField", str)
	}
	return nil
}

func (e SortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting order
type SortingOrder string

const (
	// ascending
	SortingOrderAsc SortingOrder = "asc"
	// descending
	SortingOrderDesc SortingOrder = "desc"
)

var AllSortingOrder = []SortingOrder{
	SortingOrderAsc,
	SortingOrderDesc,
}

func (e SortingOrder) IsValid() bool {
	switch e {
	case SortingOrderAsc, SortingOrderDesc:
		return true
	}
	return false
}

func (e SortingOrder) String() string {
	return string(e)
}

func (e *SortingOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingOrder", str)
	}
	return nil
}

func (e SortingOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync success/failure
type SyncSuccess string

const (
	// FAILURE - when SyncStatus is OUT_OF_SYNC or UNKNOWN
	SyncSuccessFailure SyncSuccess = "FAILURE"
	// SUCCESS - when SyncStatus is SYNCED
	SyncSuccessSuccess SyncSuccess = "SUCCESS"
)

var AllSyncSuccess = []SyncSuccess{
	SyncSuccessFailure,
	SyncSuccessSuccess,
}

func (e SyncSuccess) IsValid() bool {
	switch e {
	case SyncSuccessFailure, SyncSuccessSuccess:
		return true
	}
	return false
}

func (e SyncSuccess) String() string {
	return string(e)
}

func (e *SyncSuccess) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncSuccess(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncSuccess", str)
	}
	return nil
}

func (e SyncSuccess) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

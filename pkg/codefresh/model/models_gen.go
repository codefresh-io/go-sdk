// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Event
type Event interface {
	IsEvent()
}

// Gitops entity
type GitopsEntity interface {
	IsGitopsEntity()
}

// Page
type Page interface {
	IsPage()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

// Sensor trigger
type SensorTrigger interface {
	IsSensorTrigger()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name string `json:"name"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (Component) IsBaseEntity()         {}
func (Component) IsGitopsEntity()       {}
func (Component) IsProjectBasedEntity() {}
func (Component) IsEntity()             {}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// Component Page
type ComponentPage struct {
	// Total amount of components
	TotalCount int `json:"totalCount"`
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (ComponentPage) IsPage() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Environment Variable
type EnvVar struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
}

// Error
type Error struct {
	// Type
	Type *ErrorTypes `json:"type"`
	// Code
	Code *int `json:"code"`
	// Title
	Title *string `json:"title"`
	// Message
	Message *string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Eventbus
	Eventbus string `json:"eventbus"`
	// Events
	Events []Event `json:"events"`
}

func (EventSource) IsBaseEntity()         {}
func (EventSource) IsGitopsEntity()       {}
func (EventSource) IsProjectBasedEntity() {}
func (EventSource) IsEntity()             {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// Event source Page
type EventSourcePage struct {
	// Total amount of event sources
	TotalCount int `json:"totalCount"`
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (EventSourcePage) IsPage() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

//  EventResponse
type EventsResponse struct {
	// Name of event
	Name EventName `json:"name"`
	// Payload of event
	Payload *string `json:"payload"`
	// Time of event
	Time string `json:"time"`
}

// Git integration entity
type GitIntegration struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Git provider
	Provider *GitProviders `json:"provider"`
	// API URL of the git provider
	APIURL string `json:"apiUrl"`
}

func (GitIntegration) IsGitopsEntity()       {}
func (GitIntegration) IsBaseEntity()         {}
func (GitIntegration) IsProjectBasedEntity() {}
func (GitIntegration) IsEntity()             {}

// Git integration Edge
type GitIntegrationEdge struct {
	// Node contains the actual git integration data
	Node *GitIntegration `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitIntegrationEdge) IsEdge() {}

// Git integration Page
type GitIntegrationPage struct {
	// Total amount of git integration
	TotalCount int `json:"totalCount"`
	// Git integration edges
	Edges []*GitIntegrationEdge `json:"edges"`
	// Git integration information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (GitIntegrationPage) IsPage() {}

// Git integration Slice
type GitIntegrationSlice struct {
	// Git integration edges
	Edges []*GitIntegrationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitIntegrationSlice) IsSlice() {}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (GitSource) IsGitopsEntity()       {}
func (GitSource) IsBaseEntity()         {}
func (GitSource) IsProjectBasedEntity() {}
func (GitSource) IsEntity()             {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git source Page
type GitSourcePage struct {
	// Total amount of git sources
	TotalCount int `json:"totalCount"`
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (GitSourcePage) IsPage() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource"`
	// Path
	Path string `json:"path"`
	// Git revision
	Revision string `json:"revision"`
	// Git manifest
	GitManifest string `json:"gitManifest"`
}

// Http Trigger
type HTTPTrigger struct {
	// Name
	Name string `json:"name"`
	// Conditions
	Conditions string `json:"conditions"`
	// Url
	URL string `json:"url"`
	// Method
	Method string `json:"method"`
}

func (HTTPTrigger) IsSensorTrigger() {}

// Me
type Me struct {
	// The user id
	ID string `json:"id"`
	// The roles of the user provide specific permission for the current user
	Roles []*UserRole `json:"roles"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount"`
	// The customers that this user is in
	Customers []Customer `json:"customers"`
	// The current status of this user
	Status *UserStatus `json:"status"`
	// Provide details about this user
	Details *UserDetails `json:"details"`
	// Provide info on user
	Info *UserInfo `json:"info"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description"`
	// Namespace
	Namespace string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels"`
	// Annotations
	Annotations []*StringPair `json:"annotations"`
	// Last updated
	LastUpdated *string `json:"lastUpdated"`
	// Created
	Created *string `json:"created"`
}

// Information about current page
type PageInfo struct {
	// Cursor for the first result in the page
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the page
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next page
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous page
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Dependencies
	Dependencies []*SensorDependency `json:"dependencies"`
	// Trigger name
	Trigger string `json:"trigger"`
}

func (Pipeline) IsEntity()             {}
func (Pipeline) IsBaseEntity()         {}
func (Pipeline) IsProjectBasedEntity() {}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline Page
type PipelinePage struct {
	// Total amount of pipelines
	TotalCount int `json:"totalCount"`
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (PipelinePage) IsPage() {}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// Project Page
type ProjectPage struct {
	// Total amount of Projects
	TotalCount int `json:"totalCount"`
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (ProjectPage) IsPage() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// Release Entity
type Release struct {
	// Release version
	Version string `json:"version"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Cluster
	Cluster string `json:"cluster"`
	// Runtime version
	RuntimeVersion string `json:"runtimeVersion"`
}

func (Runtime) IsEntity()             {}
func (Runtime) IsBaseEntity()         {}
func (Runtime) IsProjectBasedEntity() {}
func (Runtime) IsGitopsEntity()       {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Page
type RuntimePage struct {
	// Total amount of runtimes
	TotalCount int `json:"totalCount"`
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (RuntimePage) IsPage() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Dependencies
	Dependencies []*SensorDependency `json:"dependencies"`
	// Triggers
	Triggers []SensorTrigger `json:"triggers"`
}

func (Sensor) IsEntity()             {}
func (Sensor) IsGitopsEntity()       {}
func (Sensor) IsBaseEntity()         {}
func (Sensor) IsProjectBasedEntity() {}

// Sensor dependency
type SensorDependency struct {
	// Name
	Name string `json:"name"`
	// EventSource name
	EventSource string `json:"eventSource"`
	// Event name
	Event string `json:"event"`
}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// Sensor Page
type SensorPage struct {
	// Total amount of sensors
	TotalCount int `json:"totalCount"`
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (SensorPage) IsPage() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns workflow templates after the provided cursor
	After *string `json:"after"`
	// Returns workflow templates before the provided cursor
	Before *string `json:"before"`
	// Returns the first X workflow templates
	First *int `json:"first"`
	// Returns the last X workflow templates
	Last *int `json:"last"`
}

// Lable
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// "User Details
type UserDetails struct {
	// The user name
	Name string `json:"name"`
	// User image url
	Image *string `json:"image"`
}

// "User statistics
type UserInfo struct {
	// The user name
	Name *string `json:"name"`
	// Register date
	RegisterDate *string `json:"registerDate"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
}

func (Workflow) IsEntity()             {}
func (Workflow) IsProjectBasedEntity() {}
func (Workflow) IsBaseEntity()         {}

// Container spec
type WorkflowContainerSpec struct {
	// Name
	Name string `json:"name"`
	// Image
	Image string `json:"image"`
	// Command
	Command []string `json:"command"`
	// Args
	Args []string `json:"args"`
	// Environment variables
	Env []*EnvVar `json:"env"`
}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	Template WorkflowSpecTemplate `json:"template"`
	// Dependencies
	Dependencies []string `json:"dependencies"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Failfast
	Failfast *bool `json:"failfast"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// Workflow Page
type WorkflowPage struct {
	// Total amount of workflows
	TotalCount int `json:"totalCount"`
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (WorkflowPage) IsPage() {}

// Workflow template ref
type WorkflowRefTemplate struct {
	// Name
	Name string `json:"name"`
	// Template reference
	Template WorkflowSpecTemplate `json:"template"`
}

func (WorkflowRefTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint string `json:"entrypoint"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates"`
}

// Workflow standard template
type WorkflowStandardTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon"`
	// Container to run for this template
	Container *WorkflowContainerSpec `json:"container"`
}

func (WorkflowStandardTemplate) IsWorkflowSpecTemplate() {}

// Workflow status
type WorkflowStatus struct {
	// Creation time
	CreatedAt string `json:"createdAt"`
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Message
	Message *string `json:"message"`
	// Previous statuses
	Statuses []*WorkflowStatusHistoryItem `json:"statuses"`
}

// Workflow status history item
type WorkflowStatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowPhases `json:"phase"`
	// Message
	Message *string `json:"message"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	Template WorkflowSpecTemplate `json:"template"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []*Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Workflow *WorkflowSpec `json:"workflow"`
}

func (WorkflowTemplate) IsEntity()             {}
func (WorkflowTemplate) IsGitopsEntity()       {}
func (WorkflowTemplate) IsBaseEntity()         {}
func (WorkflowTemplate) IsProjectBasedEntity() {}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// WorkflowTemplate Page
type WorkflowTemplatePage struct {
	// Total amount of workflow templates
	TotalCount int `json:"totalCount"`
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Page information
	PageInfo *PageInfo `json:"pageInfo"`
}

func (WorkflowTemplatePage) IsPage() {}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Http Trigger
type WorkflowTrigger struct {
	// Name
	Name string `json:"name"`
	// Conditions
	Conditions string `json:"conditions"`
	// Workflow manifest
	Workflow string `json:"workflow"`
	// Operation
	Op WorkflowTriggerOperation `json:"op"`
}

func (WorkflowTrigger) IsSensorTrigger() {}

// Error types
type ErrorTypes string

const (
	// Permission error
	ErrorTypesPermission ErrorTypes = "PERMISSION"
	// Syntax error
	ErrorTypesSyntax ErrorTypes = "SYNTAX"
)

var AllErrorTypes = []ErrorTypes{
	ErrorTypesPermission,
	ErrorTypesSyntax,
}

func (e ErrorTypes) IsValid() bool {
	switch e {
	case ErrorTypesPermission, ErrorTypesSyntax:
		return true
	}
	return false
}

func (e ErrorTypes) String() string {
	return string(e)
}

func (e *ErrorTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorTypes", str)
	}
	return nil
}

func (e ErrorTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

//  EventName
type EventName string

const (
	EventNameKeepAlive  EventName = "KEEP_ALIVE"
	EventNameTestEventA EventName = "TEST_EVENT_A"
	EventNameTestEventB EventName = "TEST_EVENT_B"
)

var AllEventName = []EventName{
	EventNameKeepAlive,
	EventNameTestEventA,
	EventNameTestEventB,
}

func (e EventName) IsValid() bool {
	switch e {
	case EventNameKeepAlive, EventNameTestEventA, EventNameTestEventB:
		return true
	}
	return false
}

func (e EventName) String() string {
	return string(e)
}

func (e *EventName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventName", str)
	}
	return nil
}

func (e EventName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Git Providers
type GitProviders string

const (
	// Github
	GitProvidersGithub GitProviders = "GITHUB"
	// Gitlab
	GitProvidersGitlab GitProviders = "GITLAB"
)

var AllGitProviders = []GitProviders{
	GitProvidersGithub,
	GitProvidersGitlab,
}

func (e GitProviders) IsValid() bool {
	switch e {
	case GitProvidersGithub, GitProvidersGitlab:
		return true
	}
	return false
}

func (e GitProviders) String() string {
	return string(e)
}

func (e *GitProviders) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitProviders(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitProviders", str)
	}
	return nil
}

func (e GitProviders) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// "User role provide specific permission for the current user
type UserRole string

const (
	// Account Admin role can control codefresh
	UserRoleAccountAdmin UserRole = "ACCOUNT_ADMIN"
	// Admin role can control the entire system
	UserRoleAdmin UserRole = "ADMIN"
	// Regular user can do basic operations the current account
	UserRoleUser UserRole = "USER"
)

var AllUserRole = []UserRole{
	UserRoleAccountAdmin,
	UserRoleAdmin,
	UserRoleUser,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleAccountAdmin, UserRoleAdmin, UserRoleUser:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// "User status active or disable
type UserStatus string

const (
	// New user
	UserStatusNew UserStatus = "NEW"
	// Pending user
	UserStatusPending UserStatus = "PENDING"
	// Suspended
	UserStatusSuspended UserStatus = "SUSPENDED"
	// Unverifed user
	UserStatusUnverifed UserStatus = "UNVERIFED"
)

var AllUserStatus = []UserStatus{
	UserStatusNew,
	UserStatusPending,
	UserStatusSuspended,
	UserStatusUnverifed,
}

func (e UserStatus) IsValid() bool {
	switch e {
	case UserStatusNew, UserStatusPending, UserStatusSuspended, UserStatusUnverifed:
		return true
	}
	return false
}

func (e UserStatus) String() string {
	return string(e)
}

func (e *UserStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserStatus", str)
	}
	return nil
}

func (e UserStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow phases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "ERROR"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "FAILED"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "PENDING"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "RUNNING"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "SUCCEEDED"
	// Terminated
	WorkflowPhasesTerminated WorkflowPhases = "TERMINATED"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
	WorkflowPhasesTerminated,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded, WorkflowPhasesTerminated:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow Trigger Operation
type WorkflowTriggerOperation string

const (
	// Resubmit
	WorkflowTriggerOperationResubmit WorkflowTriggerOperation = "RESUBMIT"
	// Resume
	WorkflowTriggerOperationResume WorkflowTriggerOperation = "RESUME"
	// Retry
	WorkflowTriggerOperationRetry WorkflowTriggerOperation = "RETRY"
	// Submit
	WorkflowTriggerOperationSubmit WorkflowTriggerOperation = "SUBMIT"
	// Suspend
	WorkflowTriggerOperationSuspend WorkflowTriggerOperation = "SUSPEND"
	// Terminate
	WorkflowTriggerOperationTerminate WorkflowTriggerOperation = "TERMINATE"
)

var AllWorkflowTriggerOperation = []WorkflowTriggerOperation{
	WorkflowTriggerOperationResubmit,
	WorkflowTriggerOperationResume,
	WorkflowTriggerOperationRetry,
	WorkflowTriggerOperationSubmit,
	WorkflowTriggerOperationSuspend,
	WorkflowTriggerOperationTerminate,
}

func (e WorkflowTriggerOperation) IsValid() bool {
	switch e {
	case WorkflowTriggerOperationResubmit, WorkflowTriggerOperationResume, WorkflowTriggerOperationRetry, WorkflowTriggerOperationSubmit, WorkflowTriggerOperationSuspend, WorkflowTriggerOperationTerminate:
		return true
	}
	return false
}

func (e WorkflowTriggerOperation) String() string {
	return string(e)
}

func (e *WorkflowTriggerOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowTriggerOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowTriggerOperation", str)
	}
	return nil
}

func (e WorkflowTriggerOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

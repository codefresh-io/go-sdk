// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Application tree item might be Application or ApplicationSet
type ApplicationTreeItem interface {
	IsApplicationTreeItem()
}

// ArgoCD Notification
type ArgoCDNotification interface {
	IsArgoCDNotification()
}

// ArgoEvents Notification
type ArgoEventsNotification interface {
	IsArgoEventsNotification()
}

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// Favorable
type Favorable interface {
	IsFavorable()
}

// Notification That is part of a process
type GitOpsNotification interface {
	IsGitOpsNotification()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	BaseEntity
	IsGitopsEntity()
}

// IDP Entity
type IDP interface {
	IsIDP()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Notification Base type
type Notification interface {
	IsNotification()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

// ReadModelEventPayload base interface
type ReadModelEventPayload interface {
	IsReadModelEventPayload()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations"`
	// Users that are attached to this account
	Users []*User `json:"users"`
	// Ids of all users that have account admin permission to this account
	Admins []string `json:"admins"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
	// Account security
	Security *SecurityInfo `json:"security"`
	// Collaborators
	Collaborators *AccountCollaborators `json:"collaborators"`
	// Private account owner
	PrivateAccountOwner *string `json:"privateAccountOwner"`
	// Shared config repo url
	SharedConfigRepo *string `json:"sharedConfigRepo"`
	// Features supported by all runtimes
	RuntimeFeatures []*RuntimeFeature `json:"runtimeFeatures"`
	// Supports Managed Runtime
	SupportsManagedRuntime *bool `json:"supportsManagedRuntime"`
}

// AccountCollaborators
type AccountCollaborators struct {
	// Limit
	Limit *int `json:"limit"`
	// Used
	Used *int `json:"used"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle"`
	// Add ability to create/edit pipeline from UI in the configuration tab
	CreatePipelineArguments *bool `json:"createPipelineArguments"`
	// Add ability to see workflow templates list page
	CsdpWorkflowTemplates *bool `json:"csdpWorkflowTemplates"`
	// Add ability to see additonal widgets on the dashboard in home page
	CsdpDashboardWidgets *bool `json:"csdpDashboardWidgets"`
	// Add ability to see and access DORA metrics page
	CsdpDoraMetrics *bool `json:"csdpDoraMetrics"`
	// Add ability to track user's activity on the pages
	CsdpFullStoryIntegration *bool `json:"csdpFullStoryIntegration"`
	// Add ability to see and access integration widgets on the dashboard
	CsdpManagedArgo *bool `json:"csdpManagedArgo"`
	// Add ability to force reload route when navigation failed due to chunk error
	CsdpReloadOnChunkErrorFeature *bool `json:"csdpReloadOnChunkErrorFeature"`
	// Show CSDP runtime resources in applications list
	ShowCSDPRuntimeResources *bool `json:"showCSDPRuntimeResources"`
	// Shows button that links to classic codefresh
	ShowClassicCodefreshButton *bool `json:"showClassicCodefreshButton"`
	// Support ability to use oauth2 for automatic registration
	Oauth2AutomaticRegistration *bool `json:"oauth2AutomaticRegistration"`
	// Support ability to add integrations
	CsdpIntegrations *bool `json:"csdpIntegrations"`
	// Support ability to add Amazon ECR integration
	CsdpAmazonECRIntegration *bool `json:"csdpAmazonECRIntegration"`
	// Support ability to add authentications
	CsdpAuthentication *bool `json:"csdpAuthentication"`
	// Gives access to application resource details
	ShowAppResourceDetails *bool `json:"showAppResourceDetails"`
	// Gives access to application current state graph
	ShowAppCurrentStateGraph *bool `json:"showAppCurrentStateGraph"`
	// Gives access to application release rollout details drawer
	ShowAppRolloutDetails *bool `json:"showAppRolloutDetails"`
	// Gives access to application release analysis run details drawer
	ShowAppAnalysisRunsDetails *bool `json:"showAppAnalysisRunsDetails"`
	// Filter Applications By User Permissions
	FilterAppsByUserPermissions *bool `json:"filterAppsByUserPermissions"`
	// Gives access to application edit flow
	CsdpApplicationEdit *bool `json:"csdpApplicationEdit"`
	// Adds ability to delete an application
	CsdpApplicationDelete *bool `json:"csdpApplicationDelete"`
	// To build correct references beetween apps and appSets we always define metadata.cluster=https://kubernetes.default.svc because they always within same cluster
	UseDefaultSvcApplicationClusterMetadata *bool `json:"useDefaultSvcApplicationClusterMetadata"`
	// Sets default codefresh authentication for runtime
	UseCodefreshAuthForManagedRuntime *bool `json:"useCodefreshAuthForManagedRuntime"`
	// Retrieve runtime features for the active account
	CsdpRuntimesCompatibility *bool `json:"csdpRuntimesCompatibility"`
	// Cut refsBy if parent app not present in list of applications
	CsdpAppUnexistedRefByCut *bool `json:"csdpAppUnexistedRefByCut"`
	// Ability to sync application
	CsdpApplicationSync *bool `json:"csdpApplicationSync"`
	// Ability to refresh application
	CsdpApplicationRefresh *bool `json:"csdpApplicationRefresh"`
	// Ability to show application details
	CsdpApplicationDetails *bool `json:"csdpApplicationDetails"`
	// Adds ability to see and download audit logs
	CsdpAudit *bool `json:"csdpAudit"`
	// Enables new application errors view
	NewApplicationErrorsView *bool `json:"newApplicationErrorsView"`
	// Hides first release till it doesn't have attached rollout
	CsdpHideFirstRelease *bool `json:"csdpHideFirstRelease"`
	// Supports GitLab and Bitbucket for managed runtime
	CsdpGitlabAndBitbucketSupportForManagedRuntime *bool `json:"csdpGitlabAndBitbucketSupportForManagedRuntime"`
	// New application header with sync status, last sync result
	CsdpApplicationNewHeader *bool `json:"csdpApplicationNewHeader"`
	// Applications dashboard cards view
	ApplicationsDashboardCardsView *bool `json:"applicationsDashboardCardsView"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
}

// AnalysisRun
type AnalysisRun struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Rollout revision
	Revision int `json:"revision"`
	// Analysis Run Status
	Status *AnalysisRunStatus `json:"status"`
	// Analysis Run spec
	Spec *AnalysisRunSpec `json:"spec"`
}

func (AnalysisRun) IsK8sStandardEntity() {}
func (AnalysisRun) IsEntity()            {}

// Analysis Datadog Spec
type AnalysisRunDatadogSpec struct {
	// Query
	Query string `json:"query"`
}

// AnalysisRun Edge
type AnalysisRunEdge struct {
	// Node contains the actual analysis run data
	Node *AnalysisRun `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (AnalysisRunEdge) IsEdge() {}

// Analysis Kayenta Spec
type AnalysisRunKayentaSpec struct {
	// Address
	Address string `json:"address"`
}

// Analysis run spec object
type AnalysisRunMetricSpec struct {
	// Name
	Name string `json:"name"`
	// Interval
	Interval *string `json:"interval"`
	// Success Condition
	SuccessCondition *string `json:"successCondition"`
	// Failure Condition
	FailureCondition *string `json:"failureCondition"`
	// Failure Limit
	FailureLimit *int `json:"failureLimit"`
	// Count
	Count *int `json:"count"`
	// Initial Delay
	InitialDelay *string `json:"initialDelay"`
	// Provider
	Provider *AnalysisRunProviderSpec `json:"provider"`
}

// Analysis NewRelic Spec
type AnalysisRunNewRelicSpec struct {
	// Query
	Query string `json:"query"`
}

// Analysis Run Prometheus spec
type AnalysisRunPrometheusSpec struct {
	// Address
	Address string `json:"address"`
	// Query
	Query string `json:"query"`
}

// Analysis status object
type AnalysisRunProviderSpec struct {
	// Job
	Job *string `json:"job"`
	// Prometheus
	Prometheus *AnalysisRunPrometheusSpec `json:"prometheus"`
	// Datadog
	Datadog *AnalysisRunDatadogSpec `json:"datadog"`
	// New Relic
	NewRelic *AnalysisRunNewRelicSpec `json:"newRelic"`
	// Wavefront
	Wavefront *AnalysisRunWavefrontSpec `json:"wavefront"`
	// Web
	Web *AnalysisRunWebSpec `json:"web"`
	// Kayenta
	Kayenta *AnalysisRunKayentaSpec `json:"kayenta"`
	// Cloud Watch
	CloudWatch *string `json:"cloudWatch"`
}

// AnalysisRun Slice
type AnalysisRunSlice struct {
	// Analysis run edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (AnalysisRunSlice) IsSlice() {}

// Analysis run spec metrics
type AnalysisRunSpec struct {
	// Metrics
	Metrics []*AnalysisRunMetricSpec `json:"metrics"`
}

// Analysis status object
type AnalysisRunStatus struct {
	// Message
	Message *string `json:"message"`
	// Metric results
	MetricResults []*MetricResult `json:"metricResults"`
	// Total Successful
	TotalSuccessful int `json:"totalSuccessful"`
	// Total Failed
	TotalFailed int `json:"totalFailed"`
	// Total Inconclusive
	TotalInconclusive int `json:"totalInconclusive"`
	// Total Error
	TotalError int `json:"totalError"`
	// Entire state of analysis
	Phase *AnalysisPhases `json:"phase"`
}

// Analysis Wavefront Spec
type AnalysisRunWavefrontSpec struct {
	// Address
	Address string `json:"address"`
	// Query
	Query string `json:"query"`
}

// Analysis Web Spec
type AnalysisRunWebSpec struct {
	// Url
	URL string `json:"url"`
}

// Annotation
type Annotation struct {
	// Annotation type
	Type *string `json:"type"`
	// Annotation value
	Value *string `json:"value"`
	// Annotation accountId
	AccountID *string `json:"accountId"`
	// Annotation entityId
	EntityID *string `json:"entityId"`
	// Annotation entityType
	EntityType *string `json:"entityType"`
	// Annotation key
	Key *string `json:"key"`
}

// Args to set annotation for entity
type AnnotationArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
	// Event-source issueValue
	IssueValue *IssueValue `json:"issueValue"`
	// Event-source pullRequestValue
	PullRequestValue *PullRequestValue `json:"pullRequestValue"`
}

// Application Edge
type AnnotationEdge struct {
	// Node contains the actual application data
	Node *Annotation `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter annotation
type AnnotationFilterArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
}

// Annotation Slice
type AnnotationSlice struct {
	// Annotation edges
	Edges []*AnnotationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token"`
}

// AppProjectReadModelEventPayload type
type AppProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (AppProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Number of resources
	Size *int `json:"size"`
	// Revision
	Revision *string `json:"revision"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Favorites
	Favorites []string `json:"favorites"`
	// Argo CD application destination config
	Destination *ArgoCDApplicationDestination `json:"destination"`
	// Include files
	Include *string `json:"include"`
	// Exclude files
	Exclude *string `json:"exclude"`
	// Operation State (argo)
	OperationState *ApplicationOperationState `json:"operationState"`
	// Sync info (argo)
	Sync *ApplicationSyncStatus `json:"sync"`
}

func (Application) IsApplicationTreeItem() {}
func (Application) IsGitopsEntity()        {}
func (Application) IsBaseEntity()          {}
func (Application) IsProjectBasedEntity()  {}
func (Application) IsFavorable()           {}
func (Application) IsEntity()              {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

// ApplicationField Entity
type ApplicationField struct {
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Issues
	Issues []*Annotation `json:"issues"`
	// PullRequest
	Prs []*Annotation `json:"prs"`
	// Committers
	Committers []*CommitterLabel `json:"committers"`
	// Build
	Builds []*Build `json:"builds"`
}

// Application form data object
type ApplicationFormData struct {
	// Metadata
	Metadata *ApplicationFormMetadata `json:"metadata"`
	// Destination info
	Destination *ApplicationFormDestination `json:"destination"`
	// Application source
	Source *ApplicationFormSource `json:"source"`
	// Project of application
	Project string `json:"project"`
	// Sync policy settings
	SyncPolicy *ApplicationFormSyncPolicy `json:"syncPolicy"`
}

// Application form Destination
type ApplicationFormDestination struct {
	// Cluster name
	Name *string `json:"name"`
	// Destination namespace
	Namespace *string `json:"namespace"`
	// Cluster address
	Server *string `json:"server"`
}

// Application form input data object
type ApplicationFormInputData struct {
	// Metadata
	Metadata *ApplicationFormInputMetadata `json:"metadata"`
	// Destination info
	Destination *ApplicationFormInputDestination `json:"destination"`
	// Application source
	Source *ApplicationFormInputSource `json:"source"`
	// Project of application
	Project string `json:"project"`
	// Sync policy settings
	SyncPolicy *ApplicationFormInputSyncPolicy `json:"syncPolicy"`
}

// Application form Destination
type ApplicationFormInputDestination struct {
	// Cluster name
	Name *string `json:"name"`
	// Destination namespace
	Namespace *string `json:"namespace"`
	// Cluster address
	Server *string `json:"server"`
}

// Application form metadata
type ApplicationFormInputMetadata struct {
	// Application name
	Name string `json:"name"`
	// Application namespace
	Namespace *string `json:"namespace"`
	// Application finalizers
	Finalizers []string `json:"finalizers"`
}

// Application form Source
type ApplicationFormInputSource struct {
	// Path
	Path *string `json:"path"`
	// Repository url
	RepoURL string `json:"repoURL"`
	// Target revision
	TargetRevision string `json:"targetRevision"`
	// Helm chart
	Chart *string `json:"chart"`
	// Directory
	Directory *ApplicationFormInputSourceDirectory `json:"directory"`
	// HEML
	Helm *ApplicationFormInputSourceHelm `json:"helm"`
	// Kustomize
	Kustomize *ApplicationFormInputSourceKustomize `json:"kustomize"`
	// Ksonnet
	Ksonnet *ApplicationFormInputSourceKsonnet `json:"ksonnet"`
	// Plugin
	Plugin *ApplicationFormInputSourcePlugin `json:"plugin"`
}

// Application form Source Directory
type ApplicationFormInputSourceDirectory struct {
	// Directory recurse
	Recurse *bool `json:"recurse"`
	// Exclude
	Exclude *string `json:"exclude"`
	// Include
	Include *string `json:"include"`
	// Directory jsonnet options
	Jsonnet *ApplicationFormInputSourceDirectoryJsonnet `json:"jsonnet"`
}

// Application form Source Directory Jsonnet
type ApplicationFormInputSourceDirectoryJsonnet struct {
	// Top level vars
	Tlas []*NameValueCodeInput `json:"tlas"`
	// External vars
	ExtVars []*NameValueCodeInput `json:"extVars"`
	// Libs
	Libs []string `json:"libs"`
}

// Application form Source Helm
type ApplicationFormInputSourceHelm struct {
	// Values
	Values *string `json:"values"`
	// Value files
	ValueFiles []string `json:"valueFiles"`
	// Parameters
	Parameters []*NameValueInput `json:"parameters"`
}

// Application form Source Ksonnet
type ApplicationFormInputSourceKsonnet struct {
	// Environment
	Environment string `json:"environment"`
}

// Application form Source Kustomize
type ApplicationFormInputSourceKustomize struct {
	// Name prefix
	NamePrefix *string `json:"namePrefix"`
	// Name suffix
	NameSuffix *string `json:"nameSuffix"`
	// Images
	Images []string `json:"images"`
}

// Application form Source Plugin
type ApplicationFormInputSourcePlugin struct {
	// Plagin name
	Name string `json:"name"`
	// Array of env variables
	Env []*NameValueInput `json:"env"`
}

// Application form Sync Automated Policy
type ApplicationFormInputSyncAutomatedPolicy struct {
	// Prune policy flag
	Prune *bool `json:"prune"`
	// Self heal policy flag
	SelfHeal *bool `json:"selfHeal"`
}

// Application form Sync Policy
type ApplicationFormInputSyncPolicy struct {
	// Automated sync policy options
	Automated *ApplicationFormInputSyncAutomatedPolicy `json:"automated"`
	// Sync options
	SyncOptions []string `json:"syncOptions"`
	// Retry options
	Retry *ApplicationFormInputSyncRetryOptions `json:"retry"`
}

// Application form Sync Policy retry options
type ApplicationFormInputSyncRetryBackoffOptions struct {
	// Duration
	Duration string `json:"duration"`
	// Max duration
	MaxDuration string `json:"maxDuration"`
	// Factor
	Factor int `json:"factor"`
}

// Application form Sync Policy retry options
type ApplicationFormInputSyncRetryOptions struct {
	// Retries amount
	Limit int `json:"limit"`
	// Backoff options
	Backoff *ApplicationFormInputSyncRetryBackoffOptions `json:"backoff"`
}

// Application form metadata
type ApplicationFormMetadata struct {
	// Application name
	Name string `json:"name"`
	// Application namespace
	Namespace *string `json:"namespace"`
	// Application finalizers
	Finalizers []string `json:"finalizers"`
}

// Application form Source
type ApplicationFormSource struct {
	// Path
	Path *string `json:"path"`
	// Repository url
	RepoURL string `json:"repoURL"`
	// Target revision
	TargetRevision *string `json:"targetRevision"`
	// Helm chart
	Chart *string `json:"chart"`
	// Directory
	Directory *ApplicationFormSourceDirectory `json:"directory"`
	// HEML
	Helm *ApplicationFormSourceHelm `json:"helm"`
	// Kustomize
	Kustomize *ApplicationFormSourceKustomize `json:"kustomize"`
	// Ksonnet
	Ksonnet *ApplicationFormSourceKsonnet `json:"ksonnet"`
	// Plugin
	Plugin *ApplicationFormSourcePlugin `json:"plugin"`
}

// Application form Source Directory
type ApplicationFormSourceDirectory struct {
	// Directory recurse
	Recurse *bool `json:"recurse"`
	// Exclude
	Exclude *string `json:"exclude"`
	// Include
	Include *string `json:"include"`
	// Directory jsonnet options
	Jsonnet *ApplicationFormSourceDirectoryJsonnet `json:"jsonnet"`
}

// Application form Source Directory Jsonnet
type ApplicationFormSourceDirectoryJsonnet struct {
	// Top level vars
	Tlas []*NameValueCodeOutput `json:"tlas"`
	// External vars
	ExtVars []*NameValueCodeOutput `json:"extVars"`
	// Libs
	Libs []string `json:"libs"`
}

// Application form Source Helm
type ApplicationFormSourceHelm struct {
	// Values
	Values *string `json:"values"`
	// Value files
	ValueFiles []string `json:"valueFiles"`
	// Parameters
	Parameters []*NameValueOutput `json:"parameters"`
}

// Application form Source Ksonnet
type ApplicationFormSourceKsonnet struct {
	// Environment
	Environment string `json:"environment"`
}

// Application form Source Kustomize
type ApplicationFormSourceKustomize struct {
	// Name prefix
	NamePrefix *string `json:"namePrefix"`
	// Name suffix
	NameSuffix *string `json:"nameSuffix"`
	// Images
	Images []string `json:"images"`
}

// Application form Source Plugin
type ApplicationFormSourcePlugin struct {
	// Plagin name
	Name string `json:"name"`
	// Array of env variables
	Env []*NameValueOutput `json:"env"`
}

// Application form Sync Automated Policy
type ApplicationFormSyncAutomatedPolicy struct {
	// Prune policy flag
	Prune *bool `json:"prune"`
	// Self heal policy flag
	SelfHeal *bool `json:"selfHeal"`
}

// Application form Sync Policy
type ApplicationFormSyncPolicy struct {
	// Automated sync policy options
	Automated *ApplicationFormSyncAutomatedPolicy `json:"automated"`
	// Sync options
	SyncOptions []string `json:"syncOptions"`
	// Retry options
	Retry *ApplicationFormSyncRetryOptions `json:"retry"`
}

// Application form Sync Policy retry options
type ApplicationFormSyncRetryBackoffOptions struct {
	// Duration
	Duration string `json:"duration"`
	// Max duration
	MaxDuration string `json:"maxDuration"`
	// Factor
	Factor int `json:"factor"`
}

// Application form Sync Policy retry options
type ApplicationFormSyncRetryOptions struct {
	// Retries amount
	Limit int `json:"limit"`
	// Backoff options
	Backoff *ApplicationFormSyncRetryBackoffOptions `json:"backoff"`
}

// Application manifest hierarchy
type ApplicationManifestHierarchy struct {
	// Block name
	Name string `json:"name"`
	// Block line number
	Line *int `json:"line"`
	// Nested items
	Children []*ApplicationManifestHierarchy `json:"children"`
}

// Application Operation
type ApplicationOperation struct {
	// Initiated By
	InitiatedBy *ApplicationOperationInitiatedBy `json:"initiatedBy"`
	// Retry
	Retry *ApplicationOperationRetryOptions `json:"retry"`
	// Info
	Info []*NameValueOutput `json:"info"`
	// Sync
	Sync *ApplicationOperationSync `json:"sync"`
}

// ApplicationOperationInitiatedBy
type ApplicationOperationInitiatedBy struct {
	// Automated
	Automated *bool `json:"automated"`
	// Username
	Username *string `json:"username"`
}

// Application form Sync Policy retry options
type ApplicationOperationRetryBackoffOptions struct {
	// Duration
	Duration string `json:"duration"`
	// Max duration
	MaxDuration string `json:"maxDuration"`
	// Factor
	Factor int `json:"factor"`
}

// ApplicationOperationRetryOptions
type ApplicationOperationRetryOptions struct {
	// Limit
	Limit *int `json:"limit"`
	// Backoff
	Backoff *ApplicationOperationRetryBackoffOptions `json:"backoff"`
}

// Application Operation State
type ApplicationOperationState struct {
	// Finished At
	FinishedAt *string `json:"finishedAt"`
	// Started At
	StartedAt string `json:"startedAt"`
	// Message
	Message string `json:"message"`
	// Phase
	Phase SyncOperationPhase `json:"phase"`
	// Retry Count
	RetryCount *int `json:"retryCount"`
	// Operation
	Operation *ApplicationOperation `json:"operation"`
	// Sync Result
	SyncResult *ApplicationSyncResult `json:"syncResult"`
}

// ApplicationOperationRetryOptions
type ApplicationOperationSync struct {
	// Prune
	Prune *bool `json:"prune"`
	// Revision
	Revision *string `json:"revision"`
	// Sync Options
	SyncOptions []string `json:"syncOptions"`
	// Resources
	Resources []*ApplicationOperationSyncResource `json:"resources"`
	// Sync Strategy
	SyncStrategy *ApplicationOperationSyncStrategy `json:"syncStrategy"`
}

// ApplicationOperationSyncResource
type ApplicationOperationSyncResource struct {
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Group
	Group *string `json:"group"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// ApplicationOperationSyncStrategy
type ApplicationOperationSyncStrategy struct {
	// Hook
	Hook *string `json:"hook"`
}

// ApplicationOrderedStatistics
type ApplicationOrderedStatistics struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Applications stats
	ApplicationsStats []*ApplicationOrderedStatisticsData `json:"applicationsStats"`
}

// Ordered Application Stats single application statistics
type ApplicationOrderedStatisticsData struct {
	// Application
	Application string `json:"application"`
	// Namespace
	Namespace string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Cluster
	Cluster string `json:"cluster"`
	// Application deployment statistics by status
	DeploymentStatusBreakdown []*DeploymentStatisticsInfo `json:"deploymentStatusBreakdown"`
	// Total deployments
	TotalDeployments *MetricWithTrend `json:"totalDeployments"`
}

// ApplicationReadModelEventPayload type
type ApplicationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ApplicationReadModelEventPayload) IsReadModelEventPayload() {}

// Application ref
type ApplicationRef struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Is reference was cut during tree normalizing
	IsReferenceCut *bool `json:"isReferenceCut"`
}

// ApplicationSet entity
type ApplicationSet struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Revision
	Revision *string `json:"revision"`
	// Number of resources
	Size *int `json:"size"`
	// Favorites
	Favorites []string `json:"favorites"`
}

func (ApplicationSet) IsBaseEntity()          {}
func (ApplicationSet) IsProjectBasedEntity()  {}
func (ApplicationSet) IsFavorable()           {}
func (ApplicationSet) IsApplicationTreeItem() {}
func (ApplicationSet) IsEntity()              {}

// Application Set Edge
type ApplicationSetEdge struct {
	// Node contains the actual application set data
	Node *ApplicationSet `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationSetEdge) IsEdge() {}

// ApplicationSet Slice
type ApplicationSetSlice struct {
	// Application edges
	Edges []*ApplicationSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSetSlice) IsSlice() {}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Application Sync Compared To
type ApplicationSyncComparedTo struct {
	// Destination
	Destination *ApplicationFormDestination `json:"destination"`
	// Source
	Source *ApplicationFormSource `json:"source"`
}

// ApplicationSyncResult
type ApplicationSyncResult struct {
	// Revision
	Revision string `json:"revision"`
	// Resources
	Resources []*SyncResultResource `json:"resources"`
	// Source
	Source *ApplicationFormSource `json:"source"`
}

// Application Sync Status
type ApplicationSyncStatus struct {
	// Status
	Status SyncStatus `json:"status"`
	// ComparedTo
	ComparedTo *ApplicationSyncComparedTo `json:"comparedTo"`
}

// Application tree filter arguments
type ApplicationTreeFilterArgs struct {
	// Filter applications from a specific project
	Project *string `json:"project"`
	// Filter applications from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter applications from runtime list
	Runtimes []string `json:"runtimes"`
	// Filter applications by list of names
	Applications []string `json:"applications"`
	// Filter applications by name fragment
	ApplicationName *string `json:"applicationName"`
	// Filter applications by name
	ApplicationFullName *string `json:"applicationFullName"`
	// Filter applications by status
	Statuses []SyncStatus `json:"statuses"`
	// Filter applications by health status
	HealthStatuses []HealthStatus `json:"healthStatuses"`
	// Filter applications by namespace list
	Namespaces []string `json:"namespaces"`
	// Filter applications by namespace
	Namespace *string `json:"namespace"`
	// Filter applications by kind
	Kinds []string `json:"kinds"`
	// Filter applications by cluster urls list
	ClusterUrls []string `json:"clusterUrls"`
	// Filter applications by cluster url
	ClusterURL *string `json:"clusterUrl"`
	// Filter applications by favorite using userId
	UserID *string `json:"userId"`
	// Filter applications by favorite
	Favorite *bool `json:"favorite"`
	// Filter applications by labels
	Labels []string `json:"labels"`
	// Filter applications by groups
	Groups []string `json:"groups"`
	// Filter applications by version
	Versions []string `json:"versions"`
}

// Application Tree Health Status Statistic
type ApplicationTreeHealthStatusStatisticRecord struct {
	// Health Status
	Type HealthStatus `json:"type"`
	// Count
	Count int `json:"count"`
}

// Application tree sorting arguments
type ApplicationTreeSortArg struct {
	// Field for sorting
	Field ApplicationTreeSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Application filter arguments
type ApplicationsFilterArgs struct {
	// Filter applications from a specific project
	Project *string `json:"project"`
	// Filter applications from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter applications from runtime list
	Runtimes []string `json:"runtimes"`
	// Filter applications by list of names
	Applications []string `json:"applications"`
	// Filter applications by name fragment
	ApplicationName *string `json:"applicationName"`
	// Filter applications by status
	Statuses []SyncStatus `json:"statuses"`
	// Filter applications by health status
	HealthStatuses []HealthStatus `json:"healthStatuses"`
	// Filter applications by namespace list
	Namespaces []string `json:"namespaces"`
	// Filter applications by namespace
	Namespace *string `json:"namespace"`
	// Filter applications by kind
	Kinds []string `json:"kinds"`
	// Filter applications by cluster urls list
	ClusterUrls []string `json:"clusterUrls"`
	// Filter applications by cluster url
	ClusterURL *string `json:"clusterUrl"`
	// Filter applications by favorite using userId
	UserID *string `json:"userId"`
	// Filter applications by favorite
	Favorite *bool `json:"favorite"`
	// Filter applications by labels
	Labels []string `json:"labels"`
	// Filter applications by groups
	Groups []string `json:"groups"`
	// Filter applications by versions
	Versions []string `json:"versions"`
}

// Application relations
type AppsRelations struct {
	// Entities referencing this entity
	ReferencedBy []*ApplicationRef `json:"referencedBy"`
	// Entities referenced by this enitity
	References []*ApplicationRef `json:"references"`
}

// Argo CD Application destination config
type ArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name"`
	// Cluster url
	Server *string `json:"server"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Revision
	Revision string `json:"revision"`
	// Version
	Version string `json:"version"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor"`
	// CommitAvatar
	CommitAvatar *string `json:"commitAvatar"`
	// CommitUrl
	CommitURL *string `json:"commitUrl"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage"`
	// CommitDate
	CommitDate *string `json:"commitDate"`
}

// Argo Hub Template
type ArgoHubTemplate struct {
	// Version
	ID *string `json:"id"`
	// Manifest
	Manifest *string `json:"manifest"`
	// Manifest url
	ManifestURL *string `json:"manifestUrl"`
	// Description
	Description *string `json:"description"`
	// Categories
	Categories []*string `json:"categories"`
}

// Argo Hub Templates
type ArgoHubTemplates struct {
	// Starter template name
	Data []*ArgoHubTemplatesSlice `json:"data"`
}

// Argo Hub templates filter arguments
type ArgoHubTemplatesFilterArgs struct {
	// Filter Argo Hub Templates by category
	Category *string `json:"category"`
	// Filter Argo Hub Templates by name
	Name *string `json:"name"`
}

// Argo Hub Templates Slice
type ArgoHubTemplatesSlice struct {
	// Template name
	Name *string `json:"name"`
	// Versions
	Versions []*ArgoHubTemplate `json:"versions"`
	// Latest version
	LatestVersion *ArgoHubTemplate `json:"latestVersion"`
}

// Audit Edge
type AuditEdge struct {
	// Node contains the actual audit record
	Node *AuditEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Audit Entity Record
type AuditEntity struct {
	// Timestamp
	Timestamp *string `json:"timestamp"`
	// AccountId
	AccountID *string `json:"accountId"`
	// AccountName
	AccountName *string `json:"accountName"`
	// UserId
	UserID *string `json:"userId"`
	// UserName
	UserName *string `json:"userName"`
	// Action
	Action string `json:"action"`
	// AuthEntityType
	AuthEntityType string `json:"authEntityType"`
	// EventType
	EventType string `json:"eventType"`
	// EntityType
	EntityType string `json:"entityType"`
	// EntityId
	EntityID *string `json:"entityId"`
	// EntityName
	EntityName string `json:"entityName"`
	// Runtime
	Runtime *string `json:"runtime"`
	// IP
	IP *string `json:"ip"`
	// Method
	Method *string `json:"method"`
	// Url
	URL *string `json:"url"`
	// Params
	Params *string `json:"params"`
	// Query
	Query *string `json:"query"`
	// Headers
	Headers *string `json:"headers"`
	// Payload
	Payload *string `json:"payload"`
	// Status
	Status *int `json:"status"`
	// Response
	Response *string `json:"response"`
}

// Args to filter audit
type AuditFilterArgs struct {
	// Status
	Status *int `json:"status"`
}

// Audit Slice
type AuditSlice struct {
	// Audit edges
	Edges []*AuditEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Auth0SSO
type Auth0sso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Client host
	ClientHost *string `json:"clientHost"`
}

func (Auth0sso) IsIDP() {}

// Authorization input
type AuthArgs struct {
	// x-access-token
	AccessToken *string `json:"accessToken"`
	// api key
	APIKey *string `json:"apiKey"`
}

// Stats for avg change failure rate
type AvgChangeFailureRateStatistics struct {
	// Avg change failure rate data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Avg change failure rate info
	Info *DoraStatisticsSummery `json:"info"`
}

// Stats for Avg time to restore service
type AvgTimeToRestoreServiceStatistics struct {
	// Avg time to restore service data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Avg time to restore service info
	Info *DoraStatisticsSummery `json:"info"`
}

// AzureSSO
type AzureSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// Tenant
	Tenant *string `json:"tenant"`
	// Object Id in Azure
	AppID *string `json:"appId"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Cookie key
	CookieKey *string `json:"cookieKey"`
	// Cookie iv
	CookieIv *string `json:"cookieIv"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
}

func (AzureSso) IsIDP() {}

// BasePrice
type BasePrice struct {
	// Month
	Month *int `json:"month"`
	// Year
	Year *int `json:"year"`
}

// references info
type BaseReference struct {
	// Object metadata
	Metadata *EntityReferenceMeta `json:"metadata"`
}

// BitbucketCloud trigger conditions
type BitbucketCloudTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
	// Repo filter argumets
	Repo *RepoBitbucketCloudFilterArgs `json:"repo"`
}

// BitbucketCloud trigger conditions
type BitbucketCloudTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// repo filter argumets
	Repo *RepoBitbucketCloudFilterArgsInput `json:"repo"`
}

// BitbucketServer trigger conditions
type BitbucketServerTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Bitbucket Server url
	BaseURL string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// BitbucketServer trigger conditions
type BitbucketServerTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Base url
	BaseURL string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
}

// Build Entity
type Build struct {
	// Build Id
	ID string `json:"id"`
	// PipelineRef
	Pipeline *PipelineRef `json:"pipeline"`
}

// ClusterCacheInfo contains information about the cluster cache
type CacheInfo struct {
	// ResourcesCount holds number of observed Kubernetes resources
	ResourcesCount *int `json:"resourcesCount"`
	// APIsCount holds number of observed Kubernetes API count
	ApisCount *int `json:"apisCount"`
	// LastCacheSyncTime holds time of most recent cache synchronization
	LastCacheSyncTime *string `json:"lastCacheSyncTime"`
}

// Cluster cache info input
type CacheInfoInput struct {
	// Number of observed Kubernetes resources
	ResourcesCount *int `json:"resourcesCount"`
	// Number of observed Kubernetes API count
	ApisCount *int `json:"apisCount"`
	// Last cache sync time
	LastCacheSyncTime *string `json:"lastCacheSyncTime"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// TBD
	Schedule *string `json:"schedule"`
	// TBD
	Interval *string `json:"interval"`
	// TBD
	Timezone *string `json:"timezone"`
	// TBD
	Metadata *string `json:"metadata"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// Calendar trigger conditions
type CalendarTriggerConditions struct {
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Number of seconds, minutes, hours, etc..
	Interval *string `json:"interval"`
	// Cron expression
	Schedule *string `json:"schedule"`
	// TimeZone
	Timezone *string `json:"timezone"`
	// Metadata
	Metadata *string `json:"metadata"`
}

// Calendar trigger conditions
type CalendarTriggerConditionsArgs struct {
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Number of seconds, minutes, hours, etc..
	Interval *string `json:"interval"`
	// Cron expression
	Schedule *string `json:"schedule"`
	// TimeZone
	Timezone *string `json:"timezone"`
	// Metadata
	Metadata *string `json:"metadata"`
}

// ChildApplicationField Entity
type ChildApplicationField struct {
	// Name
	Name string `json:"name"`
	// Repo
	Repo *string `json:"repo"`
	// Cluster
	Cluster *string `json:"cluster"`
	// Status
	Status *SyncStatus `json:"status"`
}

// Child workflow reference
type ChildWorkflowRef struct {
	// Child workflow
	Workflow *Workflow `json:"workflow"`
	// Child workflow type
	Type *string `json:"type"`
	// Node ref
	NodeRef *string `json:"nodeRef"`
}

// ClientIP
type ClientIP struct {
	// TimeoutSeconds
	TimeoutSeconds *int `json:"timeoutSeconds"`
}

// Cluster entity
type Cluster struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Server is the API server URL of the Kubernetes cluster
	Server string `json:"server"`
	// Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
	Namespaces []string `json:"namespaces"`
	// RefreshRequestedAt holds time when cluster cache refresh has been requested
	RefreshRequestedAt *string `json:"refreshRequestedAt"`
	// Shard contains optional shard number. Calculated on the fly by the application controller if not specified.
	Shard *int `json:"shard"`
	// Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
	ClusterResources bool `json:"clusterResources"`
	// Info holds information about cluster cache and state
	Info *ClusterInfo `json:"info"`
}

func (Cluster) IsBaseEntity() {}
func (Cluster) IsEntity()     {}

// Cluster Edge
type ClusterEdge struct {
	// Node contains the actual cluster data
	Node *Cluster `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ClusterEdge) IsEdge() {}

// ClusterInfo contains information about the cluster
type ClusterInfo struct {
	// ConnectionState contains information about the connection to the cluster
	ConnectionState *ConnectionState `json:"connectionState"`
	// ServerVersion contains information about the Kubernetes version of the cluster
	ServerVersion *string `json:"serverVersion"`
	// CacheInfo contains information about the cluster cache
	CacheInfo *CacheInfo `json:"cacheInfo"`
	// ApplicationsCount is the number of applications managed by Argo CD on the cluster
	ApplicationsCount int `json:"applicationsCount"`
	// APIVersions contains list of API versions supported by the cluster
	APIVersions []*string `json:"apiVersions"`
}

// Cluster info input
type ClusterInfoInput struct {
	// Connection state
	ConnectionState *ConnectionStateInput `json:"connectionState"`
	// The Kubernetes version of the cluster
	ServerVersion *string `json:"serverVersion"`
	// Cache info
	CacheInfo *CacheInfoInput `json:"cacheInfo"`
	// Number of applications managed by Argo CD on the cluster
	ApplicationsCount int `json:"applicationsCount"`
	// APIVersions contains list of API versions supported by the cluster
	APIVersions []*string `json:"apiVersions"`
}

// Cluster Slice
type ClusterSlice struct {
	// Cluster edges
	Edges []*ClusterEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ClusterSlice) IsSlice() {}

// Cluster upsert args
type ClusterUpsertArgs struct {
	// Cluster name
	Name string `json:"name"`
	// The runtime of which the cluster belongs
	Runtime string `json:"runtime"`
	// Cluster server URL
	Server string `json:"server"`
	// Cluster info
	Info *ClusterInfoInput `json:"info"`
}

// Clusters statistics
type ClustersStatistics struct {
	// Total clusters number
	Total int `json:"total"`
	// Number of connected runtimes
	Connected int `json:"connected"`
	// Number of failed connection clusters
	Failed int `json:"failed"`
	// Number of unknown connection clusters
	Unknown int `json:"unknown"`
}

// Commits
type Commits struct {
	// url
	URL *string `json:"url"`
	// userName
	UserName *string `json:"userName"`
	// sha
	Sha *string `json:"sha"`
	// message
	Message *string `json:"message"`
	// commitDate
	CommitDate *string `json:"commitDate"`
}

// Commits output
type CommitsOutput struct {
	// Commit url
	URL string `json:"url"`
	// Commit author
	UserName string `json:"userName"`
	// Commit sha
	Sha string `json:"sha"`
	// Commit message
	Message string `json:"message"`
}

// Committer Label
type CommitterLabel struct {
	// UserName
	UserName string `json:"userName"`
	// Avatar
	Avatar *string `json:"avatar"`
	// Comitter commits list
	Commits []*CommitsOutput `json:"commits"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the component
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity()         {}
func (Component) IsK8sLogicEntity()     {}
func (Component) IsProjectBasedEntity() {}
func (Component) IsEntity()             {}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// Component Notification
type ComponentNotification struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (ComponentNotification) IsNotification()       {}
func (ComponentNotification) IsArgoCDNotification() {}
func (ComponentNotification) IsGitOpsNotification() {}

// ComponentReadModelEventPayload type
type ComponentReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ComponentReadModelEventPayload) IsReadModelEventPayload() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Composite Slice
type CompositeSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo []*CompositeSliceInfo `json:"pageInfo"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Infomration about a slice of a specific kind
type CompositeSliceInfo struct {
	// Key of the slice
	Key string `json:"key"`
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
}

// Pagination arguments to request kind-slice
type CompositeSlicePaginationArgs struct {
	// References a specific key
	Key string `json:"key"`
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// ConfigMap Form Data object
type ConfigMapFormData struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata"`
	// Data
	Data *string `json:"data"`
	// Data
	BinaryData *string `json:"binaryData"`
	// Sync status
	SyncStatus *SyncStatus `json:"syncStatus"`
}

// GitAuthConfig form input data object
type ConfigMapFormInputData struct {
	// Metadata
	Metadata *ConfigMapFormInputMetadata `json:"metadata"`
	// Data
	Data *string `json:"data"`
	// Binary Data
	BinaryData *string `json:"binaryData"`
}

// ConfigMap form input metadata object
type ConfigMapFormInputMetadata struct {
	// ConfigMap name
	Name string `json:"name"`
	// ConfigMap namespace
	Namespace *string `json:"namespace"`
}

// ConfigMapMetadata
type ConfigMapMetadata struct {
	// Name
	Name *string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Runtime
	Runtime *string `json:"runtime"`
	// Labels
	Labels []*StringPair `json:"labels"`
}

// ConnectionState contains information about remote resource connection state, currently used for clusters and repositories
type ConnectionState struct {
	// Status contains the current status indicator for the connection
	Status ClusterConnectionStatus `json:"status"`
	// Message contains human readable information about the connection status
	Message *string `json:"message"`
	// AttemptedAt contains the timestamp when this connection status has been determined
	AttemptedAt *string `json:"attemptedAt"`
}

// Cluster connection state input
type ConnectionStateInput struct {
	// Current status indicator for the connection
	Status ClusterConnectionStatusInput `json:"status"`
	// Human readable information about the connection status
	Message *string `json:"message"`
	// Last attempt for connection
	AttemptedAt *string `json:"attemptedAt"`
}

// Input for git-source placeholder
type CreateGitSourcePlaceholderInput struct {
	// App name
	AppName string `json:"appName"`
	// The path to the source watched by the git-source
	AppSpecifier string `json:"appSpecifier"`
	// The server on which the resources will be applied
	DestServer string `json:"destServer"`
	// The server on which the resources will be applied
	DestNamespace string `json:"destNamespace"`
	// The labels of the git-source
	Labels *string `json:"labels"`
	// Files to be included
	Include *string `json:"include"`
	// Files to be excluded
	Exclude *string `json:"exclude"`
	// Is this a codefresh internal git-source
	IsInternal *bool `json:"isInternal"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilter struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilterArgs struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// DataRetention
type DataRetention struct {
	// Weeks
	Weeks *int `json:"weeks"`
}

// DefaultDindResources
type DefaultDindResources struct {
	// Requests
	Requests *ResourcesRequests `json:"requests"`
}

// Deployment entity
type Deployment struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Deployment Entity
	Spec *DeploymentSpec `json:"spec"`
	// Deployment Status
	Status *DeploymentStatus `json:"status"`
}

func (Deployment) IsGitopsEntity()       {}
func (Deployment) IsBaseEntity()         {}
func (Deployment) IsProjectBasedEntity() {}
func (Deployment) IsEntity()             {}

// Container
type DeploymentContainer struct {
	// Containers
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// ImagePullPolicy
	ImagePullPolicy *ImagePullPolicy `json:"imagePullPolicy"`
}

// Deployment Edge
type DeploymentEdge struct {
	// Node contains the actual Deployment data
	Node *Deployment `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (DeploymentEdge) IsEdge() {}

// Stats for deployment frequency
type DeploymentFrequencyStatistics struct {
	// Deployment frequency statistics data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Deployments frequency info
	Info *DoraStatisticsSummery `json:"info"`
}

// DeploymentReadModelEventPayload type
type DeploymentReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (DeploymentReadModelEventPayload) IsReadModelEventPayload() {}

// Deployment Slice
type DeploymentSlice struct {
	// Deployment edges
	Edges []*DeploymentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (DeploymentSlice) IsSlice() {}

// Deployment Spec
type DeploymentSpec struct {
	// Template
	Template *PodTemplateSpec `json:"template"`
	// Replicas
	Replicas *int `json:"replicas"`
}

// DeploymentSpecPart
type DeploymentSpecPart struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Status
	Status *DeploymentStatus `json:"status"`
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// Deployment statistics
type DeploymentStatistics struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Deployment statistics data
	Data []*DeploymentStatisticsData `json:"data"`
	// Deplyment statistics total
	Info []*DeploymentStatisticsInfo `json:"info"`
}

// Stats data for deployments - holds daily stats
type DeploymentStatisticsData struct {
	// Time
	Time string `json:"time"`
	// Deployment status
	Status DeploymentStatisticsStatus `json:"status"`
	// Number Of Syncs
	Value int `json:"value"`
}

// Stats info for deployments holds total data for each of the statuses
type DeploymentStatisticsInfo struct {
	// Deployment status
	Status DeploymentStatisticsStatus `json:"status"`
	// Total number of deployments in the given time period
	TotalDeployments *MetricWithTrend `json:"totalDeployments"`
	// Last deployment
	LastDeployment *MetricWithTrend `json:"lastDeployment"`
}

// Deployment Status
type DeploymentStatus struct {
	// Replicas
	Replicas *int `json:"replicas"`
	// AvailableReplicas
	AvailableReplicas *int `json:"availableReplicas"`
	// ReadyReplicas
	ReadyReplicas *int `json:"readyReplicas"`
	// UnavailableReplicas
	UnavailableReplicas *int `json:"unavailableReplicas"`
	// UpdatedReplicas
	UpdatedReplicas *int `json:"updatedReplicas"`
}

// General stats data
type DoraGeneralStatistics struct {
	// Total
	Total float64 `json:"total"`
}

// General dora metrics stats data
type DoraMetricsGeneralStatistics struct {
	// Deployments
	Deployments *DoraGeneralStatistics `json:"deployments"`
	// Rollback
	Rollbacks *DoraGeneralStatistics `json:"rollbacks"`
	// Failure rate
	FailureRate *DoraGeneralStatistics `json:"failureRate"`
	// Commit / pull request
	CommitOrPullRequests *DoraGeneralStatistics `json:"commitOrPullRequests"`
}

// Stats data for deployment frequency
type DoraStatisticsData struct {
	// Time
	Time string `json:"time"`
	// Number of deployment
	Value float64 `json:"value"`
}

// Stats summery for all dora graphs
type DoraStatisticsSummery struct {
	// Avg
	Summery float64 `json:"summery"`
}

// Dora statistics filter arguments
type DoraStatsFilterArgs struct {
	// Date range
	DateRange *StatisticsDateRangeFilterWithTz `json:"dateRange"`
	// Runtime
	RuntimeName []string `json:"runtimeName"`
	// Cluster
	ClusterName []string `json:"clusterName"`
	// Application
	Application []string `json:"application"`
	// Labels
	Labels []*LabelStringPair `json:"labels"`
	// Favorite applications
	Favorite *bool `json:"favorite"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

// Db Entity Reference
type EntityReference struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// Entity Reference Meta
type EntityReferenceMeta struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// EnvironmentConcurrency
type EnvironmentConcurrency struct {
	// Price
	Price *BasePrice `json:"price"`
	// Amount
	Amount *int `json:"amount"`
	// Min
	Min *int `json:"min"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
	// Commit url with file
	FileURL *string `json:"fileUrl"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid"`
	// Content of the event
	Data *string `json:"data"`
	// Time
	Time *string `json:"time"`
	// Event source
	EventSource *EventSource `json:"eventSource"`
	// Event name
	EventName *string `json:"eventName"`
	// Event type
	EventType *string `json:"eventType"`
	// Account
	Account *string `json:"account"`
	// Runtime
	Runtime *string `json:"runtime"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

// EventPayloadReadModelEventPayload type
type EventPayloadReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (EventPayloadReadModelEventPayload) IsReadModelEventPayload() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the event-source
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (EventSource) IsBaseEntity()         {}
func (EventSource) IsGitopsEntity()       {}
func (EventSource) IsProjectBasedEntity() {}
func (EventSource) IsEntity()             {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// EventSourceReadModelEventPayload type
type EventSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (EventSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Event source type
type EventSourceType struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// List of the supported events by this event source type. CAP know how to filter this kind of events.
	Events []*SupportedEventMapping `json:"events"`
}

// Args to set favorite for entity
type FavoriteInfoArgs struct {
	// Event-source kind
	Kind string `json:"kind"`
	// Event-source group
	Group string `json:"group"`
	// Event-source group
	Version string `json:"version"`
	// Event-source runtime name
	Runtime string `json:"runtime"`
	// Event-source name
	Name string `json:"name"`
	// Event-source namespace
	Namespace *string `json:"namespace"`
	// Event-source cluster URL
	Cluster *string `json:"cluster"`
}

// From State Entity
type FromState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Returns runtimes and clusters statistics
type GeneralStatistics struct {
	// Runtimes statistics
	Runtimes *RuntimesStatistics `json:"runtimes"`
	// Clusters statistics
	Clusters *ClustersStatistics `json:"clusters"`
}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (GenericEntity) IsGitopsEntity()       {}
func (GenericEntity) IsBaseEntity()         {}
func (GenericEntity) IsProjectBasedEntity() {}
func (GenericEntity) IsEntity()             {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// Argo events generic Error Notification
type GenericErrorNotification struct {
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Notification type
	Type *string `json:"type"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
}

func (GenericErrorNotification) IsNotification()           {}
func (GenericErrorNotification) IsArgoEventsNotification() {}

// GitAuthConfig
type GitAuthConfig struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata"`
	// Data
	Data *GitAuthProvidersData `json:"data"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Entity source
	Source *GitConfigEntitySource `json:"source"`
}

// GitAuthConfig form data object
type GitAuthConfigFormData struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata"`
	// Data
	Data *GitAuthProvidersData `json:"data"`
	// Sync status
	SyncStatus *SyncStatus `json:"syncStatus"`
}

// GitAuthConfig form input data object
type GitAuthConfigFormInputData struct {
	// Metadata
	Metadata *GitAuthConfigFormInputMetadata `json:"metadata"`
	// Data
	Data *GitAuthProviderDataInput `json:"data"`
}

// GitAuthConfig form metadata
type GitAuthConfigFormInputMetadata struct {
	// GitAuthConfig name
	Name *string `json:"name"`
	// GitAuthConfig namespace
	Namespace *string `json:"namespace"`
	// GitAuthConfig runtime
	Runtime *string `json:"runtime"`
}

// GitAuthProviderConfigData
type GitAuthProviderConfig struct {
	// Provider
	Provider string `json:"provider"`
	// Mode
	Mode GitAuthMode `json:"mode"`
	// AppName
	AppName *string `json:"appName"`
	// Secret
	Secret *SecretData `json:"secret"`
}

// GitAuthProviderConfig input data object
type GitAuthProviderConfigInput struct {
	// Provider
	Provider string `json:"provider"`
	// Mode
	Mode GitAuthMode `json:"mode"`
	// AppName
	AppName *string `json:"appName"`
	// Secret
	Secret *SecretDataInput `json:"secret"`
}

// GitAuthProviderData input data object
type GitAuthProviderDataInput struct {
	// Config
	Config *GitAuthProviderConfigInput `json:"config"`
}

// GitAuthProvidersData
type GitAuthProvidersData struct {
	// Config
	Config *GitAuthProviderConfig `json:"config"`
}

// GitConfigEntitySource
type GitConfigEntitySource struct {
	// GitSource
	GitSource *string `json:"gitSource"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Path
	Path *string `json:"path"`
	// Revision
	Revision *string `json:"revision"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage"`
	// CommitDate
	CommitDate *string `json:"commitDate"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor"`
	// SyncStartedAt
	SyncStartedAt *string `json:"syncStartedAt"`
	// SyncFinishedAt
	SyncFinishedAt *string `json:"syncFinishedAt"`
	// ResourceAction
	ResourceAction *ResourceAction `json:"resourceAction"`
}

// GitOps Edge
type GitOpsEdge struct {
	// Node contains the actual component data
	Node GitopsEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// GitOps Slice
type GitOpsSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork"`
	// PR comment
	Comment *GitPRComment `json:"comment"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp"`
	// PR data
	Pr *GitPr `json:"pr"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPREventPayloadData) IsEventPayloadData()          {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *WorkflowRepository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha"`
	// SHA URL
	ShaURL *string `json:"shaURL"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPushEventPayloadData) IsEventPayloadData()          {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp"`
	// Release data
	Release *GitRelease `json:"release"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitReleaseEventPayloadData) IsEventPayloadData()          {}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the GitSource
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Permissions to this git source
	Permissions []*Permission `json:"permissions"`
}

func (GitSource) IsK8sLogicEntity()     {}
func (GitSource) IsBaseEntity()         {}
func (GitSource) IsProjectBasedEntity() {}
func (GitSource) IsEntity()             {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git Source Notification
type GitSourceNotification struct {
	// Commit information that triggered sync
	Source *GitopsEntitySource `json:"source"`
	// Link to the git-source in git provider
	GsRepoLink *string `json:"gsRepoLink"`
	// Sync status
	GsSyncStatus SyncStatus `json:"gsSyncStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (GitSourceNotification) IsNotification()       {}
func (GitSourceNotification) IsArgoCDNotification() {}
func (GitSourceNotification) IsGitOpsNotification() {}

// GitSourceReadModelEventPayload type
type GitSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (GitSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event timestamp
	Timestamp *string `json:"timestamp"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitUnknownEventPayloadData) IsEventPayloadData()          {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Github trigger conditions
type GithubTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Base url for github enterprise
	BaseURL *string `json:"baseUrl"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters chosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Github trigger conditions
type GithubTriggerConditionsArgs struct {
	// Specific github event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Base url for github enterprise
	BaseURL *string `json:"baseUrl"`
	// Repositories
	Repositories []*string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
}

// Gitlab trigger conditions
type GitlabTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Gitlab enterprise url
	BaseURL *string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Gitlab trigger conditions
type GitlabTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Base url
	BaseURL *string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource"`
	// Repo URL
	RepoURL *string `json:"repoURL"`
	// Path
	Path *string `json:"path"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL"`
	// Git revision
	Revision *string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit web url
	CommitURL *string `json:"commitURL"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Author web profile url
	ProfileURL *string `json:"profileURL"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL"`
	// Git manifest
	GitManifest *string `json:"gitManifest"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction"`
}

// Gitops Release Entity
type GitopsRelease struct {
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
	// History id
	HistoryID int `json:"historyId"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
	// Current release flag
	Current *bool `json:"current"`
}

// Args to define application
type GitopsReleaseApplicationArgs struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace string `json:"namespace"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
	// Kind
	Kind *string `json:"kind"`
}

// Gitops Release chart record
type GitopsReleaseChartRecord struct {
	// Date
	Date string `json:"date"`
	// Date
	Releases []*GitopsReleaseChartRelease `json:"releases"`
}

// Gitops Release chart release
type GitopsReleaseChartRelease struct {
	// Date
	SyncStartedAt *string `json:"syncStartedAt"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// History id
	HistoryID int `json:"historyId"`
}

// Release Edge
type GitopsReleaseEdge struct {
	// Node contains the actual application data
	Node *GitopsRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter release
type GitopsReleaseFilterArgs struct {
	// Runtime
	Runtime *string `json:"runtime"`
	// Name
	Name *string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
	// Kind
	Kind *string `json:"kind"`
	// HistoryId
	HistoryID *int `json:"historyId"`
	// Issue key
	IssueKey *string `json:"issueKey"`
	// PR key
	PrKey *string `json:"prKey"`
	// Committer
	Committer *string `json:"committer"`
	// Issue key array
	IssueKeys []string `json:"issueKeys"`
	// PR key array
	PrKeys []string `json:"prKeys"`
	// Committers array
	Committers []string `json:"committers"`
	// Filter workflows from a specific start date
	SyncStartDateFrom *string `json:"syncStartDateFrom"`
	// Filter workflows to a specific start date
	SyncStartDateTo *string `json:"syncStartDateTo"`
	// Start date
	StartDate *string `json:"startDate"`
	// End date
	EndDate *string `json:"endDate"`
}

// Gitops Release Slice
type GitopsReleaseSlice struct {
	// Release edges
	Edges []*GitopsReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Gitops releases sorting arguments
type GitopsReleaseSortArg struct {
	// Field for sorting
	Field GitopsReleasesSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// GoogleSSO
type GoogleSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// ClientHost
	ClientHost *string `json:"clientHost"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Keyfile
	Keyfile *string `json:"keyfile"`
	// Subject
	Subject *string `json:"subject"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
	// SyncField
	SyncField *string `json:"syncField"`
}

func (GoogleSso) IsIDP() {}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// Health Error Input
type HealthErrorInput struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Message
	Message string `json:"message"`
}

// Workflow template ref Hierarchy
type HierarchyRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Ref line number
	Line *int `json:"line"`
}

// WorkflowTemplate Hierarchy Step
type HierarchyStep struct {
	// Step name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line"`
}

// WorkflowTemplate Steps Template
type HierarchyTemplate struct {
	// Template name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line"`
	// Steps
	Steps []*HierarchyStep `json:"steps"`
}

// WorkflowTemplate templates hierarchy
type HierarchyTemplates struct {
	// WorkflowTemlate name
	Name *string `json:"name"`
	// WorkflowTemlate name line number
	Line *int `json:"line"`
	// WorkflowTemplate templates structer heiarchy
	Steps []*HierarchyTemplate `json:"steps"`
	// WorkflowTemplate templates structer heiarchy
	Refs []*HierarchyRef `json:"refs"`
}

// History arguments
type HistoryArgs struct {
	// History Pagination arguments
	Pagination []*CompositeSlicePaginationArgs `json:"pagination"`
	// Page Size
	PageSize *int `json:"pageSize"`
	// Sync Success - SUCCESS/FAILURE
	SyncSuccess *SyncSuccess `json:"syncSuccess"`
	// Repo
	Repo *string `json:"repo"`
}

// Image application
type ImageApplication struct {
	// Application Ref metadata
	ApplicationRef *ObjectMeta `json:"applicationRef"`
	// Application git info
	ApplicationGitInfo *ImageApplicationGitInfo `json:"applicationGitInfo"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Related binary
	Binary *ImageBinary `json:"binary"`
	// Currently deployed
	CurrentlyDeployed bool `json:"currentlyDeployed"`
}

// Application Commit Author
type ImageApplicationCommitAuthor struct {
	// Username
	Username *string `json:"username"`
	// Profile Url
	ProfileURL *string `json:"profileUrl"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl"`
}

// Image Application Git Info
type ImageApplicationGitInfo struct {
	// Git repo url
	RepoURL *string `json:"repoURL"`
	// Git branch
	Branch *string `json:"branch"`
	// Commit author
	Author *ImageApplicationCommitAuthor `json:"author"`
	// Commit message
	CommitMessage *string `json:"commitMessage"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
}

// Image binary entity
type ImageBinary struct {
	//  Runtime
	Runtime *RuntimeInfo `json:"runtime"`
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// ImageName
	ImageName string `json:"imageName"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Branch
	Branch *string `json:"branch"`
	// Commit
	Commit *string `json:"commit"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg"`
	// CommitURL
	CommitURL *string `json:"commitURL"`
	// Git repository
	GitRepository *string `json:"gitRepository"`
	//  AccountId
	AccountID string `json:"accountId"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	// Size
	Size *int `json:"size"`
	// OS
	Os *string `json:"os"`
	// Architecture
	Architecture *string `json:"architecture"`
	// Info
	Info *string `json:"info"`
	// Author
	Author *ImageBinaryAuthor `json:"author"`
	// Workflow name
	WorkflowName *string `json:"workflowName"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl"`
	// CI provider
	CiProvider *string `json:"ciProvider"`
	// Logs url
	LogsURL *string `json:"logsUrl"`
	// Image registry
	ImageRegistryDomains []ImageRegistryType `json:"imageRegistryDomains"`
}

func (ImageBinary) IsEntity() {}

// ImageBinaryAuthor
type ImageBinaryAuthor struct {
	// Username
	Username *string `json:"username"`
	// Full name
	FullName *string `json:"fullName"`
	// Profile Url
	ProfileURL *string `json:"profileUrl"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl"`
}

// ImageBinaryAuthorInput
type ImageBinaryAuthorInput struct {
	// Username
	Username *string `json:"username"`
}

// ImageBinaryAuthorOutput
type ImageBinaryAuthorOutput struct {
	// Username
	Username *string `json:"username"`
}

// Image Binary Edge
type ImageBinaryEdge struct {
	// Node contains the actual image binary data
	Node *ImageBinary `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageBinaryEdge) IsEdge() {}

// ImageBinaryInput
type ImageBinaryInput struct {
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
	//  Info
	Author *ImageBinaryAuthorInput `json:"author"`
	//  Workflow name
	WorkflowName *string `json:"workflowName"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl"`
	// Logs url
	LogsURL *string `json:"logsUrl"`
}

// ImageBinaryInput
type ImageBinaryOutput struct {
	//  Id
	ID string `json:"id"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
	//  Info
	Author *ImageBinaryAuthorOutput `json:"author"`
	//  Workflow name
	WorkflowName *string `json:"workflowName"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl"`
	// CI provider
	CiProvider *string `json:"ciProvider"`
	// Logs url
	LogsURL *string `json:"logsUrl"`
}

// ImageBinaryPatch
type ImageBinaryPatchInput struct {
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
	//  Info
	Author *ImageBinaryAuthorInput `json:"author"`
	//  Workflow name
	WorkflowName *string `json:"workflowName"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl"`
	// Logs url
	LogsURL *string `json:"logsUrl"`
}

// Images Binary Slice
type ImageBinarySlice struct {
	// Image edges
	Edges []*ImageBinaryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageBinarySlice) IsSlice() {}

// Image Details
type ImageDetails struct {
	// Image name
	Name *string `json:"name"`
	// Registry type
	Type *ImageRegistryType `json:"type"`
	// Link
	Link *string `json:"link"`
}

// Image Registry entity
type ImageRegistry struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	//  AccountId
	AccountID string `json:"accountId"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Repo digest
	RepoDigest *string `json:"repoDigest"`
	// Tags
	Tags []*ImageTag `json:"tags"`
	// Registry
	Registry *Registry `json:"registry"`
}

func (ImageRegistry) IsEntity() {}

// Image Registry Edge
type ImageRegistryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRegistry `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRegistryEdge) IsEdge() {}

// ImageRegistryInput
type ImageRegistryInput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest *string `json:"repoDigest"`
	// Tags
	Tags []*ImageTagInput `json:"tags"`
	// Registry
	Registry *RegistryInput `json:"registry"`
}

// ImageRegistryInput
type ImageRegistryOutput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest *string `json:"repoDigest"`
	// Tags
	Tags []*ImageTagOutput `json:"tags"`
	// Registry
	Registry *RegistryOutput `json:"registry"`
}

// Images Registry Slice
type ImageRegistrySlice struct {
	// Image registry edges
	Edges []*ImageRegistryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRegistrySlice) IsSlice() {}

// Image Repo Tag entity
type ImageRepoTag struct {
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Created Date
	Created string `json:"created"`
	// Related binaries
	Binaries []*ImageBinary `json:"binaries"`
	// Image applications
	Applications []*ImageApplication `json:"applications"`
}

func (ImageRepoTag) IsEntity() {}

// Image repo tag Edge
type ImageRepoTagEdge struct {
	// Node contains the actual image repo tag data
	Node *ImageRepoTag `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepoTagEdge) IsEdge() {}

// Image repo tags filter arguments
type ImageRepoTagFilterArgs struct {
	// Filter image repo tags by image name
	RepositoryName string `json:"repositoryName"`
	// Filter image repo tags by tag
	Tag *string `json:"tag"`
	// Filter image repo tags by registry type
	RegistryTypes []ImageRegistryType `json:"registryTypes"`
	// Filter image repo tags by git branch
	GitBranch *string `json:"gitBranch"`
	// Filter image repo tags by git repositories
	GitRepositories []string `json:"gitRepositories"`
	// Filter image repositories by deployed application names
	DeployedApplications []string `json:"deployedApplications"`
	// Filter image repo tags by currently deployed apps flag
	CurrentlyDeployed *bool `json:"currentlyDeployed"`
}

// Images repo tag Slice
type ImageRepoTagSlice struct {
	// Image Repository edges
	Edges []*ImageRepoTagEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepoTagSlice) IsSlice() {}

// Image repository sorting arguments
type ImageRepoTagSortArg struct {
	// Field for sorting
	Field ImageRepoTagSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Image Repository entity
type ImageRepository struct {
	// Image repository name
	Name string `json:"name"`
	// Account Id
	AccountID string `json:"accountId"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// Image repository registry domain types
	RegistryDomains []ImageRegistryType `json:"registryDomains"`
	// Image applications
	Applications []*ImageApplication `json:"applications"`
}

func (ImageRepository) IsEntity() {}

// Image Repository Edge
type ImageRepositoryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRepository `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepositoryEdge) IsEdge() {}

// Image repository filter arguments
type ImageRepositoryFilterArgs struct {
	// Filter image repositories by image repository name
	Name *string `json:"name"`
	// Filter image repositories by image repository names array
	Names []string `json:"names"`
	// Filter image repositories by tag
	Tag *string `json:"tag"`
	// Filter image repositories by registry type
	RegistryTypes []ImageRegistryType `json:"registryTypes"`
	// Filter image repositories by git branch
	GitBranch *string `json:"gitBranch"`
	// Filter image repositories by git repositories
	GitRepositories []string `json:"gitRepositories"`
	// Filter image repositories by deployed application names
	DeployedApplications []string `json:"deployedApplications"`
	// Filter image repositories by currently deployed apps flag
	CurrentlyDeployed *bool `json:"currentlyDeployed"`
}

// Images Repository Slice
type ImageRepositorySlice struct {
	// Image Repository edges
	Edges []*ImageRepositoryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepositorySlice) IsSlice() {}

// Image repository sorting arguments
type ImageRepositorySortArg struct {
	// Field for sorting
	Field ImageRepositorySortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// ImageTag
type ImageTag struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagInput struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagOutput struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// Images Entity
type Images struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// RepositoryName
	RepositoryName *string `json:"repositoryName"`
	// BinaryId
	BinaryID *string `json:"binaryId"`
	// WorkflowName
	WorkflowName *string `json:"workflowName"`
	// WorkflowUrl
	WorkflowURL *string `json:"workflowUrl"`
	// CiProvider
	CiProvider *string `json:"ciProvider"`
}

// Ingress
type Ingress struct {
	// Hostname
	Hostname *string `json:"hostname"`
	// Ip
	IP *string `json:"ip"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Input for Argo CD Application destination config
type InputArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name"`
	// Cluster url
	Server *string `json:"server"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// Integration entity
type IntegrationConfig struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// Integration Type
	IntegrationType string `json:"integrationType"`
	// Integration Type
	ProviderInfo *string `json:"providerInfo"`
}

func (IntegrationConfig) IsBaseEntity()         {}
func (IntegrationConfig) IsGitopsEntity()       {}
func (IntegrationConfig) IsProjectBasedEntity() {}

// Application Edge
type IntegrationEdge struct {
	// Node contains the actual application data
	Node *IntegrationEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Integration
type IntegrationEntity struct {
	// Name
	Name *string `json:"name"`
	// Integration type usually consists of `<type>.<subtype>`, for example `issue.jira`.
	//
	// Take a look on libs/db/src/entities/common/integration/types.ts to see the allowed values
	Type *string `json:"type"`
	// Provider info contains all non-secure data related to the integration,
	// for example `host` and `username` for `registry.quay` integration.
	//
	// Depends on the integration `type`
	ProviderInfo *string `json:"providerInfo"`
	// Runtimes
	Runtimes []string `json:"runtimes"`
	// Sync Status
	SyncStatus *SyncStatus `json:"syncStatus"`
	// All runtimes enabled
	IsAllRuntimes *bool `json:"isAllRuntimes"`
}

// Args to filter annotation
type IntegrationFilterArgs struct {
	// Name
	Name *string `json:"name"`
	// Integration type usually consists of `<type>.<subtype>`, for example `issue.jira`.
	//
	// Take a look on libs/db/src/entities/common/integration/types.ts to see the allowed values
	Type *string `json:"type"`
	// Category type
	CategoryType *IntegrationCategory `json:"categoryType"`
	// Ci tool
	CiTool *SupportedCITools `json:"ciTool"`
	// Runtime name
	Runtime *string `json:"runtime"`
	// Include default integrations
	IncludeDefaultIntegrations *bool `json:"includeDefaultIntegrations"`
}

// IntegrationGenerationInput
type IntegrationGenerationInput struct {
	// Metadata
	Metadata *IntegrationGenerationMetadata `json:"metadata"`
	// Provider info
	ProviderInfo string `json:"providerInfo"`
	// Intended operation over integration
	Operation ResourceOperation `json:"operation"`
	// Yaml containing encrypted sealed secret
	SealedSecretYaml *string `json:"sealedSecretYaml"`
}

// IntegrationGenerationInput
type IntegrationGenerationMetadata struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
	// Runtimes
	Runtimes []string `json:"runtimes"`
	// isAllRuntimes
	IsAllRuntimes bool `json:"isAllRuntimes"`
}

// IntegrationGenerationInput
type IntegrationGenerationOutput struct {
	// Operations
	Operations []*RuntimeOperation `json:"operations"`
	// Manifests
	Manifests []*ResourceManifest `json:"manifests"`
}

// IntegrationReadModelEventPayload type
type IntegrationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (IntegrationReadModelEventPayload) IsReadModelEventPayload() {}

// Integration entity
type IntegrationSecret struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// Integration Type
	IntegrationType string `json:"integrationType"`
	// Integration Name
	IntegrationName string `json:"integrationName"`
	// Secret Type
	SecretType SecretType `json:"secretType"`
}

func (IntegrationSecret) IsBaseEntity()         {}
func (IntegrationSecret) IsGitopsEntity()       {}
func (IntegrationSecret) IsProjectBasedEntity() {}

// Integration Slice
type IntegrationSlice struct {
	// Integration edges
	Edges []*IntegrationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Issue value
type IssueValue struct {
	// Issue url
	URL string `json:"url"`
	// Issue title
	Title string `json:"title"`
	// Issue status
	Status string `json:"status"`
	// Issue avatar URL
	AvatarURL *string `json:"avatarURL"`
	// Issue assignee
	Assignee *string `json:"assignee"`
}

// K8s entity id
type K8sEntityID struct {
	// name
	Name string `json:"name"`
	// namespace
	Namespace *string `json:"namespace"`
}

// KeycloakSSO
type KeycloakSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Host
	Host *string `json:"host"`
	// Realm
	Realm *string `json:"realm"`
}

func (KeycloakSso) IsIDP() {}

// Label arrays
type LabelArrays struct {
	// Key
	Key string `json:"key"`
	// Value
	Value []string `json:"value"`
}

// Label
type LabelStringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// LdapSSO
type LdapSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Password
	Password *string `json:"password"`
	// URL
	URL *string `json:"url"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName"`
	// Search base
	SearchBase *string `json:"searchBase"`
	// Search filter
	SearchFilter *string `json:"searchFilter"`
	// Certificate
	Certificate *string `json:"certificate"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync"`
}

func (LdapSso) IsIDP() {}

// Stats for lead time for changes statistics
type LeadTimeForChangesStatistics struct {
	// Lead time for changes statistics data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Lead time for changes statistics info
	Info *DoraStatisticsSummery `json:"info"`
}

// LoadBalancer
type LoadBalancer struct {
	// Ingress
	Ingress []*Ingress `json:"ingress"`
}

// Logic entity id
type LogicEntityID struct {
	// id
	ID string `json:"id"`
}

// Mapping between the var name and the path to the value in event payload
type Mapping struct {
	// Name of the variable
	VarName string `json:"varName"`
	// Description of the variable
	Description string `json:"description"`
	// Indicates if the mapping should be used in filtering expressions. Some mappings can be useless for filtering, like GIT_REPO that will be the same for each event.
	Filter bool `json:"filter"`
}

// MetricMeasurement
type MetricMeasurement struct {
	// Finished at date
	FinishedAt *string `json:"finishedAt"`
	// Started at date
	StartedAt *string `json:"startedAt"`
	// Analysis Phase
	Phase *AnalysisPhases `json:"phase"`
	// Measurements metadata object (@job-name etc.)
	Metadata *string `json:"metadata"`
	// Measurement value
	Value *string `json:"value"`
}

// Metric result
type MetricResult struct {
	// Name
	Name string `json:"name"`
	// Provider type
	ProviderType AnalysisMetricProviderTypes `json:"providerType"`
	// Phase
	Phase AnalysisPhases `json:"phase"`
	// Measurements
	Measurements []*MetricMeasurement `json:"measurements"`
	// Message
	Message *string `json:"message"`
	// Successful measurements
	Successful *int `json:"successful"`
	// Failed measurements
	Failed *int `json:"failed"`
	// Inconclusive measurements
	Inconclusive *int `json:"inconclusive"`
	// Error measurements
	Error *int `json:"error"`
	// Failure Limit
	FailureLimit *int `json:"failureLimit"`
	// Inconclusive Limit
	InconclusiveLimit *int `json:"inconclusiveLimit"`
	// Measurements count
	Count *int `json:"count"`
	// Consecutive error limit
	ConsecutiveErrorLimit *int `json:"consecutiveErrorLimit"`
}

// Pipeline metric with trend
type MetricWithTrend struct {
	// Metric value
	Value int `json:"value"`
	// Percent Diff between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Reference Entity by runtime/name/namespace
type NameReferenceInput struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
	// Resource cluster URL
	Cluster *string `json:"cluster"`
}

// Object with name / value / code fields
type NameValueCodeInput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
	// Code
	Code *bool `json:"code"`
}

// Object with name / value / code fields
type NameValueCodeOutput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
	// Code
	Code *bool `json:"code"`
}

// Object with name and value fields
type NameValueInput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
}

// Object with name and value fields
type NameValueOutput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
}

// Named Resource
type NamedResource struct {
	// Name
	Name string `json:"name"`
}

// retriving many entities matching name
type NamespacedFindManyArgs struct {
	// Runtime name
	Runtime string `json:"runtime"`
	// Names
	Names []string `json:"names"`
	// Namespace
	Namespace string `json:"namespace"`
	// Kind
	Kind *string `json:"kind"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName *string `json:"templateName"`
	// Node children
	Children []*string `json:"children"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Message
	Message *string `json:"message"`
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Inputs
	Inputs *string `json:"inputs"`
	// Outputs
	Outputs *string `json:"outputs"`
	// Script
	Script *string `json:"script"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id"`
	// Resources Duration
	ResourcesDuration *string `json:"resourcesDuration"`
	// Template Ref
	TemplateRef *string `json:"templateRef"`
	// Host node name
	HostNodeName *string `json:"hostNodeName"`
	// Template
	Template *string `json:"template"`
	// Template scope
	TemplateScope *string `json:"templateScope"`
}

// Notification Edge
type NotificationEdge struct {
	// Node contains the actual notification data
	Node Notification `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// NotificationReadModelEventPayload
type NotificationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
	// Payload of event
	Notification Notification `json:"notification"`
}

func (NotificationReadModelEventPayload) IsReadModelEventPayload() {}

// Notification Slice
type NotificationSlice struct {
	// Notification edges
	Edges []*NotificationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Cluster URL
	Cluster *string `json:"cluster"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels"`
	// Annotations
	Annotations []*StringPair `json:"annotations"`
	// Last updated
	LastUpdated *string `json:"lastUpdated"`
	// Created
	Created *string `json:"created"`
	// K8s object uid
	UID *string `json:"uid"`
	// Favorite
	Favorite *bool `json:"favorite"`
}

// OktaSSO
type OktaSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// AutoGroupSync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// App Id
	AppID *string `json:"appId"`
}

func (OktaSso) IsIDP() {}

// "get one time token for a user
type OneTimeToken struct {
	// One time access token
	AccessToken string `json:"accessToken"`
}

// OneloginSSO
type OneloginSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// API client id
	APIClientID *string `json:"apiClientId"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret"`
}

func (OneloginSso) IsIDP() {}

// Pack
type Pack struct {
	// Metadata
	Metadata *PackMetadata `json:"metadata"`
	// Workflows
	Workflows *WorkflowConcurrency `json:"workflows"`
	// Runtime
	Runtime *PackRuntime `json:"runtime"`
	// Id
	ID *string `json:"id"`
}

// PackMetadata
type PackMetadata struct {
	// Description
	Description *string `json:"description"`
	// Name
	Name *string `json:"name"`
}

// PackRuntime
type PackRuntime struct {
	// DefaultDindResources
	DefaultDindResources *DefaultDindResources `json:"defaultDindResources"`
	// Name
	Name *string `json:"name"`
	// OS
	Os *string `json:"os"`
	// Architecture
	Architecture *string `json:"architecture"`
	// CPU
	CPU *string `json:"cpu"`
	// Memory
	Memory *string `json:"memory"`
	// Storage
	Storage *string `json:"storage"`
	// DindStorage
	DindStorage *string `json:"dindStorage"`
}

// Parent workflow reference
type ParentWorkflowRef struct {
	// Parent workflow
	Workflow *Workflow `json:"workflow"`
	// Parent workflow type
	Type *string `json:"type"`
}

// PastDue
type PastDue struct {
	// IsPastDue
	IsPastDue *bool `json:"isPastDue"`
	// ShowPastDueWarning
	ShowPastDueWarning *bool `json:"showPastDueWarning"`
}

// Permission model
type Permission struct {
	// The id of the user with the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
	// Deprecated: The user with the permission
	User *User `json:"user"`
}

// Permission input
type PermissionInput struct {
	// The id of the user the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self"`
	// History of the pipeline
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity"`
}

func (Pipeline) IsBaseEntity()         {}
func (Pipeline) IsK8sLogicEntity()     {}
func (Pipeline) IsProjectBasedEntity() {}
func (Pipeline) IsEntity()             {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time"`
	// Committers
	Committers *int `json:"committers"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time"`
	// Executions
	Executions *int `json:"executions"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace string `json:"pipelineNamespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame"`
	// Success Rate stats
	SuccessRateStats *MetricWithTrend `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
}

// PipelineReadModelEventPayload type
type PipelineReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (PipelineReadModelEventPayload) IsReadModelEventPayload() {}

// Pipeline Reference
type PipelineRef struct {
	// Id
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Project
	Project string `json:"project"`
	// ProjectId
	ProjectID string `json:"projectId"`
}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats"`
}

// Pipeline Step
type PipelineStepStatistics struct {
	// Step Name
	StepName *string `json:"stepName"`
	// Template Name
	TemplateName *string `json:"templateName"`
	// Workflow Template
	WorkflowTemplate *string `json:"workflowTemplate"`
	// Node Type
	NodeType *string `json:"nodeType"`
	// Step Average duration
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Step Executions count
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
	// Step Average CPU usage
	CPUStats *MetricWithTrend `json:"cpuStats"`
	// Step Average Memory
	MemoryStats *MetricWithTrend `json:"memoryStats"`
	// Step Errors count
	ErrorsCountStats *MetricWithTrend `json:"errorsCountStats"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time"`
	// Success rate
	SuccessRate *int `json:"successRate"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace"`
	// Filter pipelines from a specific cluster URL
	Cluster *string `json:"cluster"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name"`
	// Filter pipelines from a specific groups
	Groups []*string `json:"groups"`
	// Filter pipelines from a specific versions
	Versions []*string `json:"versions"`
	// Filter pipelines by workflowTemplate
	WorkflowTemplate *string `json:"workflowTemplate"`
}

// Plan
type Plan struct {
	// Stripe
	Stripe *Stripe `json:"stripe"`
	// Trial
	Trial *Trial `json:"trial"`
	// BasePrice
	BasePrice *BasePrice `json:"basePrice"`
	// Workflows
	Workflows *PlanWorkflows `json:"workflows"`
	// Environments
	Environments *PlanEnvironment `json:"environments"`
	// DataRetention
	DataRetention *DataRetention `json:"dataRetention"`
	// Collaborators
	Collaborators *PlanCollaborators `json:"collaborators"`
	// PastDue
	PastDue *PastDue `json:"pastDue"`
	// NewPricingModel
	NewPricingModel *bool `json:"newPricingModel"`
	// Azure
	Azure *bool `json:"azure"`
	// Currency
	Currency *string `json:"currency"`
	// Default
	Default *bool `json:"default"`
	// Dedicated
	Dedicated *bool `json:"dedicated"`
	// PrivateRepo
	PrivateRepo *bool `json:"privateRepo"`
	// PaymentInterval
	PaymentInterval *string `json:"paymentInterval"`
	// IsWiredTransfer
	IsWiredTransfer *bool `json:"isWiredTransfer"`
	// Packs
	Packs []*Pack `json:"packs"`
	// TotalPrice
	TotalPrice *int `json:"totalPrice"`
	// DisplayName
	DisplayName *string `json:"displayName"`
	// Id
	ID *string `json:"id"`
	// DefaultPack
	DefaultPack *string `json:"defaultPack"`
	// Segment
	Segment *string `json:"segment"`
	// MRR
	Mrr *int `json:"mrr"`
	// ARR
	Arr *int `json:"arr"`
}

// PlanCollaborators
type PlanCollaborators struct {
	// Limit
	Limit *int `json:"limit"`
}

// PlanEnvironment
type PlanEnvironment struct {
	// Concurrency
	Concurrency *EnvironmentConcurrency `json:"concurrency"`
}

// PlanWorkflows
type PlanWorkflows struct {
	// Concurrency
	Concurrency *WorkflowConcurrency `json:"concurrency"`
}

// Pod Spec
type PodSpec struct {
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// PodTemplate Spec
type PodTemplateSpec struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Spec
	Spec *PodSpec `json:"spec"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilter struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilterArgs struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// ProjectReadModelEventPayload type
type ProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// PullRequestCommitter
type PullRequestCommitter struct {
	// userName
	UserName string `json:"userName"`
	// avatar
	Avatar string `json:"avatar"`
}

// PullRequest value
type PullRequestValue struct {
	// url
	URL string `json:"url"`
	// title
	Title string `json:"title"`
	// committers
	Committers []*PullRequestCommitter `json:"committers"`
	// commits
	Commits []*Commits `json:"commits"`
}

// ReadModelEventResponse
type ReadModelEventResponse struct {
	// Account ID
	AccountID string `json:"accountId"`
	// Time of event
	Time string `json:"time"`
	// Payload of event
	Payload ReadModelEventPayload `json:"payload"`
}

// Registry
type Registry struct {
	// Domain
	Domain string `json:"domain"`
	// Registry type
	Type ImageRegistryType `json:"type"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// Original Repository Prefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// RegistryInput
type RegistryInput struct {
	// Id
	ID string `json:"id"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// RegistryInput
type RegistryOutput struct {
	// Id
	ID *string `json:"id"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// Release Entity - represents a Codefresh runtime release
type Release struct {
	// Release version
	Version string `json:"version"`
	// Has security vulnerabilities
	HasSecurityVulnerabilities *bool `json:"hasSecurityVulnerabilities"`
}

// Rollout Rollout State
type ReleaseRolloutState struct {
	// Name
	Name string `json:"name"`
	// UID
	UID *string `json:"uid"`
	// Revision
	CurrentRevision int `json:"currentRevision"`
	// Status of the process
	Phase RolloutPhases `json:"phase"`
	// Name of current strategy
	CurrentStrategyName RolloutStrategyNames `json:"currentStrategyName"`
	// Number of steps
	Steps *int `json:"steps"`
	// Current step index
	CurrentStepIndex *int `json:"currentStepIndex"`
	// Services
	Services []*string `json:"services"`
	// Status of PrePromotion analysis
	PrePromotionAnalysisRunStatus *RolloutAnalysisStatus `json:"prePromotionAnalysisRunStatus"`
	// Status of postPromotion analysis
	PostPromotionAnalysisRunStatus *RolloutAnalysisStatus `json:"postPromotionAnalysisRunStatus"`
	// Status of inline analyses
	StepsAnalysisRunStatuses []*RolloutAnalysisStatus `json:"stepsAnalysisRunStatuses"`
	// Status of background status
	BackgroundAnalysisRunStatus *RolloutAnalysisStatus `json:"backgroundAnalysisRunStatus"`
	// Revision info
	RevisionInfo *RevisionInfo `json:"revisionInfo"`
	// Is rollout complete
	IsComplete bool `json:"isComplete"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images"`
	// SyncStatus
	SyncStatus *SyncStatus `json:"syncStatus"`
	// Replicas
	Replicas *int `json:"replicas"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// RepoBitbucketCloudFilterArgs
type RepoBitbucketCloudFilterArgs struct {
	// Repo owner
	Owner string `json:"owner"`
	// Repo projectKey
	ProjectKey string `json:"projectKey"`
	// Repo name
	RepositorySlug string `json:"repositorySlug"`
}

// RepoBitbucketCloudFilterArgs
type RepoBitbucketCloudFilterArgsInput struct {
	// Repo owner
	Owner string `json:"owner"`
	// Repo projectKey
	ProjectKey string `json:"projectKey"`
	// Repo name
	RepositorySlug string `json:"repositorySlug"`
}

// Runtime Errors Report Arguments
type ReportRuntimeErrorsArgs struct {
	// Name of the Runtime
	Runtime string `json:"runtime"`
	// Errors
	Errors []*HealthErrorInput `json:"errors"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Resource manifest
type ResourceManifest struct {
	// Full filename with path
	Filename *string `json:"filename"`
	// Status: created, updated, deleted
	Status *string `json:"status"`
	// K8s kind
	Kind string `json:"kind"`
	// File contents
	Content string `json:"content"`
	// Old file contents
	OldContent *string `json:"oldContent"`
	// Git commit sha
	Revision *string `json:"revision"`
	// Entities referenced by this resource
	ReferencedBy []*BaseReference `json:"referencedBy"`
}

// ResourcesRequests
type ResourcesRequests struct {
	// CPU
	CPU *string `json:"cpu"`
	// Memory
	Memory *string `json:"memory"`
}

// Revision Info Entity
type RevisionInfo struct {
	// Image Name
	Image string `json:"image"`
	// Image details
	ImageDetails *RolloutImageDetails `json:"imageDetails"`
	// Current traffic weight directed to this revision
	Weight int `json:"weight"`
	// Current replicas
	Replicas *int `json:"replicas"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas"`
	// Current unavailable replicas
	UnavailableReplicas *int `json:"unavailableReplicas"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas"`
}

// "Rollout Entity
type Rollout struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// History of the entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Spec
	Spec *RolloutSpec `json:"spec"`
	// Status
	Status *RolloutStatus `json:"status"`
}

func (Rollout) IsProjectBasedEntity() {}
func (Rollout) IsGitopsEntity()       {}
func (Rollout) IsBaseEntity()         {}
func (Rollout) IsEntity()             {}

// Rollout Analysis Status
type RolloutAnalysisStatus struct {
	// Number of erroneous measurments
	Error int `json:"error"`
	// Number of failed measurments
	Failed int `json:"failed"`
	// Number of inconclusive measurments
	Inconclusive int `json:"inconclusive"`
	// Name of the analysis
	Name string `json:"name"`
	// The summary state of the analysis, taking into account defined limits
	Phase string `json:"phase"`
	// Number of successful measurments
	Successful int `json:"successful"`
}

// Rollout Set Canary Scale Step
type RolloutCanaryInlineAnalysisStep struct {
	// Replicas
	Templates []*RolloutInlineAnalysisTemplate `json:"templates"`
	// Name value args list
	Args []*NameValueOutput `json:"args"`
}

// Rollout Canary Pause Step
type RolloutCanaryPauseStep struct {
	// Duration settings
	Duration *string `json:"duration"`
}

// Rollout Set Canary Scale Step
type RolloutCanarySetScaleStep struct {
	// Replicas
	Replicas *int `json:"replicas"`
	// Weight
	Weight *int `json:"weight"`
	// Match Traffic Weight
	MatchTrafficWeight *bool `json:"matchTrafficWeight"`
}

// Rollout Canary Step
type RolloutCanaryStep struct {
	// Set weight
	SetWeight *int `json:"setWeight"`
	// Pause settings
	Pause *RolloutCanaryPauseStep `json:"pause"`
	// Set canary scal
	SetCanaryScale *RolloutCanarySetScaleStep `json:"setCanaryScale"`
	// Inline analysis
	Analysis *RolloutCanaryInlineAnalysisStep `json:"analysis"`
	// Inline experiment
	Experiment *RolloutInlineExperimentTemplate `json:"experiment"`
	// Related Analysis Run object
	AnalysisRun *AnalysisRun `json:"analysisRun"`
}

// Rollout Edge
type RolloutEdge struct {
	// Node contains the actual rollout data
	Node *Rollout `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RolloutEdge) IsEdge() {}

// Rollout filter arguments
type RolloutFilterArgs struct {
	// Filter rollouts from a specific project
	Project *string `json:"project"`
	// Filter rollouts from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter rollouts by group
	Group *string `json:"group"`
	// Filter rollouts by version
	Version *string `json:"version"`
	// Filter rollouts from a specific cluster url
	Cluster *string `json:"cluster"`
}

// Rollout Image Details
type RolloutImageDetails struct {
	// Image name
	Image string `json:"image"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Workflow name
	WorkflowName *string `json:"workflowName"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl"`
	// CI provider
	CiProvider *string `json:"ciProvider"`
}

// Rollout Set Canary Scale Step
type RolloutInlineAnalysisTemplate struct {
	// Template name
	TemplateName string `json:"templateName"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentAnalyses struct {
	// Name
	Name string `json:"name"`
	// Template name
	TemplateName string `json:"templateName"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentTemplate struct {
	// Duration
	Duration *string `json:"duration"`
	// Templates
	Templates []*RolloutInlineExperimentTemplates `json:"templates"`
	// Analyses
	Analyses []*RolloutInlineExperimentAnalyses `json:"analyses"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentTemplates struct {
	// Name
	Name string `json:"name"`
	// Spec ref
	SpecRef string `json:"specRef"`
}

// Rollout Slice
type RolloutSlice struct {
	// Rollout edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RolloutSlice) IsSlice() {}

// Rollout Spec
type RolloutSpec struct {
	// Strategy
	Strategy *RolloutStrategy `json:"strategy"`
	// Desired replicas
	DesiredReplicas int `json:"desiredReplicas"`
}

// Rollout Status
type RolloutStatus struct {
	// Index of the current step that is being executed
	CurrentStepIndex *int `json:"currentStepIndex"`
	// Status of the process
	Phase string `json:"phase"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas"`
	// Current traffic weight of the new version
	WeightOfNew int `json:"weightOfNew"`
	// Is the rollout aborted
	Abort *bool `json:"abort"`
	// Status of inline analysis
	CurrentStepAnalysisRunStatus *RolloutAnalysisStatus `json:"currentStepAnalysisRunStatus"`
	// Status of background status
	BackgroundAnalysisRunStatus *RolloutAnalysisStatus `json:"backgroundAnalysisRunStatus"`
}

// Rollout Strategy
type RolloutStrategy struct {
	// Name
	Name string `json:"name"`
	// Rollout new image
	NewImage string `json:"newImage"`
	// Rollout new image details
	NewImageRegistry *ImageRegistry `json:"newImageRegistry"`
	// Steps
	Steps []*RolloutCanaryStep `json:"steps"`
	// The name of the service pointing to the old version
	CurrentService *string `json:"currentService"`
	// The name of the service pointing to the new version
	NewService *string `json:"newService"`
	// Canary background analysis run details
	BackgroundAnalysisRun *AnalysisRun `json:"backgroundAnalysisRun"`
	// Canary background analysis starting step
	BackgoundAnalysisSpec *string `json:"backgoundAnalysisSpec"`
	// Blue-green pre promotion analysis run details
	PrePromotionAnalysisRun *AnalysisRun `json:"prePromotionAnalysisRun"`
	// Blue-green post promotion analysis run details
	PostPromotionAnalysisRun *AnalysisRun `json:"postPromotionAnalysisRun"`
}

// RolloutTransition Entity
type RolloutTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseRolloutState `json:"from"`
	// To
	To *ReleaseRolloutState `json:"to"`
}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// History of the runtime
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster"`
	// Runtime is managed
	Managed bool `json:"managed"`
	// At least one remote cluster is connected (for managed runtimes)
	IsRemoteClusterConnected bool `json:"isRemoteClusterConnected"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost"`
	// Internal Ingress host of the runtime - for app proxy usage only
	InternalIngressHost *string `json:"internalIngressHost"`
	// Ingress class of the runtime
	IngressClass *string `json:"ingressClass"`
	// Ingress controller of the runtime
	IngressController *string `json:"ingressController"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion"`
	// Runtime release information
	RuntimeRelease *Release `json:"runtimeRelease"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
	// Clusters managed by this runtime
	ManagedClusters []*Cluster `json:"managedClusters"`
	// Total number of clusters managed by this runtime
	ManagedClustersNum int `json:"managedClustersNum"`
	// Runtime features
	Features []*RuntimeFeature `json:"features"`
	// The git provider of the installation repo
	GitProvider *GitProviders `json:"gitProvider"`
	// The access mode to the runtime - INGRESS|TUNNEL
	AccessMode AccessMode `json:"accessMode"`
}

func (Runtime) IsBaseEntity()         {}
func (Runtime) IsProjectBasedEntity() {}
func (Runtime) IsK8sLogicEntity()     {}
func (Runtime) IsEntity()             {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Feature
type RuntimeFeature struct {
	// Runtime feature name
	Name string `json:"name"`
	// Is feature supported
	Supported bool `json:"supported"`
	// Minimal runtime version supporting the feature
	RequiredVersion *string `json:"requiredVersion"`
}

// RuntimeInfo
type RuntimeInfo struct {
	// Name
	Name string `json:"name"`
}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Cluster
	Cluster string `json:"cluster"`
	// Managed runtime (default false)
	Managed *bool `json:"managed"`
	// The git provider of the installation repo
	GitProvider *GitProviders `json:"gitProvider"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost"`
	// Internal Ingress Host
	InternalIngressHost *string `json:"internalIngressHost"`
	// Ingress class name
	IngressClass *string `json:"ingressClass"`
	// Ingress controller name
	IngressController *string `json:"ingressController"`
	// Gateway name
	GatewayName *string `json:"gatewayName"`
	// Gateway namespace
	GatewayNamespace *string `json:"gatewayNamespace"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
	// Does runtime installed from an existing repo
	Recover *bool `json:"recover"`
	// The access mode to the runtime - INGRESS|TUNNEL
	AccessMode *AccessMode `json:"accessMode"`
}

// Runtime Integarion Response
type RuntimeIntegration struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
	// Config Name
	Config *NamedResource `json:"config"`
	// Secret Name
	Secret *NamedResource `json:"secret"`
}

// Runtume Notification
type RuntimeNotification struct {
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (RuntimeNotification) IsNotification()       {}
func (RuntimeNotification) IsArgoCDNotification() {}

// IntegrationGenerationInput
type RuntimeOperation struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Runtime
	Name string `json:"name"`
	// Runtime
	Action RuntimeOperationAction `json:"action"`
}

// RuntimeReadModelEventPayload type
type RuntimeReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (RuntimeReadModelEventPayload) IsReadModelEventPayload() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// Runtimes statistics
type RuntimesStatistics struct {
	// Total runtimes number
	Total int `json:"total"`
	// Number of unhealthy runtimes
	Unhealthy int `json:"unhealthy"`
}

// SSOArgs
type SSOArgs struct {
	// Id
	ID *string `json:"id"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName *string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Entry point
	EntryPoint *string `json:"entryPoint"`
	// Callback url
	CallbackURL *string `json:"callbackUrl"`
	// Cert
	Cert *string `json:"cert"`
	// Provider
	Provider *string `json:"provider"`
	// Keyfile
	Keyfile *string `json:"keyfile"`
	// Subject
	Subject *string `json:"subject"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
	// SyncField
	SyncField *string `json:"syncField"`
	// App Id
	AppID *string `json:"appId"`
	// Tenant
	Tenant *string `json:"tenant"`
	// Password
	Password *string `json:"password"`
	// URL
	URL *string `json:"url"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName"`
	// Search base
	SearchBase *string `json:"searchBase"`
	// Search filter
	SearchFilter *string `json:"searchFilter"`
	// Certificate
	Certificate *string `json:"certificate"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// API client id
	APIClientID *string `json:"apiClientId"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Host
	Host *string `json:"host"`
	// Realm
	Realm *string `json:"realm"`
	// Default
	Default *bool `json:"default"`
}

// SamlSSO
type SamlSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Entry point
	EntryPoint *string `json:"entryPoint"`
	// Callback url
	CallbackURL *string `json:"callbackUrl"`
	// Cert
	Cert *string `json:"cert"`
	// Provider
	Provider *string `json:"provider"`
	// Keyfile
	Keyfile *string `json:"keyfile"`
	// Subject
	Subject *string `json:"subject"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
	// SyncField
	SyncField *string `json:"syncField"`
}

func (SamlSso) IsIDP() {}

// SecretData
type SecretData struct {
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace string `json:"namespace"`
	// Path
	Path *SecretPath `json:"path"`
}

// GitAuthConfig form spec
type SecretDataInput struct {
	// Secret name
	Name string `json:"name"`
	// Secret namespace
	Namespace *string `json:"namespace"`
	// Secret filed paths
	Path *SecretFieldPaths `json:"path"`
}

// SecretFieldPaths
type SecretFieldPaths struct {
	// AppId
	AppID string `json:"appId"`
	// ClientId
	ClientID string `json:"clientId"`
	// ClientSecret
	ClientSecret string `json:"clientSecret"`
	// Url
	URL string `json:"url"`
}

// SecretPath
type SecretPath struct {
	// AppId
	AppID string `json:"appId"`
	// ClientId
	ClientID string `json:"clientId"`
	// ClientSecret
	ClientSecret string `json:"clientSecret"`
	// Url
	URL string `json:"url"`
}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the sensor
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (Sensor) IsGitopsEntity()       {}
func (Sensor) IsBaseEntity()         {}
func (Sensor) IsProjectBasedEntity() {}
func (Sensor) IsEntity()             {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// SensorReadModelEventPayload type
type SensorReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (SensorReadModelEventPayload) IsReadModelEventPayload() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Service entity
type ServiceEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// ServiceSpec
	Spec *ServiceSpec `json:"spec"`
	// ServiceStatus
	Status *ServiceStatus `json:"status"`
	// Deployment Spec Part
	Deployments []*DeploymentSpecPart `json:"deployments"`
}

func (ServiceEntity) IsGitopsEntity()       {}
func (ServiceEntity) IsBaseEntity()         {}
func (ServiceEntity) IsProjectBasedEntity() {}
func (ServiceEntity) IsEntity()             {}

// Service Entity Edge
type ServiceEntityEdge struct {
	// Node contains the actual Service data
	Node *ServiceEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ServiceEntityEdge) IsEdge() {}

// Service Slice
type ServiceEntitySlice struct {
	// Service edges
	Edges []*ServiceEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ServiceEntitySlice) IsSlice() {}

// Service Item Entity
type ServiceItem struct {
	// Name
	Name *string `json:"name"`
}

// ServicePort
type ServicePort struct {
	// AppProtocol
	AppProtocol *string `json:"appProtocol"`
	// Name
	Name *string `json:"name"`
	// NodePort
	NodePort *int `json:"nodePort"`
	// Port
	Port *int `json:"port"`
	// Protocol
	Protocol *string `json:"protocol"`
	// TargetPort
	TargetPort *string `json:"targetPort"`
}

// ServiceReadModelEventPayload type
type ServiceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (ServiceReadModelEventPayload) IsReadModelEventPayload() {}

// Service sorting arguments
type ServiceSortArg struct {
	// Field for sorting
	Field ServiceSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// ServiceSpec
type ServiceSpec struct {
	// AllocateLoadBalancerNodePorts
	AllocateLoadBalancerNodePorts *bool `json:"allocateLoadBalancerNodePorts"`
	// ClusterIP
	ClusterIP *string `json:"clusterIP"`
	// ClusterIPs
	ClusterIPs []*string `json:"clusterIPs"`
	// ExternalIPs
	ExternalIPs []*string `json:"externalIPs"`
	// ExternalName
	ExternalName *string `json:"externalName"`
	// ExternalTrafficPolicy
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy"`
	// HealthCheckNodePort
	HealthCheckNodePort *int `json:"healthCheckNodePort"`
	// InternalTrafficPolicy
	InternalTrafficPolicy *string `json:"internalTrafficPolicy"`
	// IpFamilies
	IPFamilies []*string `json:"ipFamilies"`
	// IpFamilyPolicy
	IPFamilyPolicy *string `json:"ipFamilyPolicy"`
	// LoadBalancerClass
	LoadBalancerClass *string `json:"loadBalancerClass"`
	// LoadBalancerIP
	LoadBalancerIP *string `json:"loadBalancerIP"`
	// LoadBalancerSourceRanges
	LoadBalancerSourceRanges []*string `json:"loadBalancerSourceRanges"`
	// Ports
	Ports []*ServicePort `json:"ports"`
	// PublishNotReadyAddresses
	PublishNotReadyAddresses *bool `json:"publishNotReadyAddresses"`
	// Selector
	Selector []*StringPair `json:"selector"`
	// SessionAffinity
	SessionAffinity *string `json:"sessionAffinity"`
	// SessionAffinityConfig
	SessionAffinityConfig *SessionAffinityConfig `json:"sessionAffinityConfig"`
	// Type
	Type *ServiceType `json:"type"`
}

// ServiceStatus
type ServiceStatus struct {
	// LoadBalancer
	LoadBalancer *LoadBalancer `json:"loadBalancer"`
}

// ServiceTransition Entity
type ServiceTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseServiceState `json:"from"`
	// To
	To *ReleaseServiceState `json:"to"`
}

// Services filter arguments
type ServicesFilterArgs struct {
	// Filter services from a specific project
	Project *string `json:"project"`
	// Filter services from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter services from a specific namespaces
	Namespace []string `json:"namespace"`
	// Filter services by groups
	Groups []string `json:"groups"`
	// Filter services by versions
	Versions []string `json:"versions"`
	// Filter services from a specific application
	Application *string `json:"application"`
	// Filter services with a specific health statuses
	HealthStatus []HealthStatus `json:"healthStatus"`
	// Filter services by name fragment
	ServiceName *string `json:"serviceName"`
	// Filter services by cluster URL
	Cluster *string `json:"cluster"`
}

// SessionAffinityConfig
type SessionAffinityConfig struct {
	// ClientIP
	ClientIP *ClientIP `json:"clientIP"`
}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
}

// Args to set the permissions of a specific user to a git-source
type SetGitSourcePermissionArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The new permission to set
	Permission *PermissionInput `json:"permission"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Object of specific trigger conditions
type SpecificTriggerConditions struct {
	// Github trigger conditions
	Github []*GithubTriggerConditions `json:"github"`
	// Gitlab trigger conditions
	Gitlab []*GitlabTriggerConditions `json:"gitlab"`
	// BitbucketServer trigger conditions
	Bitbucketserver []*BitbucketServerTriggerConditions `json:"bitbucketserver"`
	// BitbucketCloud trigger conditions
	Bitbucket []*BitbucketCloudTriggerConditions `json:"bitbucket"`
	// Calendar trigger conditions
	Calendar []*CalendarTriggerConditions `json:"calendar"`
}

// Object of specific trigger conditions
type SpecificTriggerConditionsArgs struct {
	// Github trigger conditions
	Github []*GithubTriggerConditionsArgs `json:"github"`
	// Gitlab trigger conditions
	Gitlab []*GitlabTriggerConditionsArgs `json:"gitlab"`
	// BitbucketServer trigger conditions
	Bitbucketserver []*BitbucketServerTriggerConditionsArgs `json:"bitbucketserver"`
	// BitbucketCloud trigger conditions
	Bitbucket []*BitbucketCloudTriggerConditionsArgs `json:"bitbucket"`
	// Calendar trigger conditions
	Calendar []*CalendarTriggerConditionsArgs `json:"calendar"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType"`
	// Display name
	DisplayName *string `json:"displayName"`
}

// Statistics Date Range Filter
type StatisticsDateRangeFilterWithTz struct {
	// Start Date From
	StartDateFrom string `json:"startDateFrom"`
	// Start Date To
	StartDateTo string `json:"startDateTo"`
	// Client Time zone
	Timezone string `json:"timezone"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message"`
}

// Label
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// Stripe
type Stripe struct {
	// Name
	HardCodedPlan *bool `json:"hardCodedPlan"`
	// Plan id
	PlanID *string `json:"planId"`
	// Subscription id
	SubscriptionID *string `json:"subscriptionId"`
	// Customer id
	CustomerID *string `json:"customerId"`
}

// Event filter
type SupportedEventMapping struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// Mappings between the var name and the path to the value in event payload
	Mappings []*Mapping `json:"mappings"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context"`
}

func (SyncError) IsError() {}

// ApplicationSyncResult
type SyncResultResource struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Message
	Message *string `json:"message"`
	// Sync Action On Resource
	SyncActionOnResource *SyncActionOnResource `json:"syncActionOnResource"`
	// Status
	Status *SyncResultCode `json:"status"`
	// Sync Phase
	SyncPhase *SyncPhase `json:"syncPhase"`
	// Hook Phase
	HookPhase *SyncOperationPhase `json:"hookPhase"`
	// Hook Type
	HookType *SyncHookType `json:"hookType"`
}

// To State Entity
type ToState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Transition Entity
type Transition struct {
	// Services
	Services []*ServiceTransition `json:"services"`
	// Rollouts
	Rollouts []*RolloutTransition `json:"rollouts"`
}

// Trial
type Trial struct {
	// Trialing
	Trialing *bool `json:"trialing"`
	// IsRuntimePaying
	IsRuntimePaying *bool `json:"isRuntimePaying"`
	// TrialWillEndNotified
	TrialWillEndNotified *bool `json:"trialWillEndNotified"`
	// TrialEndedNotified
	TrialEndedNotified *bool `json:"trialEndedNotified"`
	// Type
	Type *string `json:"type"`
	// PreviousSegment
	PreviousSegment *string `json:"previousSegment"`
	// TrialEnd
	TrialEnd *string `json:"trialEnd"`
}

// Differentiated DataFilters
type TriggerConditionDataFilters struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilter `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilter `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilter `json:"predefined"`
}

// Differentiated DataFilters
type TriggerConditionDataFiltersArgs struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilterArgs `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilterArgs `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilterArgs `json:"predefined"`
}

// TriggerConditions filters object
type TriggerConditionFilters struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFilters `json:"data"`
}

// TriggerConditions filters object
type TriggerConditionFiltersArgs struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFiltersArgs `json:"data"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameter struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameterArgs struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditions struct {
	// Conditions
	Conditions *SpecificTriggerConditions `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflow `json:"workflow"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditionsArgs struct {
	// Sensor name
	SensorName string `json:"sensorName"`
	// Trigger name
	TriggerName string `json:"triggerName"`
	// Ingress host (SET ON BACKEND)
	IngressHost *string `json:"ingressHost"`
	// Conditions
	Conditions *SpecificTriggerConditionsArgs `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflowArgs `json:"workflow"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflow struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameter `json:"parameters"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflowArgs struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameterArgs `json:"parameters"`
}

// Reference Entity by uid
type UIDReferenceInput struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Unique ID
	UID string `json:"uid"`
}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// Args to update the permissions of a git-source
type UpdateGitSourcePermissionsArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The set of permissions
	Permissions []*PermissionInput `json:"permissions"`
}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount"`
	// The customers that this user is in
	Customers []Customer `json:"customers"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate"`
	// User chosen sso of active account
	Sso *string `json:"sso"`
	// User settings
	Settings *UserSettings `json:"settings"`
}

// Args to edit user details
type UserDetailsArgs struct {
	// User settings
	Settings *UserSettingsArgs `json:"settings"`
}

// "User settings
type UserSettings struct {
	// Allow admin to login
	AllowAdminToLogin *bool `json:"allowAdminToLogin"`
}

// Args to edit settings user details
type UserSettingsArgs struct {
	// Allow admin to login
	AllowAdminToLogin *bool `json:"allowAdminToLogin"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Initiator of the workflow
	Initiator *WorkflowInitiator `json:"initiator"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []string `json:"eventsPayload"`
	// Pipeline reference
	Pipeline *Pipeline `json:"pipeline"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Workflow URL. Maybe empty if the runtime was deleted.
	URL *string `json:"url"`
	// Workflow's runtime ingress host. Maybe empty if the runtime was deleted.
	IngressHost *string `json:"ingressHost"`
	// Workflow's runtime version. Maybe empty if the runtime was deleted.
	RuntimeVersion *string `json:"runtimeVersion"`
	// Indicates that workflow was created by platform/app-proxy and the value shows the flow that caused the creation
	OriginatedFrom *string `json:"originatedFrom"`
	// Workflows which executed by this workflow
	ChildWorkflows []*ChildWorkflowRef `json:"childWorkflows"`
	// Parent workflow that executed this workflow
	ParentWorkflow *ParentWorkflowRef `json:"parentWorkflow"`
	// Image details that was created from report image workflow execution.
	ImageDetails *ImageDetails `json:"imageDetails"`
}

func (Workflow) IsProjectBasedEntity() {}
func (Workflow) IsBaseEntity()         {}
func (Workflow) IsK8sStandardEntity()  {}
func (Workflow) IsEntity()             {}

// WorkflowArguments
type WorkflowArguments struct {
	// Workflow parameters
	Parameters []*WorkflowParameter `json:"parameters"`
}

// WorkflowConcurrency
type WorkflowConcurrency struct {
	// Concurrency
	Concurrency *WorkflowConcurrencyInfo `json:"concurrency"`
}

// WorkflowConcurrency
type WorkflowConcurrencyInfo struct {
	// Price
	Price *BasePrice `json:"price"`
	// Amount
	Amount *int `json:"amount"`
	// Absorb
	Absorb *int `json:"absorb"`
	// Min
	Min *int `json:"min"`
	// Max
	Max *int `json:"max"`
	// AllowUnlimited
	AllowUnlimited *bool `json:"allowUnlimited"`
}

// Workflow conditions
type WorkflowConditions struct {
	// Type
	Type *string `json:"type"`
	// Status
	Status *string `json:"status"`
}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// Command array
	Command []*string `json:"command"`
	// Args
	Args []*string `json:"args"`
	// Env map
	Env []*StringPair `json:"env"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon"`
	// Container
	Container *WorkflowContainerSpec `json:"container"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// If the workflow created through the wt playground it will contain username and avatar URL of codefresh user.
// If the workflow was triggered by some GIT event it will contain username and avatar URL of git user.
// Otherwise this field will be empty.
type WorkflowInitiator struct {
	// Initiator name
	Name string `json:"name"`
	// Initiator avatar URL
	AvatarURL *string `json:"avatarURL"`
}

// Workflow last execution object
type WorkflowLastExecution struct {
	// Arguments
	Arguments *WorkflowArguments `json:"arguments"`
}

// Workflow Parameter object
type WorkflowParameter struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value"`
	// Default value
	Default *string `json:"default"`
}

// Workflow Parameter object
type WorkflowParameterArgs struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value"`
	// Default value
	Default *string `json:"default"`
}

// WorkflowReadModelEventPayload type
type WorkflowReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (WorkflowReadModelEventPayload) IsReadModelEventPayload() {}

// "Repository data for workflows
type WorkflowRepository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow resources duration
type WorkflowResourcesDuration struct {
	// Cpu
	CPU *int `json:"cpu"`
	// Memory
	Memory *int `json:"memory"`
}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Pipeline filter arguments
type WorkflowStatisticsFilterArgs struct {
	// Date range filter
	DateRange *StatisticsDateRangeFilterWithTz `json:"dateRange"`
	// Repository name
	RepoName []string `json:"repoName"`
	// workflow status
	Status []WorkflowPhases `json:"status"`
	// Git Event Type
	GitEventType []string `json:"gitEventType"`
	// Initiator
	Initiator []string `json:"initiator"`
	// Brnach Name
	Branch []string `json:"branch"`
	// Pipeline Name
	PipelineName []string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace []string `json:"pipelineNamespace"`
	// Runtime
	Runtime []string `json:"runtime"`
}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes"`
	// Message
	Message *string `json:"message"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Stored Templates
	StoredTemplates *string `json:"storedTemplates"`
	// Stored workflow template spec
	StoredWorkflowTemplateSpec *string `json:"storedWorkflowTemplateSpec"`
	// Conditions
	Conditions []*WorkflowConditions `json:"conditions"`
	// Resources duration
	ResourcesDuration *WorkflowResourcesDuration `json:"resourcesDuration"`
	// Amount of running pods
	RunningPodsCount int `json:"runningPodsCount"`
	// Name of the first running pod
	ActivePodName *string `json:"activePodName"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the workflow-template
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity()       {}
func (WorkflowTemplate) IsBaseEntity()         {}
func (WorkflowTemplate) IsProjectBasedEntity() {}
func (WorkflowTemplate) IsEntity()             {}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// WorkflowTemplateReadModelEventPayload type
type WorkflowTemplateReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item"`
}

func (WorkflowTemplateReadModelEventPayload) IsReadModelEventPayload() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow template filter arguments
type WorkflowTemplatesFilterArgs struct {
	// Filter WorkflowTemplates from a specific project
	Project *string `json:"project"`
	// Filter WorkflowTemplates from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter WorkflowTemplates from a specific cluster URL
	Cluster *string `json:"cluster"`
	// Filter WorkflowTemplates by name
	Name *string `json:"name"`
	// Filter WorkflowTemplates by namespace
	Namespace *string `json:"namespace"`
	// Filter WorkflowTemplates by group
	Groups []*string `json:"groups"`
	// Filter WorkflowTemplates by version
	Versions []*string `json:"versions"`
	// Filter WorkflowTemplates by git source
	GitSource *string `json:"gitSource"`
}

// Workflow filter arguments
type WorkflowsFilterArgs struct {
	// Filter workflows from a specific project
	Project *string `json:"project"`
	// Filter workflows from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter workflows from a specific namespace
	Namespace *string `json:"namespace"`
	// Filter workflows by groups
	Groups []string `json:"groups"`
	// Filter workflows by versions
	Versions []string `json:"versions"`
	// Filter workflows from a specific cluster URL
	Cluster *string `json:"cluster"`
	// Filter workflows filer by pipelines
	Pipelines *NamespacedFindManyArgs `json:"pipelines"`
	// Filter workflows from a specific repositories
	Repositories []string `json:"repositories"`
	// Filter workflows from a specific branches
	Branches []string `json:"branches"`
	// Filter workflows from a specific event types
	EventTypes []string `json:"eventTypes"`
	// Filter workflows from a specific initiators
	Initiators []string `json:"initiators"`
	// Filter workflows from a specific statuses
	Statuses []WorkflowPhases `json:"statuses"`
	// Filter workflows from a specific start date
	StartDateFrom *string `json:"startDateFrom"`
	// Filter workflows to a specific start date
	StartDateTo *string `json:"startDateTo"`
	// Filter workflows by workflowTemplate
	WorkflowTemplate *string `json:"workflowTemplate"`
	// Filter workflows created by platform/app-proxy, the value should be the name of the flow that caused the creation
	OriginatedFrom []WorkflowOrigins `json:"originatedFrom"`
	// Filter workflows by workflowTemplate clusterScope
	WorkflowTemplateClusterScope *bool `json:"workflowTemplateClusterScope"`
}

// Access Mode
type AccessMode string

const (
	// standard installation using an ingress resource
	AccessModeIngress AccessMode = "INGRESS"
	// ingressless installation, using an FRP tunnel
	AccessModeTunnel AccessMode = "TUNNEL"
)

var AllAccessMode = []AccessMode{
	AccessModeIngress,
	AccessModeTunnel,
}

func (e AccessMode) IsValid() bool {
	switch e {
	case AccessModeIngress, AccessModeTunnel:
		return true
	}
	return false
}

func (e AccessMode) String() string {
	return string(e)
}

func (e *AccessMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessMode", str)
	}
	return nil
}

func (e AccessMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Analysis Metric Provider Types
type AnalysisMetricProviderTypes string

const (
	// CLOUD_WATCH
	AnalysisMetricProviderTypesCloudWatch AnalysisMetricProviderTypes = "CLOUD_WATCH"
	// DATADOG
	AnalysisMetricProviderTypesDatadog AnalysisMetricProviderTypes = "DATADOG"
	// JOB
	AnalysisMetricProviderTypesJob AnalysisMetricProviderTypes = "JOB"
	// KAYENTA
	AnalysisMetricProviderTypesKayenta AnalysisMetricProviderTypes = "KAYENTA"
	// NEW_RELIC
	AnalysisMetricProviderTypesNewRelic AnalysisMetricProviderTypes = "NEW_RELIC"
	// PROMETHEUS
	AnalysisMetricProviderTypesPrometheus AnalysisMetricProviderTypes = "PROMETHEUS"
	// UNKNOWN
	AnalysisMetricProviderTypesUnknown AnalysisMetricProviderTypes = "UNKNOWN"
	// WAVEFRONT
	AnalysisMetricProviderTypesWavefront AnalysisMetricProviderTypes = "WAVEFRONT"
	// WEB
	AnalysisMetricProviderTypesWeb AnalysisMetricProviderTypes = "WEB"
)

var AllAnalysisMetricProviderTypes = []AnalysisMetricProviderTypes{
	AnalysisMetricProviderTypesCloudWatch,
	AnalysisMetricProviderTypesDatadog,
	AnalysisMetricProviderTypesJob,
	AnalysisMetricProviderTypesKayenta,
	AnalysisMetricProviderTypesNewRelic,
	AnalysisMetricProviderTypesPrometheus,
	AnalysisMetricProviderTypesUnknown,
	AnalysisMetricProviderTypesWavefront,
	AnalysisMetricProviderTypesWeb,
}

func (e AnalysisMetricProviderTypes) IsValid() bool {
	switch e {
	case AnalysisMetricProviderTypesCloudWatch, AnalysisMetricProviderTypesDatadog, AnalysisMetricProviderTypesJob, AnalysisMetricProviderTypesKayenta, AnalysisMetricProviderTypesNewRelic, AnalysisMetricProviderTypesPrometheus, AnalysisMetricProviderTypesUnknown, AnalysisMetricProviderTypesWavefront, AnalysisMetricProviderTypesWeb:
		return true
	}
	return false
}

func (e AnalysisMetricProviderTypes) String() string {
	return string(e)
}

func (e *AnalysisMetricProviderTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnalysisMetricProviderTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnalysisMetricProviderTypes", str)
	}
	return nil
}

func (e AnalysisMetricProviderTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// AnalysisPhases
type AnalysisPhases string

const (
	// Error
	AnalysisPhasesError AnalysisPhases = "Error"
	// Failed
	AnalysisPhasesFailed AnalysisPhases = "Failed"
	// Inconclusive
	AnalysisPhasesInconclusive AnalysisPhases = "Inconclusive"
	// Pending
	AnalysisPhasesPending AnalysisPhases = "Pending"
	// Running
	AnalysisPhasesRunning AnalysisPhases = "Running"
	// Successful
	AnalysisPhasesSuccessful AnalysisPhases = "Successful"
)

var AllAnalysisPhases = []AnalysisPhases{
	AnalysisPhasesError,
	AnalysisPhasesFailed,
	AnalysisPhasesInconclusive,
	AnalysisPhasesPending,
	AnalysisPhasesRunning,
	AnalysisPhasesSuccessful,
}

func (e AnalysisPhases) IsValid() bool {
	switch e {
	case AnalysisPhasesError, AnalysisPhasesFailed, AnalysisPhasesInconclusive, AnalysisPhasesPending, AnalysisPhasesRunning, AnalysisPhasesSuccessful:
		return true
	}
	return false
}

func (e AnalysisPhases) String() string {
	return string(e)
}

func (e *AnalysisPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnalysisPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnalysisPhases", str)
	}
	return nil
}

func (e AnalysisPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Tree Sorting field
type ApplicationTreeSortingField string

const (
	// healthStatus
	ApplicationTreeSortingFieldHealthStatus ApplicationTreeSortingField = "healthStatus"
	// kind
	ApplicationTreeSortingFieldKind ApplicationTreeSortingField = "kind"
	// last deployment date
	ApplicationTreeSortingFieldLastUpdated ApplicationTreeSortingField = "lastUpdated"
	// name
	ApplicationTreeSortingFieldName ApplicationTreeSortingField = "name"
	// runtime
	ApplicationTreeSortingFieldRuntime ApplicationTreeSortingField = "runtime"
	// syncStatus
	ApplicationTreeSortingFieldSyncStatus ApplicationTreeSortingField = "syncStatus"
)

var AllApplicationTreeSortingField = []ApplicationTreeSortingField{
	ApplicationTreeSortingFieldHealthStatus,
	ApplicationTreeSortingFieldKind,
	ApplicationTreeSortingFieldLastUpdated,
	ApplicationTreeSortingFieldName,
	ApplicationTreeSortingFieldRuntime,
	ApplicationTreeSortingFieldSyncStatus,
}

func (e ApplicationTreeSortingField) IsValid() bool {
	switch e {
	case ApplicationTreeSortingFieldHealthStatus, ApplicationTreeSortingFieldKind, ApplicationTreeSortingFieldLastUpdated, ApplicationTreeSortingFieldName, ApplicationTreeSortingFieldRuntime, ApplicationTreeSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e ApplicationTreeSortingField) String() string {
	return string(e)
}

func (e *ApplicationTreeSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationTreeSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationTreeSortingField", str)
	}
	return nil
}

func (e ApplicationTreeSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ConnectionState contains information about remote resource connection state, currently used for clusters and repositories
type ClusterConnectionStatus string

const (
	// ConnectionStatusFailed indicates that a connection attempt has failed
	ClusterConnectionStatusFailed ClusterConnectionStatus = "Failed"
	// ConnectionStatusSuccessful indicates that a connection has been successfully established
	ClusterConnectionStatusSuccessful ClusterConnectionStatus = "Successful"
	// ConnectionStatusUnknown indicates that the connection status could not be reliably determined
	ClusterConnectionStatusUnknown ClusterConnectionStatus = "Unknown"
)

var AllClusterConnectionStatus = []ClusterConnectionStatus{
	ClusterConnectionStatusFailed,
	ClusterConnectionStatusSuccessful,
	ClusterConnectionStatusUnknown,
}

func (e ClusterConnectionStatus) IsValid() bool {
	switch e {
	case ClusterConnectionStatusFailed, ClusterConnectionStatusSuccessful, ClusterConnectionStatusUnknown:
		return true
	}
	return false
}

func (e ClusterConnectionStatus) String() string {
	return string(e)
}

func (e *ClusterConnectionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterConnectionStatus", str)
	}
	return nil
}

func (e ClusterConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Cluster connection status input
type ClusterConnectionStatusInput string

const (
	// Indicates that a connection attempt has failed
	ClusterConnectionStatusInputFailed ClusterConnectionStatusInput = "Failed"
	// Indicates that a connection has been successfully established
	ClusterConnectionStatusInputSuccessful ClusterConnectionStatusInput = "Successful"
	// Indicates that the connection status could not be reliably determined
	ClusterConnectionStatusInputUnknown ClusterConnectionStatusInput = "Unknown"
)

var AllClusterConnectionStatusInput = []ClusterConnectionStatusInput{
	ClusterConnectionStatusInputFailed,
	ClusterConnectionStatusInputSuccessful,
	ClusterConnectionStatusInputUnknown,
}

func (e ClusterConnectionStatusInput) IsValid() bool {
	switch e {
	case ClusterConnectionStatusInputFailed, ClusterConnectionStatusInputSuccessful, ClusterConnectionStatusInputUnknown:
		return true
	}
	return false
}

func (e ClusterConnectionStatusInput) String() string {
	return string(e)
}

func (e *ClusterConnectionStatusInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterConnectionStatusInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterConnectionStatusInput", str)
	}
	return nil
}

func (e ClusterConnectionStatusInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Deployment Statistics Status
type DeploymentStatisticsStatus string

const (
	DeploymentStatisticsStatusAll                 DeploymentStatisticsStatus = "ALL"
	DeploymentStatisticsStatusDegraded            DeploymentStatisticsStatus = "DEGRADED"
	DeploymentStatisticsStatusDegradedAndRollback DeploymentStatisticsStatus = "DEGRADED_AND_ROLLBACK"
	DeploymentStatisticsStatusHealthy             DeploymentStatisticsStatus = "HEALTHY"
	DeploymentStatisticsStatusRollback            DeploymentStatisticsStatus = "ROLLBACK"
)

var AllDeploymentStatisticsStatus = []DeploymentStatisticsStatus{
	DeploymentStatisticsStatusAll,
	DeploymentStatisticsStatusDegraded,
	DeploymentStatisticsStatusDegradedAndRollback,
	DeploymentStatisticsStatusHealthy,
	DeploymentStatisticsStatusRollback,
}

func (e DeploymentStatisticsStatus) IsValid() bool {
	switch e {
	case DeploymentStatisticsStatusAll, DeploymentStatisticsStatusDegraded, DeploymentStatisticsStatusDegradedAndRollback, DeploymentStatisticsStatusHealthy, DeploymentStatisticsStatusRollback:
		return true
	}
	return false
}

func (e DeploymentStatisticsStatus) String() string {
	return string(e)
}

func (e *DeploymentStatisticsStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentStatisticsStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentStatisticsStatus", str)
	}
	return nil
}

func (e DeploymentStatisticsStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// GitAuthMode
type GitAuthMode string

const (
	// CODEFRESH mode
	GitAuthModeCodefresh GitAuthMode = "CODEFRESH"
	// CUSTOM mode
	GitAuthModeCustom GitAuthMode = "CUSTOM"
	// PAT mode
	GitAuthModePat GitAuthMode = "PAT"
)

var AllGitAuthMode = []GitAuthMode{
	GitAuthModeCodefresh,
	GitAuthModeCustom,
	GitAuthModePat,
}

func (e GitAuthMode) IsValid() bool {
	switch e {
	case GitAuthModeCodefresh, GitAuthModeCustom, GitAuthModePat:
		return true
	}
	return false
}

func (e GitAuthMode) String() string {
	return string(e)
}

func (e *GitAuthMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitAuthMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitAuthMode", str)
	}
	return nil
}

func (e GitAuthMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Git providers
type GitProviders string

const (
	// Bitbucket cloud
	GitProvidersBitbucket GitProviders = "BITBUCKET"
	// Bitbucket server
	GitProvidersBitbucketServer GitProviders = "BITBUCKET_SERVER"
	// Github
	GitProvidersGithub GitProviders = "GITHUB"
	// Gitlab
	GitProvidersGitlab GitProviders = "GITLAB"
)

var AllGitProviders = []GitProviders{
	GitProvidersBitbucket,
	GitProvidersBitbucketServer,
	GitProvidersGithub,
	GitProvidersGitlab,
}

func (e GitProviders) IsValid() bool {
	switch e {
	case GitProvidersBitbucket, GitProvidersBitbucketServer, GitProvidersGithub, GitProvidersGitlab:
		return true
	}
	return false
}

func (e GitProviders) String() string {
	return string(e)
}

func (e *GitProviders) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitProviders(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitProviders", str)
	}
	return nil
}

func (e GitProviders) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Gitops Releases Sorting field
type GitopsReleasesSortingField string

const (
	// By health status
	GitopsReleasesSortingFieldHealthStatus GitopsReleasesSortingField = "healthStatus"
	// By history id (for chronological sorting)
	GitopsReleasesSortingFieldHistoryID GitopsReleasesSortingField = "historyId"
	// By sync status
	GitopsReleasesSortingFieldSyncStatus GitopsReleasesSortingField = "syncStatus"
)

var AllGitopsReleasesSortingField = []GitopsReleasesSortingField{
	GitopsReleasesSortingFieldHealthStatus,
	GitopsReleasesSortingFieldHistoryID,
	GitopsReleasesSortingFieldSyncStatus,
}

func (e GitopsReleasesSortingField) IsValid() bool {
	switch e {
	case GitopsReleasesSortingFieldHealthStatus, GitopsReleasesSortingFieldHistoryID, GitopsReleasesSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e GitopsReleasesSortingField) String() string {
	return string(e)
}

func (e *GitopsReleasesSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitopsReleasesSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitopsReleasesSortingField", str)
	}
	return nil
}

func (e GitopsReleasesSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Runtime Installation error
	HealthErrorCodesRuntimeInstallationError HealthErrorCodes = "RUNTIME_INSTALLATION_ERROR"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesRuntimeInstallationError,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesRuntimeInstallationError, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// CUSTOM status, used in case when resource update process was interrupted by new changes
	HealthStatusTerminated HealthStatus = "TERMINATED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusTerminated,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusTerminated, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image registry domain types
type ImageRegistryType string

const (
	// Docker hub
	ImageRegistryTypeDockerHub ImageRegistryType = "DOCKER_HUB"
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Ghcr
	ImageRegistryTypeGhcr ImageRegistryType = "GHCR"
	// Jfrog
	ImageRegistryTypeJfrog ImageRegistryType = "JFROG"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
	// Quay
	ImageRegistryTypeQuay ImageRegistryType = "QUAY"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeDockerHub,
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeGhcr,
	ImageRegistryTypeJfrog,
	ImageRegistryTypeOther,
	ImageRegistryTypeQuay,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeDockerHub, ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeGhcr, ImageRegistryTypeJfrog, ImageRegistryTypeOther, ImageRegistryTypeQuay:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Integration Category
type IntegrationCategory string

const (
	// Git
	IntegrationCategoryGit IntegrationCategory = "git"
	// Issue
	IntegrationCategoryIssue IntegrationCategory = "issue"
	// Registry
	IntegrationCategoryRegistry IntegrationCategory = "registry"
)

var AllIntegrationCategory = []IntegrationCategory{
	IntegrationCategoryGit,
	IntegrationCategoryIssue,
	IntegrationCategoryRegistry,
}

func (e IntegrationCategory) IsValid() bool {
	switch e {
	case IntegrationCategoryGit, IntegrationCategoryIssue, IntegrationCategoryRegistry:
		return true
	}
	return false
}

func (e IntegrationCategory) String() string {
	return string(e)
}

func (e *IntegrationCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationCategory", str)
	}
	return nil
}

func (e IntegrationCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification action type
type NotificationActionType string

const (
	// Add action
	NotificationActionTypeAdded NotificationActionType = "ADDED"
	// Remove action
	NotificationActionTypeRemoved NotificationActionType = "REMOVED"
	// Update action
	NotificationActionTypeUpdate NotificationActionType = "UPDATE"
)

var AllNotificationActionType = []NotificationActionType{
	NotificationActionTypeAdded,
	NotificationActionTypeRemoved,
	NotificationActionTypeUpdate,
}

func (e NotificationActionType) IsValid() bool {
	switch e {
	case NotificationActionTypeAdded, NotificationActionTypeRemoved, NotificationActionTypeUpdate:
		return true
	}
	return false
}

func (e NotificationActionType) String() string {
	return string(e)
}

func (e *NotificationActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationActionType", str)
	}
	return nil
}

func (e NotificationActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification State
type NotificationState string

const (
	// Failed state
	NotificationStateFailed NotificationState = "FAILED"
	// In progress state
	NotificationStateInProgress NotificationState = "IN_PROGRESS"
	// Success state
	NotificationStateSuccess NotificationState = "SUCCESS"
)

var AllNotificationState = []NotificationState{
	NotificationStateFailed,
	NotificationStateInProgress,
	NotificationStateSuccess,
}

func (e NotificationState) IsValid() bool {
	switch e {
	case NotificationStateFailed, NotificationStateInProgress, NotificationStateSuccess:
		return true
	}
	return false
}

func (e NotificationState) String() string {
	return string(e)
}

func (e *NotificationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationState", str)
	}
	return nil
}

func (e NotificationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification Type
type NotificationType string

const (
	// Event that are coming from argo cd
	NotificationTypeArgoCdEvent NotificationType = "ARGO_CD_EVENT"
	// Event that are coming from argo events
	NotificationTypeArgoEventsEvent NotificationType = "ARGO_EVENTS_EVENT"
	// Generic Event
	NotificationTypeGenericEvent NotificationType = "GENERIC_EVENT"
)

var AllNotificationType = []NotificationType{
	NotificationTypeArgoCdEvent,
	NotificationTypeArgoEventsEvent,
	NotificationTypeGenericEvent,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeArgoCdEvent, NotificationTypeArgoEventsEvent, NotificationTypeGenericEvent:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline statistics sort by measure
type PipelineStatisticsSortByMeasure string

const (
	PipelineStatisticsSortByMeasureAverageDuration PipelineStatisticsSortByMeasure = "AVERAGE_DURATION"
	PipelineStatisticsSortByMeasureExecutions      PipelineStatisticsSortByMeasure = "EXECUTIONS"
)

var AllPipelineStatisticsSortByMeasure = []PipelineStatisticsSortByMeasure{
	PipelineStatisticsSortByMeasureAverageDuration,
	PipelineStatisticsSortByMeasureExecutions,
}

func (e PipelineStatisticsSortByMeasure) IsValid() bool {
	switch e {
	case PipelineStatisticsSortByMeasureAverageDuration, PipelineStatisticsSortByMeasureExecutions:
		return true
	}
	return false
}

func (e PipelineStatisticsSortByMeasure) String() string {
	return string(e)
}

func (e *PipelineStatisticsSortByMeasure) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineStatisticsSortByMeasure(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineStatisticsSortByMeasure", str)
	}
	return nil
}

func (e PipelineStatisticsSortByMeasure) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ResourceOperation
type ResourceOperation string

const (
	// Create resources
	ResourceOperationCreate ResourceOperation = "CREATE"
	// Delete resources
	ResourceOperationDelete ResourceOperation = "DELETE"
	// Update resources
	ResourceOperationUpdate ResourceOperation = "UPDATE"
)

var AllResourceOperation = []ResourceOperation{
	ResourceOperationCreate,
	ResourceOperationDelete,
	ResourceOperationUpdate,
}

func (e ResourceOperation) IsValid() bool {
	switch e {
	case ResourceOperationCreate, ResourceOperationDelete, ResourceOperationUpdate:
		return true
	}
	return false
}

func (e ResourceOperation) String() string {
	return string(e)
}

func (e *ResourceOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceOperation", str)
	}
	return nil
}

func (e ResourceOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Phases
type RolloutPhases string

const (
	// Degraded
	RolloutPhasesDegraded RolloutPhases = "Degraded"
	// Healthy
	RolloutPhasesHealthy RolloutPhases = "Healthy"
	// Paused
	RolloutPhasesPaused RolloutPhases = "Paused"
	// Progressing
	RolloutPhasesProgressing RolloutPhases = "Progressing"
	// Terminated
	RolloutPhasesTerminated RolloutPhases = "Terminated"
	// Unknown
	RolloutPhasesUnknown RolloutPhases = "Unknown"
)

var AllRolloutPhases = []RolloutPhases{
	RolloutPhasesDegraded,
	RolloutPhasesHealthy,
	RolloutPhasesPaused,
	RolloutPhasesProgressing,
	RolloutPhasesTerminated,
	RolloutPhasesUnknown,
}

func (e RolloutPhases) IsValid() bool {
	switch e {
	case RolloutPhasesDegraded, RolloutPhasesHealthy, RolloutPhasesPaused, RolloutPhasesProgressing, RolloutPhasesTerminated, RolloutPhasesUnknown:
		return true
	}
	return false
}

func (e RolloutPhases) String() string {
	return string(e)
}

func (e *RolloutPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutPhases", str)
	}
	return nil
}

func (e RolloutPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Strategy Names
type RolloutStrategyNames string

const (
	// BlueGreen
	RolloutStrategyNamesBlueGreen RolloutStrategyNames = "blueGreen"
	// Canary
	RolloutStrategyNamesCanary RolloutStrategyNames = "canary"
)

var AllRolloutStrategyNames = []RolloutStrategyNames{
	RolloutStrategyNamesBlueGreen,
	RolloutStrategyNamesCanary,
}

func (e RolloutStrategyNames) IsValid() bool {
	switch e {
	case RolloutStrategyNamesBlueGreen, RolloutStrategyNamesCanary:
		return true
	}
	return false
}

func (e RolloutStrategyNames) String() string {
	return string(e)
}

func (e *RolloutStrategyNames) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStrategyNames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStrategyNames", str)
	}
	return nil
}

func (e RolloutStrategyNames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RuntimeOperationAction
type RuntimeOperationAction string

const (
	// Delete resources from runtime
	RuntimeOperationActionDelete RuntimeOperationAction = "DELETE"
	// Upsert resources to runtime
	RuntimeOperationActionUpsert RuntimeOperationAction = "UPSERT"
)

var AllRuntimeOperationAction = []RuntimeOperationAction{
	RuntimeOperationActionDelete,
	RuntimeOperationActionUpsert,
}

func (e RuntimeOperationAction) IsValid() bool {
	switch e {
	case RuntimeOperationActionDelete, RuntimeOperationActionUpsert:
		return true
	}
	return false
}

func (e RuntimeOperationAction) String() string {
	return string(e)
}

func (e *RuntimeOperationAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeOperationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeOperationAction", str)
	}
	return nil
}

func (e RuntimeOperationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Integration Entity Type
type SecretType string

const (
	// External Secret
	SecretTypeExternalSecret SecretType = "EXTERNAL_SECRET"
	// Sealed Secret
	SecretTypeSealedSecret SecretType = "SEALED_SECRET"
)

var AllSecretType = []SecretType{
	SecretTypeExternalSecret,
	SecretTypeSealedSecret,
}

func (e SecretType) IsValid() bool {
	switch e {
	case SecretTypeExternalSecret, SecretTypeSealedSecret:
		return true
	}
	return false
}

func (e SecretType) String() string {
	return string(e)
}

func (e *SecretType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecretType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecretType", str)
	}
	return nil
}

func (e SecretType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service Sorting field
type ServiceSortingField string

const (
	// Last Update
	ServiceSortingFieldLastUpdate ServiceSortingField = "lastUpdate"
	// Service Name
	ServiceSortingFieldServiceName ServiceSortingField = "serviceName"
)

var AllServiceSortingField = []ServiceSortingField{
	ServiceSortingFieldLastUpdate,
	ServiceSortingFieldServiceName,
}

func (e ServiceSortingField) IsValid() bool {
	switch e {
	case ServiceSortingFieldLastUpdate, ServiceSortingFieldServiceName:
		return true
	}
	return false
}

func (e ServiceSortingField) String() string {
	return string(e)
}

func (e *ServiceSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceSortingField", str)
	}
	return nil
}

func (e ServiceSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ServiceType
type ServiceType string

const (
	ServiceTypeClusterIP    ServiceType = "ClusterIP"
	ServiceTypeExternalName ServiceType = "ExternalName"
	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
	ServiceTypeNodePort     ServiceType = "NodePort"
)

var AllServiceType = []ServiceType{
	ServiceTypeClusterIP,
	ServiceTypeExternalName,
	ServiceTypeLoadBalancer,
	ServiceTypeNodePort,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeClusterIP, ServiceTypeExternalName, ServiceTypeLoadBalancer, ServiceTypeNodePort:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting order
type SortingOrder string

const (
	// ascending
	SortingOrderAsc SortingOrder = "asc"
	// descending
	SortingOrderDesc SortingOrder = "desc"
)

var AllSortingOrder = []SortingOrder{
	SortingOrderAsc,
	SortingOrderDesc,
}

func (e SortingOrder) IsValid() bool {
	switch e {
	case SortingOrderAsc, SortingOrderDesc:
		return true
	}
	return false
}

func (e SortingOrder) String() string {
	return string(e)
}

func (e *SortingOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingOrder", str)
	}
	return nil
}

func (e SortingOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Granularity options for statistics
type StatisticsGranularity string

const (
	StatisticsGranularityDay   StatisticsGranularity = "day"
	StatisticsGranularityMonth StatisticsGranularity = "month"
	StatisticsGranularityWeek  StatisticsGranularity = "week"
)

var AllStatisticsGranularity = []StatisticsGranularity{
	StatisticsGranularityDay,
	StatisticsGranularityMonth,
	StatisticsGranularityWeek,
}

func (e StatisticsGranularity) IsValid() bool {
	switch e {
	case StatisticsGranularityDay, StatisticsGranularityMonth, StatisticsGranularityWeek:
		return true
	}
	return false
}

func (e StatisticsGranularity) String() string {
	return string(e)
}

func (e *StatisticsGranularity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatisticsGranularity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatisticsGranularity", str)
	}
	return nil
}

func (e StatisticsGranularity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported CI Tools
type SupportedCITools string

const (
	// CLASSIC
	SupportedCIToolsClassic SupportedCITools = "classic"
	// GITHUB_ACTIONS
	SupportedCIToolsGithubActions SupportedCITools = "github_actions"
	// JENKINS
	SupportedCIToolsJenkins SupportedCITools = "jenkins"
)

var AllSupportedCITools = []SupportedCITools{
	SupportedCIToolsClassic,
	SupportedCIToolsGithubActions,
	SupportedCIToolsJenkins,
}

func (e SupportedCITools) IsValid() bool {
	switch e {
	case SupportedCIToolsClassic, SupportedCIToolsGithubActions, SupportedCIToolsJenkins:
		return true
	}
	return false
}

func (e SupportedCITools) String() string {
	return string(e)
}

func (e *SupportedCITools) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SupportedCITools(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SupportedCITools", str)
	}
	return nil
}

func (e SupportedCITools) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncResourceAction
type SyncActionOnResource string

const (
	// Configured / updated
	SyncActionOnResourceConfigured SyncActionOnResource = "Configured"
	// Created
	SyncActionOnResourceCreated SyncActionOnResource = "Created"
	// Pruned
	SyncActionOnResourcePruned SyncActionOnResource = "Pruned"
	// Prune Skipped
	SyncActionOnResourcePruneSkipped SyncActionOnResource = "PruneSkipped"
	// Unchanged
	SyncActionOnResourceUnchanged SyncActionOnResource = "Unchanged"
)

var AllSyncActionOnResource = []SyncActionOnResource{
	SyncActionOnResourceConfigured,
	SyncActionOnResourceCreated,
	SyncActionOnResourcePruned,
	SyncActionOnResourcePruneSkipped,
	SyncActionOnResourceUnchanged,
}

func (e SyncActionOnResource) IsValid() bool {
	switch e {
	case SyncActionOnResourceConfigured, SyncActionOnResourceCreated, SyncActionOnResourcePruned, SyncActionOnResourcePruneSkipped, SyncActionOnResourceUnchanged:
		return true
	}
	return false
}

func (e SyncActionOnResource) String() string {
	return string(e)
}

func (e *SyncActionOnResource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncActionOnResource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncActionOnResource", str)
	}
	return nil
}

func (e SyncActionOnResource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncHookType
type SyncHookType string

const (
	// PostSync
	SyncHookTypePostSync SyncHookType = "PostSync"
	// PreSync
	SyncHookTypePreSync SyncHookType = "PreSync"
	// Skip
	SyncHookTypeSkip SyncHookType = "Skip"
	// Sync
	SyncHookTypeSync SyncHookType = "Sync"
	// SyncFail
	SyncHookTypeSyncFail SyncHookType = "SyncFail"
)

var AllSyncHookType = []SyncHookType{
	SyncHookTypePostSync,
	SyncHookTypePreSync,
	SyncHookTypeSkip,
	SyncHookTypeSync,
	SyncHookTypeSyncFail,
}

func (e SyncHookType) IsValid() bool {
	switch e {
	case SyncHookTypePostSync, SyncHookTypePreSync, SyncHookTypeSkip, SyncHookTypeSync, SyncHookTypeSyncFail:
		return true
	}
	return false
}

func (e SyncHookType) String() string {
	return string(e)
}

func (e *SyncHookType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncHookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncHookType", str)
	}
	return nil
}

func (e SyncHookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncOperationPhase
type SyncOperationPhase string

const (
	// Error
	SyncOperationPhaseError SyncOperationPhase = "Error"
	// Failed
	SyncOperationPhaseFailed SyncOperationPhase = "Failed"
	// Running
	SyncOperationPhaseRunning SyncOperationPhase = "Running"
	// Succeeded
	SyncOperationPhaseSucceeded SyncOperationPhase = "Succeeded"
	// Terminating
	SyncOperationPhaseTerminating SyncOperationPhase = "Terminating"
	// Unknown
	SyncOperationPhaseUnknown SyncOperationPhase = "Unknown"
)

var AllSyncOperationPhase = []SyncOperationPhase{
	SyncOperationPhaseError,
	SyncOperationPhaseFailed,
	SyncOperationPhaseRunning,
	SyncOperationPhaseSucceeded,
	SyncOperationPhaseTerminating,
	SyncOperationPhaseUnknown,
}

func (e SyncOperationPhase) IsValid() bool {
	switch e {
	case SyncOperationPhaseError, SyncOperationPhaseFailed, SyncOperationPhaseRunning, SyncOperationPhaseSucceeded, SyncOperationPhaseTerminating, SyncOperationPhaseUnknown:
		return true
	}
	return false
}

func (e SyncOperationPhase) String() string {
	return string(e)
}

func (e *SyncOperationPhase) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncOperationPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncOperationPhase", str)
	}
	return nil
}

func (e SyncOperationPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncPhase
type SyncPhase string

const (
	// PostSync
	SyncPhasePostSync SyncPhase = "PostSync"
	// PreSync
	SyncPhasePreSync SyncPhase = "PreSync"
	// Sync
	SyncPhaseSync SyncPhase = "Sync"
	// SyncFail
	SyncPhaseSyncFail SyncPhase = "SyncFail"
)

var AllSyncPhase = []SyncPhase{
	SyncPhasePostSync,
	SyncPhasePreSync,
	SyncPhaseSync,
	SyncPhaseSyncFail,
}

func (e SyncPhase) IsValid() bool {
	switch e {
	case SyncPhasePostSync, SyncPhasePreSync, SyncPhaseSync, SyncPhaseSyncFail:
		return true
	}
	return false
}

func (e SyncPhase) String() string {
	return string(e)
}

func (e *SyncPhase) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncPhase", str)
	}
	return nil
}

func (e SyncPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncResultCode
type SyncResultCode string

const (
	// Pruned
	SyncResultCodePruned SyncResultCode = "Pruned"
	// PruneSkipped
	SyncResultCodePruneSkipped SyncResultCode = "PruneSkipped"
	// Synced
	SyncResultCodeSynced SyncResultCode = "Synced"
	// SyncFailed
	SyncResultCodeSyncFailed SyncResultCode = "SyncFailed"
)

var AllSyncResultCode = []SyncResultCode{
	SyncResultCodePruned,
	SyncResultCodePruneSkipped,
	SyncResultCodeSynced,
	SyncResultCodeSyncFailed,
}

func (e SyncResultCode) IsValid() bool {
	switch e {
	case SyncResultCodePruned, SyncResultCodePruneSkipped, SyncResultCodeSynced, SyncResultCodeSyncFailed:
		return true
	}
	return false
}

func (e SyncResultCode) String() string {
	return string(e)
}

func (e *SyncResultCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncResultCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncResultCode", str)
	}
	return nil
}

func (e SyncResultCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync success/failure
type SyncSuccess string

const (
	// FAILURE - when SyncStatus is OUT_OF_SYNC or UNKNOWN
	SyncSuccessFailure SyncSuccess = "FAILURE"
	// SUCCESS - when SyncStatus is SYNCED
	SyncSuccessSuccess SyncSuccess = "SUCCESS"
)

var AllSyncSuccess = []SyncSuccess{
	SyncSuccessFailure,
	SyncSuccessSuccess,
}

func (e SyncSuccess) IsValid() bool {
	switch e {
	case SyncSuccessFailure, SyncSuccessSuccess:
		return true
	}
	return false
}

func (e SyncSuccess) String() string {
	return string(e)
}

func (e *SyncSuccess) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncSuccess(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncSuccess", str)
	}
	return nil
}

func (e SyncSuccess) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Name of the flows that can be the workflow origins
type WorkflowOrigins string

const (
	// workflow was created as a result of image reporting/enrichment by unknown source
	WorkflowOriginsCiEnrichment WorkflowOrigins = "CI_ENRICHMENT"
	// workflow was created as a result of image reporting/enrichment by github-action plugin
	WorkflowOriginsCiEnrichmentCodefreshClassic WorkflowOrigins = "CI_ENRICHMENT_CODEFRESH_CLASSIC"
	// workflow was created as a result of image reporting/enrichment by github-action plugin
	WorkflowOriginsCiEnrichmentGa WorkflowOrigins = "CI_ENRICHMENT_GA"
	// workflow was created as a result of image reporting/enrichment by jenkins plugin
	WorkflowOriginsCiEnrichmentJenkins WorkflowOrigins = "CI_ENRICHMENT_JENKINS"
	// workflow without specific origin, regular pipeline workflow
	WorkflowOriginsCommon WorkflowOrigins = "COMMON"
	// workflow was create as a result of running the workflow template
	WorkflowOriginsPlayground WorkflowOrigins = "PLAYGROUND"
)

var AllWorkflowOrigins = []WorkflowOrigins{
	WorkflowOriginsCiEnrichment,
	WorkflowOriginsCiEnrichmentCodefreshClassic,
	WorkflowOriginsCiEnrichmentGa,
	WorkflowOriginsCiEnrichmentJenkins,
	WorkflowOriginsCommon,
	WorkflowOriginsPlayground,
}

func (e WorkflowOrigins) IsValid() bool {
	switch e {
	case WorkflowOriginsCiEnrichment, WorkflowOriginsCiEnrichmentCodefreshClassic, WorkflowOriginsCiEnrichmentGa, WorkflowOriginsCiEnrichmentJenkins, WorkflowOriginsCommon, WorkflowOriginsPlayground:
		return true
	}
	return false
}

func (e WorkflowOrigins) String() string {
	return string(e)
}

func (e *WorkflowOrigins) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowOrigins(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowOrigins", str)
	}
	return nil
}

func (e WorkflowOrigins) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
	// Unknown
	WorkflowPhasesUnknown WorkflowPhases = "Unknown"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
	WorkflowPhasesUnknown,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded, WorkflowPhasesUnknown:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

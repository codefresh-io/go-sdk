// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Application tree item might be Application or ApplicationSet
type ApplicationTreeItem interface {
	IsApplicationTreeItem()
}

// ArgoCD Notification
type ArgoCDNotification interface {
	IsArgoCDNotification()
}

// ArgoEvents Notification
type ArgoEventsNotification interface {
	IsArgoEventsNotification()
}

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// Favorable
type Favorable interface {
	IsFavorable()
}

// Notification That is part of a process
type GitOpsNotification interface {
	IsGitOpsNotification()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	IsGitopsEntity()
}

// IDP Entity
type IDP interface {
	IsIDP()
}

// Base integration type
type Integration interface {
	IsIntegration()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Notification Base type
type Notification interface {
	IsNotification()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations"`
	// Users that are attached to this account
	Users []*User `json:"users"`
	// Ids of all users that have account admin premission to this account
	Admins []string `json:"admins"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
	// Account security
	Security *SecurityInfo `json:"security"`
	// Collaborators
	Collaborators *AccountCollaborators `json:"collaborators"`
	// Private account owner
	PrivateAccountOwner *string `json:"privateAccountOwner"`
}

// AccountCollaborators
type AccountCollaborators struct {
	// Limit
	Limit *int `json:"limit"`
	// Used
	Used *int `json:"used"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle"`
	// Add ability to create/edit pipeline from UI in the configuration tab
	CreatePipelineArguments *bool `json:"createPipelineArguments"`
	// Application Dasboard CSDP
	ApplicationDashboard *bool `json:"applicationDashboard"`
	// Show CSDP runtime resources in applications list
	ShowCSDPRuntimeResources *bool `json:"showCSDPRuntimeResources"`
	// Shows button that links to classic codefresh
	ShowClassicCodefreshButton *bool `json:"showClassicCodefreshButton"`
}

// Git integration creation args
type AddGitIntegrationArgs struct {
	// Git integration name
	Name *string `json:"name"`
	// Git provider
	Provider GitProviders `json:"provider"`
	// The address of the git provider api
	APIURL string `json:"apiUrl"`
	// Sharing policy
	SharingPolicy SharingPolicy `json:"sharingPolicy"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
}

// Annotation
type Annotation struct {
	// Annotation type
	Type *string `json:"type"`
	// Annotation value
	Value *string `json:"value"`
	// Annotation accountId
	AccountID *string `json:"accountId"`
	// Annotation entityId
	EntityID *string `json:"entityId"`
	// Annotation entityType
	EntityType *string `json:"entityType"`
	// Annotation key
	Key *string `json:"key"`
}

// Args to set annotation for entity
type AnnotationArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
	// Event-source issueValue
	IssueValue *IssueValue `json:"issueValue"`
	// Event-source pullRequestValue
	PullRequestValue *PullRequestValue `json:"pullRequestValue"`
}

// Application Edge
type AnnotationEdge struct {
	// Node contains the actual application data
	Node *Annotation `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter annotation
type AnnotationFilterArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
}

// Annotation Slice
type AnnotationSlice struct {
	// Annotation edges
	Edges []*AnnotationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token"`
}

// App Proxy version information
type AppProxyVersionInfo struct {
	// The version of the app-proxy
	Version string `json:"version"`
	// The address of the platform the app-proxy is working with
	PlatformHost string `json:"platformHost"`
	// The version of the platform this app-proxy was built against
	PlatformVersion string `json:"platformVersion"`
}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Number of resources
	Size *int `json:"size"`
	// Revision
	Revision *string `json:"revision"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Favorites
	Favorites []string `json:"favorites"`
	// Argo CD application destination config
	Destination *ArgoCDApplicationDestination `json:"destination"`
}

func (Application) IsApplicationTreeItem() {}
func (Application) IsGitopsEntity()        {}
func (Application) IsBaseEntity()          {}
func (Application) IsProjectBasedEntity()  {}
func (Application) IsFavorable()           {}
func (Application) IsEntity()              {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

// ApplicationField Entity
type ApplicationField struct {
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Issues
	Issues []*Annotation `json:"issues"`
	// PullRequest
	Prs []*Annotation `json:"prs"`
	// Committers
	Committers []*CommitterLabel `json:"committers"`
	// Build
	Builds []*Build `json:"builds"`
}

// Application ref
type ApplicationRef struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Is reference was cut during tree normalizing
	IsReferenceCut *bool `json:"isReferenceCut"`
}

// ApplicationSet entity
type ApplicationSet struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Revision
	Revision *string `json:"revision"`
	// Number of resources
	Size *int `json:"size"`
	// Favorites
	Favorites []string `json:"favorites"`
}

func (ApplicationSet) IsBaseEntity()          {}
func (ApplicationSet) IsProjectBasedEntity()  {}
func (ApplicationSet) IsFavorable()           {}
func (ApplicationSet) IsApplicationTreeItem() {}
func (ApplicationSet) IsEntity()              {}

// Application Set Edge
type ApplicationSetEdge struct {
	// Node contains the actual application set data
	Node *ApplicationSet `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationSetEdge) IsEdge() {}

// ApplicationSet Slice
type ApplicationSetSlice struct {
	// Application edges
	Edges []*ApplicationSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSetSlice) IsSlice() {}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Application relations
type AppsRelations struct {
	// Entities referencing this entity
	ReferencedBy []*ApplicationRef `json:"referencedBy"`
	// Entities referenced by this enitity
	References []*ApplicationRef `json:"references"`
}

// Argo CD Application destination config
type ArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name"`
	// Cluster url
	Server *string `json:"server"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Revision
	Revision string `json:"revision"`
	// Version
	Version string `json:"version"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor"`
	// CommitAvatar
	CommitAvatar *string `json:"commitAvatar"`
	// CommitUrl
	CommitURL *string `json:"commitUrl"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage"`
	// CommitDate
	CommitDate *string `json:"commitDate"`
}

// Argo Hub Template
type ArgoHubTemplate struct {
	// Version
	ID *string `json:"id"`
	// Manifest
	Manifest *string `json:"manifest"`
	// Manifest url
	ManifestURL *string `json:"manifestUrl"`
	// Description
	Description *string `json:"description"`
	// Categories
	Categories []*string `json:"categories"`
}

// Argo Hub Templates
type ArgoHubTemplates struct {
	// Starter template name
	Data []*ArgoHubTemplatesSlice `json:"data"`
}

// Argo Hub templates filter arguments
type ArgoHubTemplatesFilterArgs struct {
	// Filter Argo Hub Templates by category
	Category *string `json:"category"`
	// Filter Argo Hub Templates by name
	Name *string `json:"name"`
}

// Argo Hub Templates Slice
type ArgoHubTemplatesSlice struct {
	// Template name
	Name *string `json:"name"`
	// Versions
	Versions []*ArgoHubTemplate `json:"versions"`
	// Latest version
	LatestVersion *ArgoHubTemplate `json:"latestVersion"`
}

// Auth0SSO
type Auth0sso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Client host
	ClientHost *string `json:"clientHost"`
}

func (Auth0sso) IsIDP() {}

// AzureSSO
type AzureSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// Tenant
	Tenant *string `json:"tenant"`
	// Object Id in Azure
	AppID *string `json:"appId"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Cookie key
	CookieKey *string `json:"cookieKey"`
	// Cookie iv
	CookieIv *string `json:"cookieIv"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
}

func (AzureSso) IsIDP() {}

// BasePrice
type BasePrice struct {
	// Month
	Month *int `json:"month"`
	// Year
	Year *int `json:"year"`
}

// Build Entity
type Build struct {
	// Build Id
	ID string `json:"id"`
	// PipelineRef
	Pipeline *PipelineRef `json:"pipeline"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// TBD
	Schedule string `json:"schedule"`
	// TBD
	Interval string `json:"interval"`
	// TBD
	Timezone string `json:"timezone"`
	// TBD
	Metadata string `json:"metadata"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// Calenar source arguments
type CalendarSourceArgs struct {
	// Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron
	Schedule string `json:"schedule"`
	// Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h…
	Interval string `json:"interval"`
	// Exclusion dates for running job
	ExclusionDates []*string `json:"exclusionDates"`
	// Timezone in which to run the schedule
	Timezone *string `json:"timezone"`
}

// ChildApplicationField Entity
type ChildApplicationField struct {
	// Name
	Name string `json:"name"`
	// Repo
	Repo *string `json:"repo"`
	// Cluster
	Cluster *string `json:"cluster"`
	// Status
	Status *SyncStatus `json:"status"`
}

// ClientIP
type ClientIP struct {
	// TimeoutSeconds
	TimeoutSeconds *int `json:"timeoutSeconds"`
}

// Commit
type Commit struct {
	// Commit sha
	Sha string `json:"sha"`
	// Committer
	Committer *Committer `json:"committer"`
}

// Commit files to a git repository args
type CommitFilesArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// Branch name
	BranchName string `json:"branchName"`
	// Repository full name in format {owner}/{name}
	Repo string `json:"repo"`
	// Files to commit
	Files []*File `json:"files"`
	// Commit messege
	Msg *string `json:"msg"`
	// Description messege
	Description *string `json:"description"`
}

// Git committer profile
type Committer struct {
	// Committer name
	Name string `json:"name"`
	// Committer email
	Email *string `json:"email"`
	// Committer avatar url
	AvatarURL *string `json:"avatarUrl"`
	// Committer page url
	ProfileURL *string `json:"profileUrl"`
}

// Committer Label
type CommitterLabel struct {
	// UserName
	UserName string `json:"userName"`
	// Avatar
	Avatar *string `json:"avatar"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the component
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity()         {}
func (Component) IsK8sLogicEntity()     {}
func (Component) IsProjectBasedEntity() {}
func (Component) IsEntity()             {}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// Component Notification
type ComponentNotification struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (ComponentNotification) IsNotification()       {}
func (ComponentNotification) IsArgoCDNotification() {}
func (ComponentNotification) IsGitOpsNotification() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Composite Slice
type CompositeSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo []*CompositeSliceInfo `json:"pageInfo"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Infomration about a slice of a specific kind
type CompositeSliceInfo struct {
	// Key of the slice
	Key string `json:"key"`
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
}

// Pagination arguments to request kind-slice
type CompositeSlicePaginationArgs struct {
	// References a specific key
	Key string `json:"key"`
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Pipeline creation arguments
type CreatePipelineArgs struct {
	// Sensor name
	SensorName string `json:"sensorName"`
	// Trigger name
	TriggerName string `json:"triggerName"`
	// Source arguments
	SourcesArgs *SourceArgs `json:"sourcesArgs"`
	// Workflow template arguments
	WorkflowTemplateArgs *WorkflowTemplateArgs `json:"workflowTemplateArgs"`
}

// Custom Date filter
type CustomDataFilter struct {
	// Path is the JSONPath of the event’s (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters and ‘?’. To access an array value use the index as the key. The dot and wildcard characters can be escaped with ‘’. See https://github.com/tidwall/gjson#path-syntax for more information on how to use this. in addition you can pass a predefined varibles as the following ${{ VAR }} - assuming VAR is predefiend varaible
	Path string `json:"path"`
	// Type contains the JSON type of the data
	Type JSONTypes `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
	// Comparator compares the event data with a user given value. if left blank treated as equality
	Comparator *Comparator `json:"comparator"`
	// Template is a go-template for extracting a string from the event’s data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig’s extra functions. See https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/
	Template *string `json:"template"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilter struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilterArgs struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// Date filters
type DataFilterOld struct {
	// Filters from pre defined list
	PredefinedDataFilter *PredefinedDataFilter `json:"predefinedDataFilter"`
	// Custom filters
	CustomDataFilter *CustomDataFilter `json:"customDataFilter"`
}

// DataRetention
type DataRetention struct {
	// Weeks
	Weeks *int `json:"weeks"`
}

// DefaultDindResources
type DefaultDindResources struct {
	// Requests
	Requests *ResourcesRequests `json:"requests"`
}

// Delete files from a git repository args
type DeleteFilesArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// Branch name
	BranchName string `json:"branchName"`
	// Repository name in format {owner}/{name}
	Repo string `json:"repo"`
	// File paths to delete
	Paths []string `json:"paths"`
	// Commit messege
	Msg *string `json:"msg"`
	// Description messege
	Description *string `json:"description"`
}

// Deployment entity
type Deployment struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Deployment Entity
	Spec *DeploymentSpec `json:"spec"`
	// Deployment Status
	Status *DeploymentStatus `json:"status"`
}

func (Deployment) IsGitopsEntity()       {}
func (Deployment) IsBaseEntity()         {}
func (Deployment) IsProjectBasedEntity() {}
func (Deployment) IsEntity()             {}

// Container
type DeploymentContainer struct {
	// Containers
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// ImagePullPolicy
	ImagePullPolicy *ImagePullPolicy `json:"imagePullPolicy"`
}

// Deployment Edge
type DeploymentEdge struct {
	// Node contains the actual Deployment data
	Node *Deployment `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (DeploymentEdge) IsEdge() {}

// Deployment Slice
type DeploymentSlice struct {
	// Deployment edges
	Edges []*DeploymentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (DeploymentSlice) IsSlice() {}

// Deployment Spec
type DeploymentSpec struct {
	// Template
	Template *PodTemplateSpec `json:"template"`
	// Replicas
	Replicas *int `json:"replicas"`
}

// DeploymentSpecPart
type DeploymentSpecPart struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Status
	Status *DeploymentStatus `json:"status"`
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// Deployment Status
type DeploymentStatus struct {
	// Replicas
	Replicas *int `json:"replicas"`
	// AvailableReplicas
	AvailableReplicas *int `json:"availableReplicas"`
	// ReadyReplicas
	ReadyReplicas *int `json:"readyReplicas"`
	// UnavailableReplicas
	UnavailableReplicas *int `json:"unavailableReplicas"`
	// UpdatedReplicas
	UpdatedReplicas *int `json:"updatedReplicas"`
}

// Git integration edit args
type EditGitIntegrationArgs struct {
	// Git integration name
	Name *string `json:"name"`
	// The address of the git provider api
	APIURL string `json:"apiUrl"`
	// Sharing policy
	SharingPolicy SharingPolicy `json:"sharingPolicy"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

// EnvironmentConcurrency
type EnvironmentConcurrency struct {
	// Price
	Price *BasePrice `json:"price"`
	// Amount
	Amount *int `json:"amount"`
	// Min
	Min *int `json:"min"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
	// Commit url with file
	FileURL *string `json:"fileUrl"`
}

// Event dependency filter
type EventDependencyFilter struct {
	// Data filter constraints with escalation
	Data []*DataFilterOld `json:"data"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid"`
	// Content of the event
	Data *string `json:"data"`
	// Time
	Time *string `json:"time"`
	// Event source
	EventSource *EventSource `json:"eventSource"`
	// Event name
	EventName *string `json:"eventName"`
	// Event type
	EventType *string `json:"eventType"`
	// Account
	Account *string `json:"account"`
	// Runtime
	Runtime *string `json:"runtime"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the event-source
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (EventSource) IsBaseEntity()         {}
func (EventSource) IsGitopsEntity()       {}
func (EventSource) IsProjectBasedEntity() {}
func (EventSource) IsEntity()             {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Event source type
type EventSourceType struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// List of the supported events by this event source type. CAP know how to filter this kind of events.
	Events []*SupportedEventMapping `json:"events"`
}

// Args to set favorite for entity
type FavoriteInfoArgs struct {
	// Event-source kind
	Kind string `json:"kind"`
	// Event-source group
	Group string `json:"group"`
	// Event-source group
	Version string `json:"version"`
	// Event-source runtime name
	Runtime string `json:"runtime"`
	// Event-source name
	Name string `json:"name"`
	// Event-source namespace
	Namespace *string `json:"namespace"`
}

// File
type File struct {
	// File full path
	Path string `json:"path"`
	// File revision
	Revision *string `json:"revision"`
	// File data
	Data string `json:"data"`
}

// From State Entity
type FromState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

type GeneratedManifest struct {
	// Generated manifests to commit
	Manifest string `json:"manifest"`
	// File name to store the manifest
	Filename string `json:"filename"`
	// Kind of the k8s resource
	Kind string `json:"kind"`
}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (GenericEntity) IsGitopsEntity()       {}
func (GenericEntity) IsBaseEntity()         {}
func (GenericEntity) IsProjectBasedEntity() {}
func (GenericEntity) IsEntity()             {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// Argo events generic Error Notification
type GenericErrorNotification struct {
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Notification type
	Type *string `json:"type"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
}

func (GenericErrorNotification) IsNotification()           {}
func (GenericErrorNotification) IsArgoEventsNotification() {}

// Git integration
type GitIntegration struct {
	// Git integration name
	Name string `json:"name"`
	// Sharing policy
	SharingPolicy SharingPolicy `json:"sharingPolicy"`
	// Git provider
	Provider GitProviders `json:"provider"`
	// The address of the git provider api
	APIURL string `json:"apiUrl"`
	// List of user ids that registered themselves to this git integration
	RegisteredUsers []string `json:"registeredUsers"`
}

func (GitIntegration) IsIntegration() {}

// GitOps Edge
type GitOpsEdge struct {
	// Node contains the actual component data
	Node GitopsEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// GitOps Slice
type GitOpsSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork"`
	// PR comment
	Comment *GitPRComment `json:"comment"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// PR data
	Pr *GitPr `json:"pr"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPREventPayloadData) IsEventPayloadData()          {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *WorkflowRepository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha"`
	// SHA URL
	ShaURL *string `json:"shaURL"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPushEventPayloadData) IsEventPayloadData()          {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Release data
	Release *GitRelease `json:"release"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitReleaseEventPayloadData) IsEventPayloadData()          {}

// Git Repositories Args
type GitRepositoriesArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// If empty will return first page
	Page *int `json:"page"`
	// Default 100, max 200 results per page
	Limit *int `json:"limit"`
}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the GitSource
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Permissions to this git source
	Permissions []*Permission `json:"permissions"`
}

func (GitSource) IsK8sLogicEntity()     {}
func (GitSource) IsBaseEntity()         {}
func (GitSource) IsProjectBasedEntity() {}
func (GitSource) IsEntity()             {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git Source Notification
type GitSourceNotification struct {
	// Commit information that triggered sync
	Source *GitopsEntitySource `json:"source"`
	// Link to the git-source in git provider
	GsRepoLink *string `json:"gsRepoLink"`
	// Sync status
	GsSyncStatus SyncStatus `json:"gsSyncStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (GitSourceNotification) IsNotification()       {}
func (GitSourceNotification) IsArgoCDNotification() {}
func (GitSourceNotification) IsGitOpsNotification() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitUnknownEventPayloadData) IsEventPayloadData()          {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Events
type GithubEventArgs struct {
	Action     string                   `json:"action"`
	Filters    []*EventDependencyFilter `json:"filters"`
	Parameters []*TriggerParameter      `json:"parameters"`
}

// Github source arguments
type GithubSourceArgs struct {
	Repository string             `json:"repository"`
	Events     []*GithubEventArgs `json:"events"`
}

// Github trigger conditions
type GithubTriggerConditions struct {
	// Specific github event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backvard converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backvard converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backvard converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []*string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Github trigger conditions
type GithubTriggerConditionsArgs struct {
	// Specific github event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backvard converting from trigger conditions)
	EventSource *string `json:"eventSource"`
	// EventSource event name (for backvard converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent"`
	// Dependency name (for backvard converting from trigger conditions)
	Dependency *string `json:"dependency"`
	// Repositories
	Repositories []*string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource"`
	// Repo URL
	RepoURL *string `json:"repoURL"`
	// Path
	Path *string `json:"path"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL"`
	// Git revision
	Revision *string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit web url
	CommitURL *string `json:"commitURL"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Author web profile url
	ProfileURL *string `json:"profileURL"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL"`
	// Git manifest
	GitManifest *string `json:"gitManifest"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction"`
}

// Gitops Release Entity
type GitopsRelease struct {
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
	// History id
	HistoryID int `json:"historyId"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
}

// Args to define application
type GitopsReleaseApplicationArgs struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace string `json:"namespace"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
	// Kind
	Kind *string `json:"kind"`
}

// Gitops Release chart record
type GitopsReleaseChartRecord struct {
	// Date
	Date string `json:"date"`
	// Date
	Releases []*GitopsReleaseChartRelease `json:"releases"`
}

// Gitops Release chart release
type GitopsReleaseChartRelease struct {
	// Date
	SyncStartedAt *string `json:"syncStartedAt"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// History id
	HistoryID int `json:"historyId"`
}

// Release Edge
type GitopsReleaseEdge struct {
	// Node contains the actual application data
	Node *GitopsRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter release
type GitopsReleaseFilterArgs struct {
	// Runtime
	Runtime *string `json:"runtime"`
	// Name
	Name *string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
	// Kind
	Kind *string `json:"kind"`
	// HistoryId
	HistoryID *int `json:"historyId"`
	// Issue key
	IssueKey *string `json:"issueKey"`
	// PR key
	PrKey *string `json:"prKey"`
	// Committer
	Committer *string `json:"committer"`
	// Issue key array
	IssueKeys []*string `json:"issueKeys"`
	// PR key array
	PrKeys []*string `json:"prKeys"`
	// Committers array
	Committers []*string `json:"committers"`
	// Filter workflows from a specific start date
	SyncStartDateFrom *string `json:"syncStartDateFrom"`
	// Filter workflows to a specific start date
	SyncStartDateTo *string `json:"syncStartDateTo"`
	// Start date
	StartDate *string `json:"startDate"`
	// End date
	EndDate *string `json:"endDate"`
}

// Gitops Release Slice
type GitopsReleaseSlice struct {
	// Release edges
	Edges []*GitopsReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// GoogleSSO
type GoogleSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// ClientHost
	ClientHost *string `json:"clientHost"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Keyfile
	Keyfile *string `json:"keyfile"`
	// Subject
	Subject *string `json:"subject"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
	// SyncField
	SyncField *string `json:"syncField"`
}

func (GoogleSso) IsIDP() {}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// Health Error Input
type HealthErrorInput struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Message
	Message string `json:"message"`
}

// Workflow template ref Hierarchy
type HierarchyRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Ref line number
	Line *int `json:"line"`
}

// WorkflowTemplate Hierarchy Step
type HierarchyStep struct {
	// Step name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line"`
}

// WorkflowTemplate Steps Template
type HierarchyTemplate struct {
	// Template name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line"`
	// Steps
	Steps []*HierarchyStep `json:"steps"`
}

// WorkflowTemplate templates hierarchy
type HierarchyTemplates struct {
	// WorkflowTemlate name
	Name *string `json:"name"`
	// WorkflowTemlate name line number
	Line *int `json:"line"`
	// WorkflowTemplate templates structer heiarchy
	Steps []*HierarchyTemplate `json:"steps"`
	// WorkflowTemplate templates structer heiarchy
	Refs []*HierarchyRef `json:"refs"`
}

// Image application
type ImageApplication struct {
	// Application Ref metadata
	ApplicationRef *ObjectMeta `json:"applicationRef"`
	// Application git info
	ApplicationGitInfo *ImageApplicationGitInfo `json:"applicationGitInfo"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Related binary
	Binary *ImageBinary `json:"binary"`
	// Currently deployed
	CurrentlyDeployed bool `json:"currentlyDeployed"`
}

//  Application Commit Author
type ImageApplicationCommitAuthor struct {
	// Username
	Username *string `json:"username"`
	// Profile Url
	ProfileURL *string `json:"profileUrl"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl"`
}

// Image Application Git Info
type ImageApplicationGitInfo struct {
	// Git repo url
	RepoURL *string `json:"repoURL"`
	// Git branch
	Branch *string `json:"branch"`
	// Commit author
	Author *ImageApplicationCommitAuthor `json:"author"`
	// Commit message
	CommitMessage *string `json:"commitMessage"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
}

// Image binary entity
type ImageBinary struct {
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// ImageName
	ImageName string `json:"imageName"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Branch
	Branch *string `json:"branch"`
	// Commit
	Commit *string `json:"commit"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg"`
	// CommitURL
	CommitURL *string `json:"commitURL"`
	// Git repository
	GitRepository *string `json:"gitRepository"`
	//  AccountId
	AccountID string `json:"accountId"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	// Size
	Size *int `json:"size"`
	// OS
	Os *string `json:"os"`
	// Architecture
	Architecture *string `json:"architecture"`
	// Info
	Info *string `json:"info"`
	// Author
	Author *ImageBinaryAuthor `json:"author"`
	//  Workflow name
	WorkflowName *string `json:"workflowName"`
	// Image registry
	ImageRegistryDomains []*ImageRegistryType `json:"imageRegistryDomains"`
}

func (ImageBinary) IsEntity() {}

//  ImageBinaryAuthor
type ImageBinaryAuthor struct {
	// Username
	Username *string `json:"username"`
	// Full name
	FullName *string `json:"fullName"`
	// Profile Url
	ProfileURL *string `json:"profileUrl"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl"`
}

//  ImageBinaryAuthorOutput
type ImageBinaryAuthorOutput struct {
	// Username
	Username *string `json:"username"`
}

// Image Binary Edge
type ImageBinaryEdge struct {
	// Node contains the actual image binary data
	Node *ImageBinary `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageBinaryEdge) IsEdge() {}

//  ImageBinaryInput
type ImageBinaryOutput struct {
	//  Id
	ID string `json:"id"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
	//  Info
	Author *ImageBinaryAuthorOutput `json:"author"`
	//  Workflow name
	WorkflowName *string `json:"workflowName"`
}

// Images Binary Slice
type ImageBinarySlice struct {
	// Image edges
	Edges []*ImageBinaryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageBinarySlice) IsSlice() {}

// Image Registry entity
type ImageRegistry struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	//  AccountId
	AccountID string `json:"accountId"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTag `json:"tags"`
	// Registry
	Registry *Registry `json:"registry"`
}

func (ImageRegistry) IsEntity() {}

// Image Registry Edge
type ImageRegistryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRegistry `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRegistryEdge) IsEdge() {}

//  ImageRegistryInput
type ImageRegistryOutput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTagOutput `json:"tags"`
	// Registry
	Registry *RegistryOutput `json:"registry"`
}

// Images Registry Slice
type ImageRegistrySlice struct {
	// Image registry edges
	Edges []*ImageRegistryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRegistrySlice) IsSlice() {}

// Image Repo Tag entity
type ImageRepoTag struct {
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Created Date
	Created string `json:"created"`
	// Related binaries
	Binaries []*ImageBinary `json:"binaries"`
	// Image applications
	Applications []*ImageApplication `json:"applications"`
}

func (ImageRepoTag) IsEntity() {}

// Image repo tag Edge
type ImageRepoTagEdge struct {
	// Node contains the actual image repo tag data
	Node *ImageRepoTag `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepoTagEdge) IsEdge() {}

// Images repo tag Slice
type ImageRepoTagSlice struct {
	// Image Repository edges
	Edges []*ImageRepoTagEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepoTagSlice) IsSlice() {}

// Image Repository entity
type ImageRepository struct {
	// Image repository name
	Name string `json:"name"`
	// Account Id
	AccountID string `json:"accountId"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// Image repository registry domain types
	RegistryDomains []*ImageRegistryType `json:"registryDomains"`
	// Image applications
	Applications []*ImageApplication `json:"applications"`
}

func (ImageRepository) IsEntity() {}

// Image Repository Edge
type ImageRepositoryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRepository `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepositoryEdge) IsEdge() {}

// Images Repository Slice
type ImageRepositorySlice struct {
	// Image Repository edges
	Edges []*ImageRepositoryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepositorySlice) IsSlice() {}

// ImageTag
type ImageTag struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagOutput struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// Images Entity
type Images struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// RepositoryName
	RepositoryName *string `json:"repositoryName"`
	// BinaryId
	BinaryID *string `json:"binaryId"`
	// WorkflowName
	WorkflowName *string `json:"workflowName"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Issue value
type IssueValue struct {
	// Issue url
	URL string `json:"url"`
	// Issue title
	Title string `json:"title"`
	// Issue status
	Status string `json:"status"`
	// Issue avatar URL
	AvatarURL *string `json:"avatarURL"`
	// Issue assignee
	Assignee *string `json:"assignee"`
}

// K8s entity id
type K8sEntityID struct {
	// name
	Name string `json:"name"`
	// namespace
	Namespace *string `json:"namespace"`
}

// KeycloakSSO
type KeycloakSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Host
	Host *string `json:"host"`
	// Realm
	Realm *string `json:"realm"`
}

func (KeycloakSso) IsIDP() {}

// LdapSSO
type LdapSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Password
	Password *string `json:"password"`
	// URL
	URL *string `json:"url"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName"`
	// Search base
	SearchBase *string `json:"searchBase"`
	// Search filter
	SearchFilter *string `json:"searchFilter"`
	// Certificate
	Certificate *string `json:"certificate"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync"`
}

func (LdapSso) IsIDP() {}

// Logic entity id
type LogicEntityID struct {
	// id
	ID string `json:"id"`
}

// Mapping between the var name and the path to the value in event payload
type Mapping struct {
	// Name of the variable
	VarName string `json:"varName"`
	// Description of the variable
	Description string `json:"description"`
	// Path of variable value inside of event payload
	Path string `json:"path"`
	// Golang template with .Input argument that equals to the value from path
	Template string `json:"template"`
	// Indicates if the mapping should be used in filtering expressions. Some mappings can be useless for filtering, like GIT_REPO that will be the same for each event.
	Filter bool `json:"filter"`
}

// Pipeline metric with trend
type MetricWithTrend struct {
	// Metric value
	Value int `json:"value"`
	// Percent Diff between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName *string `json:"templateName"`
	// Node children
	Children []*string `json:"children"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Message
	Message *string `json:"message"`
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Inputs
	Inputs *string `json:"inputs"`
	// Outputs
	Outputs *string `json:"outputs"`
	// Script
	Script *string `json:"script"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id"`
	// Resources Duration
	ResourcesDuration *string `json:"resourcesDuration"`
	// Template Ref
	TemplateRef *string `json:"templateRef"`
	// Host node name
	HostNodeName *string `json:"hostNodeName"`
	// Template
	Template *string `json:"template"`
	// Template scope
	TemplateScope *string `json:"templateScope"`
}

// Notification Edge
type NotificationEdge struct {
	// Node contains the actual notification data
	Node Notification `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Notification Slice
type NotificationSlice struct {
	// Notification edges
	Edges []*NotificationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels"`
	// Annotations
	Annotations []*StringPair `json:"annotations"`
	// Last updated
	LastUpdated *string `json:"lastUpdated"`
	// Created
	Created *string `json:"created"`
	// K8s object uid
	UID *string `json:"uid"`
	// Favorite
	Favorite *bool `json:"favorite"`
}

// OktaSSO
type OktaSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Scopes
	Scopes []*string `json:"scopes"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// AutoGroupSync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// App Id
	AppID *string `json:"appId"`
}

func (OktaSso) IsIDP() {}

// OneloginSSO
type OneloginSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// API client id
	APIClientID *string `json:"apiClientId"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret"`
}

func (OneloginSso) IsIDP() {}

// Pack
type Pack struct {
	// Metadata
	Metadata *PackMetadata `json:"metadata"`
	// Workflows
	Workflows *WorkflowConcurrency `json:"workflows"`
	// Runtime
	Runtime *PackRuntime `json:"runtime"`
	// Id
	ID *string `json:"id"`
}

// PackMetadata
type PackMetadata struct {
	// Description
	Description *string `json:"description"`
	// Name
	Name *string `json:"name"`
}

// PackRuntime
type PackRuntime struct {
	// DefaultDindResources
	DefaultDindResources *DefaultDindResources `json:"defaultDindResources"`
	// Name
	Name *string `json:"name"`
	// OS
	Os *string `json:"os"`
	// Architecture
	Architecture *string `json:"architecture"`
	// CPU
	CPU *string `json:"cpu"`
	// Memory
	Memory *string `json:"memory"`
	// Storage
	Storage *string `json:"storage"`
	// DindStorage
	DindStorage *string `json:"dindStorage"`
}

// PastDue
type PastDue struct {
	// IsPastDue
	IsPastDue *bool `json:"isPastDue"`
	// ShowPastDueWarning
	ShowPastDueWarning *bool `json:"showPastDueWarning"`
}

// Permission model
type Permission struct {
	// The user with the permission
	User *User `json:"user"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Permission inoput
type PermissionInput struct {
	// The id of the user the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self"`
	// History of the pipeline
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity"`
}

func (Pipeline) IsBaseEntity()         {}
func (Pipeline) IsK8sLogicEntity()     {}
func (Pipeline) IsProjectBasedEntity() {}
func (Pipeline) IsEntity()             {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time"`
	// Committers
	Committers *int `json:"committers"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time"`
	// Executions
	Executions *int `json:"executions"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace string `json:"pipelineNamespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame"`
	// Success Rate stats
	SuccessRateStats *MetricWithTrend `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
}

// Pipeline Reference
type PipelineRef struct {
	// Id
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Project
	Project string `json:"project"`
	// ProjectId
	ProjectID string `json:"projectId"`
}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats"`
}

// Pipeline Step
type PipelineStepStatistics struct {
	// Step Name
	StepName *string `json:"stepName"`
	// Template Name
	TemplateName *string `json:"templateName"`
	// Workflow Template
	WorkflowTemplate *string `json:"workflowTemplate"`
	// Node Type
	NodeType *string `json:"nodeType"`
	// Step Average duration
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Step Executions count
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
	// Step Average CPU usage
	CPUStats *MetricWithTrend `json:"cpuStats"`
	// Step Average Memory
	MemoryStats *MetricWithTrend `json:"memoryStats"`
	// Step Errors count
	ErrorsCountStats *MetricWithTrend `json:"errorsCountStats"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time"`
	// Success rate
	SuccessRate *int `json:"successRate"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name"`
}

// Plan
type Plan struct {
	// Stripe
	Stripe *Stripe `json:"stripe"`
	// Trial
	Trial *Trial `json:"trial"`
	// BasePrice
	BasePrice *BasePrice `json:"basePrice"`
	// Workflows
	Workflows *PlanWorkflows `json:"workflows"`
	// Environments
	Environments *PlanEnvironment `json:"environments"`
	// DataRetention
	DataRetention *DataRetention `json:"dataRetention"`
	// Collaborators
	Collaborators *PlanCollaborators `json:"collaborators"`
	// PastDue
	PastDue *PastDue `json:"pastDue"`
	// NewPricingModel
	NewPricingModel *bool `json:"newPricingModel"`
	// Azure
	Azure *bool `json:"azure"`
	// Currency
	Currency *string `json:"currency"`
	// Default
	Default *bool `json:"default"`
	// Dedicated
	Dedicated *bool `json:"dedicated"`
	// PrivateRepo
	PrivateRepo *bool `json:"privateRepo"`
	// PaymentInterval
	PaymentInterval *string `json:"paymentInterval"`
	// IsWiredTransfer
	IsWiredTransfer *bool `json:"isWiredTransfer"`
	// Packs
	Packs []*Pack `json:"packs"`
	// TotalPrice
	TotalPrice *int `json:"totalPrice"`
	// DisplayName
	DisplayName *string `json:"displayName"`
	// Id
	ID *string `json:"id"`
	// DefaultPack
	DefaultPack *string `json:"defaultPack"`
	// Segment
	Segment *string `json:"segment"`
	// MRR
	Mrr *int `json:"mrr"`
	// ARR
	Arr *int `json:"arr"`
}

// PlanCollaborators
type PlanCollaborators struct {
	// Limit
	Limit *int `json:"limit"`
}

// PlanEnvironment
type PlanEnvironment struct {
	// Concurrency
	Concurrency *EnvironmentConcurrency `json:"concurrency"`
}

// PlanWorkflows
type PlanWorkflows struct {
	// Concurrency
	Concurrency *WorkflowConcurrency `json:"concurrency"`
}

// Pod Spec
type PodSpec struct {
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// PodTemplate Spec
type PodTemplateSpec struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Spec
	Spec *PodSpec `json:"spec"`
}

// Predefined Date filter
type PredefinedDataFilter struct {
	// Predefined variable key
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
	// Comparator compares the event data with a user given value. if left blank treated as equality
	Comparator *Comparator `json:"comparator"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilter struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilterArgs struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// PullRequestCommitter
type PullRequestCommitter struct {
	// userName
	UserName string `json:"userName"`
	// avatar
	Avatar string `json:"avatar"`
}

// PullRequest value
type PullRequestValue struct {
	// url
	URL string `json:"url"`
	// title
	Title string `json:"title"`
	// committers
	Committers []*PullRequestCommitter `json:"committers"`
}

// Read file from a git repository args
type ReadFileArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// Git reference name (branch/revision)
	Ref string `json:"ref"`
	// Repository full name in format {owner}/{name}
	Repo string `json:"repo"`
	// File full path
	Path string `json:"path"`
}

// Register to Git integration args
type RegisterToGitIntegrationArgs struct {
	// Git integration name, if not provided will use the default one
	Name *string `json:"name"`
	// Token
	Token string `json:"token"`
}

// Registry
type Registry struct {
	// Domain
	Domain string `json:"domain"`
	// Registry type
	Type ImageRegistryType `json:"type"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// Original Repository Prefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// RegistryInput
type RegistryOutput struct {
	// Id
	ID *string `json:"id"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// Release Entity - represents a Codefresh runtime release
type Release struct {
	// Release version
	Version string `json:"version"`
	// Has security vulnerabilities
	HasSecurityVulnerabilities *bool `json:"hasSecurityVulnerabilities"`
}

// Rollout Rollout State
type ReleaseRolloutState struct {
	// Name
	Name string `json:"name"`
	// Revision
	CurrentRevision int `json:"currentRevision"`
	// Status of the process
	Phase RolloutPhases `json:"phase"`
	// Name of current strategy
	CurrentStrategyName RolloutStrategyNames `json:"currentStrategyName"`
	// Number of steps
	Steps *int `json:"steps"`
	// Current step index
	CurrentStepIndex *int `json:"currentStepIndex"`
	// Services
	Services []*string `json:"services"`
	// Status of inline analysis
	CurrentStepAnalysisRunStatus *RolloutAnalysisStatus `json:"currentStepAnalysisRunStatus"`
	// Status of background status
	CurrentBackgroundAnalysisRunStatus *RolloutAnalysisStatus `json:"currentBackgroundAnalysisRunStatus"`
	// Revision info
	RevisionInfo *RevisionInfo `json:"revisionInfo"`
	// Is rollout complete
	IsComplete bool `json:"isComplete"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images"`
	// SyncStatus
	SyncStatus *SyncStatus `json:"syncStatus"`
	// Replicas
	Replicas *int `json:"replicas"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images"`
	// Replicas
	Replicas *int `json:"replicas"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Runtime Errors Report Arguments
type ReportRuntimeErrorsArgs struct {
	// Name of the Runtime
	Runtime string `json:"runtime"`
	// Errors
	Errors []*HealthErrorInput `json:"errors"`
}

// Repositories filter arguments
type RepositoriesFilterArgs struct {
	// Filter repository by name
	Name *string `json:"name"`
}

// Repositories Page
type RepositoriesPage struct {
	// An aray of Repositories in the page
	Data []*Repository `json:"data"`
	// Page number
	Page int `json:"page"`
	// How many repo in a page
	Count int `json:"count"`
	// Has next page?
	HasNext bool `json:"hasNext"`
}

// Repository
type Repository struct {
	// Repo id
	ID string `json:"id"`
	// Git provider
	Provider GitProviders `json:"provider"`
	// Repository full name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Is the repo private ?
	IsRepoPrivate bool `json:"isRepoPrivate"`
	// Last time a commit was pushed to one of the branches
	PushedAt string `json:"pushedAt"`
	// Number of open issues
	OpenIssues int `json:"openIssues"`
	// Clone url
	CloneURL string `json:"cloneUrl"`
	// ssh url
	SSHURL string `json:"sshUrl"`
	// Repo owner login
	OwnerLogin string `json:"ownerLogin"`
	// Repo owner avatar url
	OwnerAvatarURL string `json:"ownerAvatarUrl"`
	// Repo creator
	RepoCreator *string `json:"repoCreator"`
	// Organization name
	Org *string `json:"org"`
	// Default branch name
	DefaultBranch string `json:"defaultBranch"`
	// Has admin permissions ?
	IsRepoAdmin *bool `json:"isRepoAdmin"`
	// Repository url
	WebURL string `json:"webUrl"`
	// Project name
	Project *string `json:"project"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Resource manifest
type ResourceManifest struct {
	// Full filename with path
	Filename *string `json:"filename"`
	// Status: created, updated, deleted
	Status *string `json:"status"`
	// K8s kind
	Kind string `json:"kind"`
	// File contents
	Content string `json:"content"`
}

// ResourcesRequests
type ResourcesRequests struct {
	// CPU
	CPU *string `json:"cpu"`
	// Memory
	Memory *string `json:"memory"`
}

// Revision Info Entity
type RevisionInfo struct {
	// Image Name
	Image string `json:"image"`
	// Current traffic weight directed to this revision
	Weight int `json:"weight"`
	// Current replicas
	Replicas *int `json:"replicas"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas"`
	// Current unavailable replicas
	UnavailableReplicas *int `json:"unavailableReplicas"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas"`
}

// "Rollout Entity
type Rollout struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Spec
	Spec *RolloutSpec `json:"spec"`
	// Status
	Status *RolloutStatus `json:"status"`
}

func (Rollout) IsProjectBasedEntity() {}
func (Rollout) IsBaseEntity()         {}
func (Rollout) IsK8sStandardEntity()  {}
func (Rollout) IsEntity()             {}

// Rollout Analysis Status
type RolloutAnalysisStatus struct {
	// Name of the analysis
	Name string `json:"name"`
	// Number of measurments in this analysis
	TotalMeasurments *int `json:"totalMeasurments"`
	// Number of successful measurments
	Successful *int `json:"successful"`
	// Number of failed measurments
	Failed *int `json:"failed"`
	// Number of erroneous measurments
	Errors *int `json:"errors"`
}

// Rollout Edge
type RolloutEdge struct {
	// Node contains the actual rollout data
	Node *Rollout `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RolloutEdge) IsEdge() {}

// Rollout Slice
type RolloutSlice struct {
	// Rollout edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RolloutSlice) IsSlice() {}

// Rollout Spec
type RolloutSpec struct {
	// Strategy
	Strategy *RolloutStrategy `json:"strategy"`
	// Desired replicas
	DesiredReplicas int `json:"desiredReplicas"`
}

// Rollout Status
type RolloutStatus struct {
	// Index of the current step that is being executed
	CurrentStepIndex *int `json:"currentStepIndex"`
	// Status of the process
	Phase string `json:"phase"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas"`
	// Current traffic weight of the new version
	WeightOfNew int `json:"weightOfNew"`
	// Is the rollout aborted
	Abort *bool `json:"abort"`
	// Status of inline analysis
	CurrentStepAnalysisRunStatus *RolloutAnalysisStatus `json:"currentStepAnalysisRunStatus"`
	// Status of background status
	CurrentBackgroundAnalysisRunStatus *RolloutAnalysisStatus `json:"currentBackgroundAnalysisRunStatus"`
}

// Rollout Strategy
type RolloutStrategy struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps []*string `json:"steps"`
	// The name of the service pointing to the old version
	CurrentService string `json:"currentService"`
	// The name of the service pointing to the new version
	NewService string `json:"newService"`
}

// RolloutTransition Entity
type RolloutTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseRolloutState `json:"from"`
	// To
	To *ReleaseRolloutState `json:"to"`
}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// History of the runtime
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion"`
	// Runtime release information
	RuntimeRelease *Release `json:"runtimeRelease"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

func (Runtime) IsBaseEntity()         {}
func (Runtime) IsProjectBasedEntity() {}
func (Runtime) IsK8sLogicEntity()     {}
func (Runtime) IsEntity()             {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Cluster
	Cluster string `json:"cluster"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

// Runtume Notification
type RuntimeNotification struct {
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (RuntimeNotification) IsNotification()       {}
func (RuntimeNotification) IsArgoCDNotification() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// SSOArgs
type SSOArgs struct {
	// Id
	ID *string `json:"id"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName *string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Entry point
	EntryPoint *string `json:"entryPoint"`
	// Callback url
	CallbackURL *string `json:"callbackUrl"`
	// Cert
	Cert *string `json:"cert"`
	// Provider
	Provider *string `json:"provider"`
	// Keyfile
	Keyfile *string `json:"keyfile"`
	// Subject
	Subject *string `json:"subject"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
	// SyncField
	SyncField *string `json:"syncField"`
	// App Id
	AppID *string `json:"appId"`
	// Tenant
	Tenant *string `json:"tenant"`
	// Password
	Password *string `json:"password"`
	// URL
	URL *string `json:"url"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName"`
	// Search base
	SearchBase *string `json:"searchBase"`
	// Search filter
	SearchFilter *string `json:"searchFilter"`
	// Certificate
	Certificate *string `json:"certificate"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync"`
	// Client host
	ClientHost *string `json:"clientHost"`
	// API client id
	APIClientID *string `json:"apiClientId"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Host
	Host *string `json:"host"`
	// Realm
	Realm *string `json:"realm"`
	// Default
	Default *bool `json:"default"`
}

// SamlSSO
type SamlSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts"`
	// Access token
	AccessToken *string `json:"accessToken"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId"`
	// Client secret
	ClientSecret *string `json:"clientSecret"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl"`
	// Login url
	LoginURL *string `json:"loginUrl"`
	// Default
	Default *bool `json:"default"`
	// Entry point
	EntryPoint *string `json:"entryPoint"`
	// Callback url
	CallbackURL *string `json:"callbackUrl"`
	// Cert
	Cert *string `json:"cert"`
	// Provider
	Provider *string `json:"provider"`
	// Keyfile
	Keyfile *string `json:"keyfile"`
	// Subject
	Subject *string `json:"subject"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync"`
	// Sync interval
	SyncInterval *string `json:"syncInterval"`
	// SyncField
	SyncField *string `json:"syncField"`
}

func (SamlSso) IsIDP() {}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the sensor
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (Sensor) IsGitopsEntity()       {}
func (Sensor) IsBaseEntity()         {}
func (Sensor) IsProjectBasedEntity() {}
func (Sensor) IsEntity()             {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Service entity
type ServiceEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// ServiceSpec
	Spec *ServiceSpec `json:"spec"`
	// Deployment Spec Part
	Deployments []*DeploymentSpecPart `json:"deployments"`
}

func (ServiceEntity) IsGitopsEntity()       {}
func (ServiceEntity) IsBaseEntity()         {}
func (ServiceEntity) IsProjectBasedEntity() {}
func (ServiceEntity) IsEntity()             {}

// Service Entity Edge
type ServiceEntityEdge struct {
	// Node contains the actual Service data
	Node *ServiceEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ServiceEntityEdge) IsEdge() {}

// Service Slice
type ServiceEntitySlice struct {
	// Service edges
	Edges []*ServiceEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ServiceEntitySlice) IsSlice() {}

// Service Item Entity
type ServiceItem struct {
	// Name
	Name *string `json:"name"`
}

// ServicePort
type ServicePort struct {
	// AppProtocol
	AppProtocol *string `json:"appProtocol"`
	// Name
	Name *string `json:"name"`
	// NodePort
	NodePort *int `json:"nodePort"`
	// Port
	Port *int `json:"port"`
	// Protocol
	Protocol *string `json:"protocol"`
	// TargetPort
	TargetPort *string `json:"targetPort"`
}

// ServiceSpec
type ServiceSpec struct {
	// AllocateLoadBalancerNodePorts
	AllocateLoadBalancerNodePorts *bool `json:"allocateLoadBalancerNodePorts"`
	// ClusterIP
	ClusterIP *string `json:"clusterIP"`
	// ClusterIPs
	ClusterIPs []*string `json:"clusterIPs"`
	// ExternalIPs
	ExternalIPs []*string `json:"externalIPs"`
	// ExternalName
	ExternalName *string `json:"externalName"`
	// ExternalTrafficPolicy
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy"`
	// HealthCheckNodePort
	HealthCheckNodePort *int `json:"healthCheckNodePort"`
	// InternalTrafficPolicy
	InternalTrafficPolicy *string `json:"internalTrafficPolicy"`
	// IpFamilies
	IPFamilies []*string `json:"ipFamilies"`
	// IpFamilyPolicy
	IPFamilyPolicy *string `json:"ipFamilyPolicy"`
	// LoadBalancerClass
	LoadBalancerClass *string `json:"loadBalancerClass"`
	// LoadBalancerIP
	LoadBalancerIP *string `json:"loadBalancerIP"`
	// LoadBalancerSourceRanges
	LoadBalancerSourceRanges []*string `json:"loadBalancerSourceRanges"`
	// Ports
	Ports []*ServicePort `json:"ports"`
	// PublishNotReadyAddresses
	PublishNotReadyAddresses *bool `json:"publishNotReadyAddresses"`
	// Selector
	Selector []*StringPair `json:"selector"`
	// SessionAffinity
	SessionAffinity *string `json:"sessionAffinity"`
	// SessionAffinityConfig
	SessionAffinityConfig *SessionAffinityConfig `json:"sessionAffinityConfig"`
	// Type
	Type *ServiceType `json:"type"`
}

// ServiceTransition Entity
type ServiceTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseServiceState `json:"from"`
	// To
	To *ReleaseServiceState `json:"to"`
}

// SessionAffinityConfig
type SessionAffinityConfig struct {
	// ClientIP
	ClientIP *ClientIP `json:"clientIP"`
}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
}

// Args to set the permissions of a specific user to a git-source
type SetGitSourcePermissionArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The new permission to set
	Permission *PermissionInput `json:"permission"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Source arguments
type SourceArgs struct {
	Github   []*GithubSourceArgs   `json:"github"`
	Calendar []*CalendarSourceArgs `json:"calendar"`
}

// Object of specific trigger conditions
type SpecificTriggerConditions struct {
	// Github trigger conditions
	Github []*GithubTriggerConditions `json:"github"`
}

// Object of specific trigger conditions
type SpecificTriggerConditionsArgs struct {
	// Github trigger conditions
	Github []*GithubTriggerConditionsArgs `json:"github"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType"`
	// Display name
	DisplayName *string `json:"displayName"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message"`
}

// Lable
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// Stripe
type Stripe struct {
	// Name
	HardCodedPlan *bool `json:"hardCodedPlan"`
	// Plan id
	PlanID *string `json:"planId"`
	// Subscription id
	SubscriptionID *string `json:"subscriptionId"`
	// Customer id
	CustomerID *string `json:"customerId"`
}

// Event filter
type SupportedEventMapping struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// Mappings between the var name and the path to the value in event payload
	Mappings []*Mapping `json:"mappings"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context"`
}

func (SyncError) IsError() {}

// To State Entity
type ToState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Transition Entity
type Transition struct {
	// Services
	Services []*ServiceTransition `json:"services"`
	// Rollouts
	Rollouts []*RolloutTransition `json:"rollouts"`
}

// Trial
type Trial struct {
	// Trialing
	Trialing *bool `json:"trialing"`
	// IsRuntimePaying
	IsRuntimePaying *bool `json:"isRuntimePaying"`
	// TrialWillEndNotified
	TrialWillEndNotified *bool `json:"trialWillEndNotified"`
	// TrialEndedNotified
	TrialEndedNotified *bool `json:"trialEndedNotified"`
	// Type
	Type *string `json:"type"`
	// PreviousSegment
	PreviousSegment *string `json:"previousSegment"`
	// TrialEnd
	TrialEnd *string `json:"trialEnd"`
}

// Differentiated DataFilters
type TriggerConditionDataFilters struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilter `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilter `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilter `json:"predefined"`
}

// Differentiated DataFilters
type TriggerConditionDataFiltersArgs struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilterArgs `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilterArgs `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilterArgs `json:"predefined"`
}

// TriggerConditions filters object
type TriggerConditionFilters struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFilters `json:"data"`
}

// TriggerConditions filters object
type TriggerConditionFiltersArgs struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFiltersArgs `json:"data"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameter struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameterArgs struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditions struct {
	// Conditions
	Conditions *SpecificTriggerConditions `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflow `json:"workflow"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditionsArgs struct {
	// Sensor name
	SensorName string `json:"sensorName"`
	// Trigger name
	TriggerName string `json:"triggerName"`
	// Ingress host (SET ON BACKEND)
	IngressHost *string `json:"ingressHost"`
	// Conditions
	Conditions *SpecificTriggerConditionsArgs `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflowArgs `json:"workflow"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflow struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameter `json:"parameters"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflowArgs struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameterArgs `json:"parameters"`
}

// Trigger parameter
type TriggerParameter struct {
	// Src contains a source reference to the value of the parameter from a dependency
	Src *TriggerParameterSource `json:"src"`
	// Name is the argument parameter name in the workflowTemplate
	Name string `json:"name"`
	// Operation is what to do with the existing value at Dest, whether to ‘prepend’, ‘overwrite’, or ‘append’ it
	Operation string `json:"operation"`
}

// Trigger parameter source
type TriggerParameterSource struct {
	// DataTemplate is a go-template for extracting a string from the event’s data. If a DataTemplate is provided with a DataKey, the template will be evaluated first and fallback to the DataKey. The templating follows the standard go-template syntax as well as sprig’s extra functions. See https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/. in addition you can pass a predefined varibles as the following ${{ VAR }} - assuming VAR is predefiend varaible or just a simple value as 'var'
	DataTemplate string `json:"dataTemplate"`
	// Value is the default literal value to use for this parameter source This is only used if the DataKey is invalid. If the DataKey is invalid and this is not defined, this param source will produce an error
	Value *string `json:"value"`
}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// Args to update the permissions of a git-source
type UpdateGitSourcePermissionsArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The set of permissions
	Permissions []*PermissionInput `json:"permissions"`
}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount"`
	// The customers that this user is in
	Customers []Customer `json:"customers"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate"`
	// User chosen sso of active account
	Sso *string `json:"sso"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []string `json:"eventsPayload"`
	// Pipeline refernece
	Pipeline *Pipeline `json:"pipeline"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Workflow URL
	URL *string `json:"url"`
}

func (Workflow) IsProjectBasedEntity() {}
func (Workflow) IsBaseEntity()         {}
func (Workflow) IsK8sStandardEntity()  {}
func (Workflow) IsEntity()             {}

// WorkflowConcurrency
type WorkflowConcurrency struct {
	// Concurrency
	Concurrency *WorkflowConcurrencyInfo `json:"concurrency"`
}

// WorkflowConcurrency
type WorkflowConcurrencyInfo struct {
	// Price
	Price *BasePrice `json:"price"`
	// Amount
	Amount *int `json:"amount"`
	// Absorb
	Absorb *int `json:"absorb"`
	// Min
	Min *int `json:"min"`
	// Max
	Max *int `json:"max"`
	// AllowUnlimited
	AllowUnlimited *bool `json:"allowUnlimited"`
}

// Workflow conditions
type WorkflowConditions struct {
	// Type
	Type *string `json:"type"`
	// Status
	Status *string `json:"status"`
}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// Command array
	Command []*string `json:"command"`
	// Args
	Args []*string `json:"args"`
	// Env map
	Env []*StringPair `json:"env"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon"`
	// Container
	Container *WorkflowContainerSpec `json:"container"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// WorkflowLogEntry
type WorkflowLogEntry struct {
	// Pod Name
	PodName string `json:"podName"`
	// Timestamp
	Timestamp string `json:"timestamp"`
	// Content
	Content string `json:"content"`
}

// Workflow Parameter object
type WorkflowParameter struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value"`
	// Default value
	Default *string `json:"default"`
}

// Workflow Parameter object
type WorkflowParameterArgs struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value"`
	// Default value
	Default *string `json:"default"`
}

// "Repository data for workflows
type WorkflowRepository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow resources duration
type WorkflowResourcesDuration struct {
	// Cpu
	CPU *int `json:"cpu"`
	// Memory
	Memory *int `json:"memory"`
}

// Response for resubmitting a workflow
type WorkflowResubmitResponse struct {
	// The newly created workflow name
	NewWorkflowName string `json:"newWorkflowName"`
}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes"`
	// Message
	Message *string `json:"message"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Stored Templates
	StoredTemplates *string `json:"storedTemplates"`
	// Stored workflow template spec
	StoredWorkflowTemplateSpec *string `json:"storedWorkflowTemplateSpec"`
	// Conditions
	Conditions []*WorkflowConditions `json:"conditions"`
	// Resources duration
	ResourcesDuration *WorkflowResourcesDuration `json:"resourcesDuration"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the workflow-template
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity()       {}
func (WorkflowTemplate) IsBaseEntity()         {}
func (WorkflowTemplate) IsProjectBasedEntity() {}
func (WorkflowTemplate) IsEntity()             {}

// Workflow template arguments
type WorkflowTemplateArgs struct {
	// Workflow template name
	Name string `json:"name"`
	// Workflow template entrypoint
	Entrypoint *string `json:"entrypoint"`
}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow template filter arguments
type WorkflowTemplatesFilterArgs struct {
	// Filter WorkflowTemplates from a specific project
	Project *string `json:"project"`
	// Filter WorkflowTemplates from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter WorkflowTemplates by name
	Name *string `json:"name"`
	// Filter WorkflowTemplates by git source
	GitSource *string `json:"gitSource"`
}

// Application Tree Sorting field
type ApplicationTreeSortingField string

const (
	// healthStatus
	ApplicationTreeSortingFieldHealthStatus ApplicationTreeSortingField = "healthStatus"
	// kind
	ApplicationTreeSortingFieldKind ApplicationTreeSortingField = "kind"
	// last deployment date
	ApplicationTreeSortingFieldLastUpdated ApplicationTreeSortingField = "lastUpdated"
	// name
	ApplicationTreeSortingFieldName ApplicationTreeSortingField = "name"
	// runtime
	ApplicationTreeSortingFieldRuntime ApplicationTreeSortingField = "runtime"
	// syncStatus
	ApplicationTreeSortingFieldSyncStatus ApplicationTreeSortingField = "syncStatus"
)

var AllApplicationTreeSortingField = []ApplicationTreeSortingField{
	ApplicationTreeSortingFieldHealthStatus,
	ApplicationTreeSortingFieldKind,
	ApplicationTreeSortingFieldLastUpdated,
	ApplicationTreeSortingFieldName,
	ApplicationTreeSortingFieldRuntime,
	ApplicationTreeSortingFieldSyncStatus,
}

func (e ApplicationTreeSortingField) IsValid() bool {
	switch e {
	case ApplicationTreeSortingFieldHealthStatus, ApplicationTreeSortingFieldKind, ApplicationTreeSortingFieldLastUpdated, ApplicationTreeSortingFieldName, ApplicationTreeSortingFieldRuntime, ApplicationTreeSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e ApplicationTreeSortingField) String() string {
	return string(e)
}

func (e *ApplicationTreeSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationTreeSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationTreeSortingField", str)
	}
	return nil
}

func (e ApplicationTreeSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Comparator values - “>=”, “>”, “=”, “!=”, “<”, or “<=”.
type Comparator string

const (
	ComparatorGt  Comparator = "GT"
	ComparatorGte Comparator = "GTE"
	ComparatorEq  Comparator = "EQ"
	ComparatorNe  Comparator = "NE"
	ComparatorLt  Comparator = "LT"
	ComparatorLte Comparator = "LTE"
)

var AllComparator = []Comparator{
	ComparatorGt,
	ComparatorGte,
	ComparatorEq,
	ComparatorNe,
	ComparatorLt,
	ComparatorLte,
}

func (e Comparator) IsValid() bool {
	switch e {
	case ComparatorGt, ComparatorGte, ComparatorEq, ComparatorNe, ComparatorLt, ComparatorLte:
		return true
	}
	return false
}

func (e Comparator) String() string {
	return string(e)
}

func (e *Comparator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Comparator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Comparator", str)
	}
	return nil
}

func (e Comparator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Git providers
type GitProviders string

const (
	// Github
	GitProvidersGithub GitProviders = "GITHUB"
	// Gitlab
	GitProvidersGitlab GitProviders = "GITLAB"
)

var AllGitProviders = []GitProviders{
	GitProvidersGithub,
	GitProvidersGitlab,
}

func (e GitProviders) IsValid() bool {
	switch e {
	case GitProvidersGithub, GitProvidersGitlab:
		return true
	}
	return false
}

func (e GitProviders) String() string {
	return string(e)
}

func (e *GitProviders) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitProviders(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitProviders", str)
	}
	return nil
}

func (e GitProviders) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Runtime Installation error
	HealthErrorCodesRuntimeInstallationError HealthErrorCodes = "RUNTIME_INSTALLATION_ERROR"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesRuntimeInstallationError,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesRuntimeInstallationError, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image registry domain types
type ImageRegistryType string

const (
	// Docker hub
	ImageRegistryTypeDockerHub ImageRegistryType = "DOCKER_HUB"
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
	// Quay
	ImageRegistryTypeQuay ImageRegistryType = "QUAY"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeDockerHub,
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeOther,
	ImageRegistryTypeQuay,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeDockerHub, ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeOther, ImageRegistryTypeQuay:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image registry domain types
type ImageRegistryType string

const (
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeOther,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeOther:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// jSON types
type JSONTypes string

const (
	JSONTypesArray   JSONTypes = "Array"
	JSONTypesBoolean JSONTypes = "Boolean"
	JSONTypesNumber  JSONTypes = "Number"
	JSONTypesObject  JSONTypes = "Object"
	JSONTypesString  JSONTypes = "String"
)

var AllJSONTypes = []JSONTypes{
	JSONTypesArray,
	JSONTypesBoolean,
	JSONTypesNumber,
	JSONTypesObject,
	JSONTypesString,
}

func (e JSONTypes) IsValid() bool {
	switch e {
	case JSONTypesArray, JSONTypesBoolean, JSONTypesNumber, JSONTypesObject, JSONTypesString:
		return true
	}
	return false
}

func (e JSONTypes) String() string {
	return string(e)
}

func (e *JSONTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JSONTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JsonTypes", str)
	}
	return nil
}

func (e JSONTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification action type
type NotificationActionType string

const (
	// Add action
	NotificationActionTypeAdded NotificationActionType = "ADDED"
	// Remove action
	NotificationActionTypeRemoved NotificationActionType = "REMOVED"
	// Update action
	NotificationActionTypeUpdate NotificationActionType = "UPDATE"
)

var AllNotificationActionType = []NotificationActionType{
	NotificationActionTypeAdded,
	NotificationActionTypeRemoved,
	NotificationActionTypeUpdate,
}

func (e NotificationActionType) IsValid() bool {
	switch e {
	case NotificationActionTypeAdded, NotificationActionTypeRemoved, NotificationActionTypeUpdate:
		return true
	}
	return false
}

func (e NotificationActionType) String() string {
	return string(e)
}

func (e *NotificationActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationActionType", str)
	}
	return nil
}

func (e NotificationActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification State
type NotificationState string

const (
	// Failed state
	NotificationStateFailed NotificationState = "FAILED"
	// In progress state
	NotificationStateInProgress NotificationState = "IN_PROGRESS"
	// Success state
	NotificationStateSuccess NotificationState = "SUCCESS"
)

var AllNotificationState = []NotificationState{
	NotificationStateFailed,
	NotificationStateInProgress,
	NotificationStateSuccess,
}

func (e NotificationState) IsValid() bool {
	switch e {
	case NotificationStateFailed, NotificationStateInProgress, NotificationStateSuccess:
		return true
	}
	return false
}

func (e NotificationState) String() string {
	return string(e)
}

func (e *NotificationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationState", str)
	}
	return nil
}

func (e NotificationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification Type
type NotificationType string

const (
	// Event that are coming from argo cd
	NotificationTypeArgoCdEvent NotificationType = "ARGO_CD_EVENT"
	// Event that are coming from argo events
	NotificationTypeArgoEventsEvent NotificationType = "ARGO_EVENTS_EVENT"
	// Generic Event
	NotificationTypeGenericEvent NotificationType = "GENERIC_EVENT"
)

var AllNotificationType = []NotificationType{
	NotificationTypeArgoCdEvent,
	NotificationTypeArgoEventsEvent,
	NotificationTypeGenericEvent,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeArgoCdEvent, NotificationTypeArgoEventsEvent, NotificationTypeGenericEvent:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Phases
type RolloutPhases string

const (
	// Degraded
	RolloutPhasesDegraded RolloutPhases = "Degraded"
	// Healthy
	RolloutPhasesHealthy RolloutPhases = "Healthy"
	// Paused
	RolloutPhasesPaused RolloutPhases = "Paused"
	// Progressing
	RolloutPhasesProgressing RolloutPhases = "Progressing"
	// Unknown
	RolloutPhasesUnknown RolloutPhases = "Unknown"
)

var AllRolloutPhases = []RolloutPhases{
	RolloutPhasesDegraded,
	RolloutPhasesHealthy,
	RolloutPhasesPaused,
	RolloutPhasesProgressing,
	RolloutPhasesUnknown,
}

func (e RolloutPhases) IsValid() bool {
	switch e {
	case RolloutPhasesDegraded, RolloutPhasesHealthy, RolloutPhasesPaused, RolloutPhasesProgressing, RolloutPhasesUnknown:
		return true
	}
	return false
}

func (e RolloutPhases) String() string {
	return string(e)
}

func (e *RolloutPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutPhases", str)
	}
	return nil
}

func (e RolloutPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Strategy Names
type RolloutStrategyNames string

const (
	// BlueGreen
	RolloutStrategyNamesBlueGreen RolloutStrategyNames = "blueGreen"
	// Canary
	RolloutStrategyNamesCanary RolloutStrategyNames = "canary"
)

var AllRolloutStrategyNames = []RolloutStrategyNames{
	RolloutStrategyNamesBlueGreen,
	RolloutStrategyNamesCanary,
}

func (e RolloutStrategyNames) IsValid() bool {
	switch e {
	case RolloutStrategyNamesBlueGreen, RolloutStrategyNamesCanary:
		return true
	}
	return false
}

func (e RolloutStrategyNames) String() string {
	return string(e)
}

func (e *RolloutStrategyNames) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStrategyNames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStrategyNames", str)
	}
	return nil
}

func (e RolloutStrategyNames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service Sorting field
type ServiceSortingField string

const (
	// Last Update
	ServiceSortingFieldLastUpdate ServiceSortingField = "lastUpdate"
	// Service Name
	ServiceSortingFieldServiceName ServiceSortingField = "serviceName"
)

var AllServiceSortingField = []ServiceSortingField{
	ServiceSortingFieldLastUpdate,
	ServiceSortingFieldServiceName,
}

func (e ServiceSortingField) IsValid() bool {
	switch e {
	case ServiceSortingFieldLastUpdate, ServiceSortingFieldServiceName:
		return true
	}
	return false
}

func (e ServiceSortingField) String() string {
	return string(e)
}

func (e *ServiceSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceSortingField", str)
	}
	return nil
}

func (e ServiceSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ServiceType
type ServiceType string

const (
	ServiceTypeClusterIP    ServiceType = "ClusterIP"
	ServiceTypeExternalName ServiceType = "ExternalName"
	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
	ServiceTypeNodePort     ServiceType = "NodePort"
)

var AllServiceType = []ServiceType{
	ServiceTypeClusterIP,
	ServiceTypeExternalName,
	ServiceTypeLoadBalancer,
	ServiceTypeNodePort,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeClusterIP, ServiceTypeExternalName, ServiceTypeLoadBalancer, ServiceTypeNodePort:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sharing policy
type SharingPolicy string

const (
	// Only account admins see this integration
	SharingPolicyAccountAdmins SharingPolicy = "ACCOUNT_ADMINS"
	// All users in account can see this integration
	SharingPolicyAllUsersInAccount SharingPolicy = "ALL_USERS_IN_ACCOUNT"
)

var AllSharingPolicy = []SharingPolicy{
	SharingPolicyAccountAdmins,
	SharingPolicyAllUsersInAccount,
}

func (e SharingPolicy) IsValid() bool {
	switch e {
	case SharingPolicyAccountAdmins, SharingPolicyAllUsersInAccount:
		return true
	}
	return false
}

func (e SharingPolicy) String() string {
	return string(e)
}

func (e *SharingPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SharingPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SharingPolicy", str)
	}
	return nil
}

func (e SharingPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting order
type SortingOrder string

const (
	// ascending
	SortingOrderAsc SortingOrder = "asc"
	// descending
	SortingOrderDesc SortingOrder = "desc"
)

var AllSortingOrder = []SortingOrder{
	SortingOrderAsc,
	SortingOrderDesc,
}

func (e SortingOrder) IsValid() bool {
	switch e {
	case SortingOrderAsc, SortingOrderDesc:
		return true
	}
	return false
}

func (e SortingOrder) String() string {
	return string(e)
}

func (e *SortingOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingOrder", str)
	}
	return nil
}

func (e SortingOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
	// Unknown
	WorkflowPhasesUnknown WorkflowPhases = "Unknown"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
	WorkflowPhasesUnknown,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded, WorkflowPhasesUnknown:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

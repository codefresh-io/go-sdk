// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// Favorable
type Favorable interface {
	IsFavorable()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	IsGitopsEntity()
}

// Base integration type
type Integration interface {
	IsIntegration()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Notification information kinds
type NotificationInfo interface {
	IsNotificationInfo()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations"`
	// Users that are attached to this account
	Users []*User `json:"users"`
	// Ids of all users that have account admin premission to this account
	Admins []string `json:"admins"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
	// Account security
	Security *SecurityInfo `json:"security"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle"`
}

// Git integration creation args
type AddGitIntegrationArgs struct {
	// Git integration name
	Name *string `json:"name"`
	// Git provider
	Provider GitProviders `json:"provider"`
	// The address of the git provider api
	APIURL string `json:"apiUrl"`
	// Sharing policy
	SharingPolicy SharingPolicy `json:"sharingPolicy"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
}

// Annotation
type Annotation struct {
	// Annotation type
	Type *string `json:"type"`
	// Annotation value
	Value *string `json:"value"`
	// Annotation accountId
	AccountID *string `json:"accountId"`
	// Annotation entityId
	EntityID *string `json:"entityId"`
	// Annotation entityType
	EntityType *string `json:"entityType"`
	// Annotation key
	Key *string `json:"key"`
}

// Args to set annotation for entity
type AnnotationArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
	// Event-source issueValue
	IssueValue *IssueValue `json:"issueValue"`
	// Event-source pullRequestValue
	PullRequestValue *PullRequestValue `json:"pullRequestValue"`
}

// Application Edge
type AnnotationEdge struct {
	// Node contains the actual application data
	Node *Annotation `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter annotation
type AnnotationFilterArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId"`
	// Event-source entityType
	EntityType *string `json:"entityType"`
	// Event-source key
	Key *string `json:"key"`
	// Event-source type
	Type *string `json:"type"`
}

// Annotation Slice
type AnnotationSlice struct {
	// Annotation edges
	Edges []*AnnotationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token"`
}

// App Proxy version information
type AppProxyVersionInfo struct {
	// The version of the app-proxy
	Version string `json:"version"`
	// The address of the platform the app-proxy is working with
	PlatformHost string `json:"platformHost"`
	// The version of the platform this app-proxy was built against
	PlatformVersion string `json:"platformVersion"`
}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Updated At
	UpdatedAt *string `json:"updatedAt"`
	// Path
	Path *string `json:"path"`
	// RepoURL
	RepoURL *string `json:"repoURL"`
	// Number of resources
	Size *int `json:"size"`
	// Revision
	Revision *string `json:"revision"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Cluster from runtime
	Cluster *string `json:"cluster"`
	// Favorites
	Favorites []string `json:"favorites"`
}

func (Application) IsGitopsEntity()       {}
func (Application) IsBaseEntity()         {}
func (Application) IsProjectBasedEntity() {}
func (Application) IsFavorable()          {}
func (Application) IsEntity()             {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

// ApplicationField Entity
type ApplicationField struct {
	// Status
	Status *ArgoCDApplicationStatus `json:"status"`
	// Issues
	Issues []*string `json:"issues"`
	// PullRequest
	Prs []*PullRequest `json:"prs"`
	// Committers
	Committers []*CommitterLabel `json:"committers"`
	// Build
	Builds []*Build `json:"builds"`
}

// Application ref
type ApplicationRef struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Is reference was cut during tree normalizing
	IsReferenceCut *bool `json:"isReferenceCut"`
}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Application relations
type AppsRelations struct {
	// Entities referencing this entity
	ReferencedBy []*ApplicationRef `json:"referencedBy"`
	// Entities referenced by this enitity
	References []*ApplicationRef `json:"references"`
}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Revision
	Revision string `json:"revision"`
	// Version
	Version string `json:"version"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage"`
	// CommitDate
	CommitDate *string `json:"commitDate"`
}

// Build Entity
type Build struct {
	// Build Id
	ID string `json:"id"`
	// PipelineRef
	Pipeline *PipelineRef `json:"pipeline"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// TBD
	Schedule string `json:"schedule"`
	// TBD
	Interval string `json:"interval"`
	// TBD
	Timezone string `json:"timezone"`
	// TBD
	Metadata string `json:"metadata"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// Calenar source arguments
type CalendarSourceArgs struct {
	// Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron
	Schedule string `json:"schedule"`
	// Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h…
	Interval string `json:"interval"`
	// Exclusion dates for running job
	ExclusionDates []*string `json:"exclusionDates"`
	// Timezone in which to run the schedule
	Timezone *string `json:"timezone"`
}

// ChildApplicationField Entity
type ChildApplicationField struct {
	// Name
	Name string `json:"name"`
	// Repo
	Repo *string `json:"repo"`
	// Cluster
	Cluster *string `json:"cluster"`
	// Status
	Status *SyncStatus `json:"status"`
}

// ClientIP
type ClientIP struct {
	// TimeoutSeconds
	TimeoutSeconds *int `json:"timeoutSeconds"`
}

// Commit
type Commit struct {
	// Commit sha
	Sha string `json:"sha"`
	// Committer
	Committer *Committer `json:"committer"`
}

// Commit files to a git repository args
type CommitFilesArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// Branch name
	BranchName string `json:"branchName"`
	// Repository full name in format {owner}/{name}
	Repo string `json:"repo"`
	// Files to commit
	Files []*File `json:"files"`
	// Commit messege
	Msg *string `json:"msg"`
	// Description messege
	Description *string `json:"description"`
}

// Git committer profile
type Committer struct {
	// Committer name
	Name string `json:"name"`
	// Committer email
	Email *string `json:"email"`
	// Committer avatar url
	AvatarURL *string `json:"avatarUrl"`
	// Committer page url
	ProfileURL *string `json:"profileUrl"`
}

// Committer Label
type CommitterLabel struct {
	// UserName
	UserName string `json:"userName"`
	// Avatar
	Avatar string `json:"avatar"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the component
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity()         {}
func (Component) IsK8sLogicEntity()     {}
func (Component) IsProjectBasedEntity() {}
func (Component) IsEntity()             {}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Composite Slice
type CompositeSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo []*CompositeSliceInfo `json:"pageInfo"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Infomration about a slice of a specific kind
type CompositeSliceInfo struct {
	// Key of the slice
	Key string `json:"key"`
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
}

// Pagination arguments to request kind-slice
type CompositeSlicePaginationArgs struct {
	// References a specific key
	Key string `json:"key"`
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Pipeline creation arguments
type CreatePipelineArgs struct {
	// Sensor name
	SensorName string `json:"sensorName"`
	// Trigger name
	TriggerName string `json:"triggerName"`
	// Source arguments
	SourcesArgs *SourceArgs `json:"sourcesArgs"`
	// Workflow template arguments
	WorkflowTemplateArgs *WorkflowTemplateArgs `json:"workflowTemplateArgs"`
}

// Custom Date filter
type CustomDataFilter struct {
	// Path is the JSONPath of the event’s (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters and ‘?’. To access an array value use the index as the key. The dot and wildcard characters can be escaped with ‘’. See https://github.com/tidwall/gjson#path-syntax for more information on how to use this. in addition you can pass a predefined varibles as the following ${{ VAR }} - assuming VAR is predefiend varaible
	Path string `json:"path"`
	// Type contains the JSON type of the data
	Type JSONTypes `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
	// Comparator compares the event data with a user given value. if left blank treated as equality
	Comparator *Comparator `json:"comparator"`
	// Template is a go-template for extracting a string from the event’s data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig’s extra functions. See https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/
	Template *string `json:"template"`
}

// Date filters
type DataFilter struct {
	// Filters from pre defined list
	PredefinedDataFilter *PredefinedDataFilter `json:"predefinedDataFilter"`
	// Custom filters
	CustomDataFilter *CustomDataFilter `json:"customDataFilter"`
}

// Delete files from a git repository args
type DeleteFilesArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// Branch name
	BranchName string `json:"branchName"`
	// Repository name in format {owner}/{name}
	Repo string `json:"repo"`
	// File paths to delete
	Paths []string `json:"paths"`
	// Commit messege
	Msg *string `json:"msg"`
	// Description messege
	Description *string `json:"description"`
}

// Deployment entity
type Deployment struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Deployment Entity
	Spec *DeploymentSpec `json:"spec"`
	// Deployment Status
	Status *DeploymentStatus `json:"status"`
}

func (Deployment) IsGitopsEntity()       {}
func (Deployment) IsBaseEntity()         {}
func (Deployment) IsProjectBasedEntity() {}
func (Deployment) IsEntity()             {}

// Container
type DeploymentContainer struct {
	// Containers
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// ImagePullPolicy
	ImagePullPolicy *ImagePullPolicy `json:"imagePullPolicy"`
}

// Deployment Edge
type DeploymentEdge struct {
	// Node contains the actual Deployment data
	Node *Deployment `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (DeploymentEdge) IsEdge() {}

// Deployment Slice
type DeploymentSlice struct {
	// Deployment edges
	Edges []*DeploymentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (DeploymentSlice) IsSlice() {}

// Deployment Spec
type DeploymentSpec struct {
	// Template
	Template *PodTemplateSpec `json:"template"`
	// Replicas
	Replicas *int `json:"replicas"`
}

// DeploymentSpecPart
type DeploymentSpecPart struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Status
	Status *DeploymentStatus `json:"status"`
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// Deployment Status
type DeploymentStatus struct {
	// Replicas
	Replicas *int `json:"replicas"`
	// AvailableReplicas
	AvailableReplicas *int `json:"availableReplicas"`
	// ReadyReplicas
	ReadyReplicas *int `json:"readyReplicas"`
	// UnavailableReplicas
	UnavailableReplicas *int `json:"unavailableReplicas"`
	// UpdatedReplicas
	UpdatedReplicas *int `json:"updatedReplicas"`
}

// Git integration edit args
type EditGitIntegrationArgs struct {
	// Git integration name
	Name *string `json:"name"`
	// The address of the git provider api
	APIURL string `json:"apiUrl"`
	// Sharing policy
	SharingPolicy SharingPolicy `json:"sharingPolicy"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line"`
	// Commit url
	CommitURL *string `json:"commitUrl"`
	// Commit url with file
	FileURL *string `json:"fileUrl"`
}

// Event dependency filter
type EventDependencyFilter struct {
	// Data filter constraints with escalation
	Data []*DataFilter `json:"data"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid"`
	// Content of the event
	Data *string `json:"data"`
	// Time
	Time *string `json:"time"`
	// Event source
	EventSource *EventSource `json:"eventSource"`
	// Event name
	EventName *string `json:"eventName"`
	// Event type
	EventType *string `json:"eventType"`
	// Account
	Account *string `json:"account"`
	// Runtime
	Runtime *string `json:"runtime"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the event-source
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (EventSource) IsBaseEntity()         {}
func (EventSource) IsGitopsEntity()       {}
func (EventSource) IsProjectBasedEntity() {}
func (EventSource) IsEntity()             {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Event source type
type EventSourceType struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// List of the supported events by this event source type. CAP know how to filter this kind of events.
	Events []*SupportedEventMapping `json:"events"`
}

// Args to set favorite for entity
type FavoriteInfoArgs struct {
	// Event-source kind
	Kind string `json:"kind"`
	// Event-source group
	Group string `json:"group"`
	// Event-source group
	Version string `json:"version"`
	// Event-source runtime name
	Runtime string `json:"runtime"`
	// Event-source name
	Name string `json:"name"`
	// Event-source namespace
	Namespace *string `json:"namespace"`
}

// File
type File struct {
	// File full path
	Path string `json:"path"`
	// File revision
	Revision *string `json:"revision"`
	// File data
	Data string `json:"data"`
}

// From State Entity
type FromState struct {
	// Services
	Services []*ServiceItem `json:"services"`
}

type GeneratedManifest struct {
	// Generated manifests to commit
	Manifest string `json:"manifest"`
	// File name to store the manifest
	Filename string `json:"filename"`
	// Kind of the k8s resource
	Kind string `json:"kind"`
}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (GenericEntity) IsGitopsEntity()       {}
func (GenericEntity) IsBaseEntity()         {}
func (GenericEntity) IsProjectBasedEntity() {}
func (GenericEntity) IsEntity()             {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// Git integration
type GitIntegration struct {
	// Git integration name
	Name string `json:"name"`
	// Sharing policy
	SharingPolicy SharingPolicy `json:"sharingPolicy"`
	// Git provider
	Provider GitProviders `json:"provider"`
	// The address of the git provider api
	APIURL string `json:"apiUrl"`
	// List of user ids that registered themselves to this git integration
	RegisteredUsers []string `json:"registeredUsers"`
}

func (GitIntegration) IsIntegration() {}

// GitOps Edge
type GitOpsEdge struct {
	// Node contains the actual component data
	Node GitopsEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// GitOps Slice
type GitOpsSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork"`
	// PR comment
	Comment *GitPRComment `json:"comment"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// PR data
	Pr *GitPr `json:"pr"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPREventPayloadData) IsEventPayloadData()          {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *WorkflowRepository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha"`
	// SHA URL
	ShaURL *string `json:"shaURL"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitPushEventPayloadData) IsEventPayloadData()          {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Release data
	Release *GitRelease `json:"release"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitReleaseEventPayloadData) IsEventPayloadData()          {}

// Git Repositories Args
type GitRepositoriesArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// If empty will return first page
	Page *int `json:"page"`
	// Default 100, max 200 results per page
	Limit *int `json:"limit"`
}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self"`
	// History of the GitSource
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Permissions to this git source
	Permissions []*Permission `json:"permissions"`
}

func (GitSource) IsK8sLogicEntity()     {}
func (GitSource) IsBaseEntity()         {}
func (GitSource) IsProjectBasedEntity() {}
func (GitSource) IsEntity()             {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git source notification
type GitSourceNotification struct {
	// Commit information that triggered sync
	Source *GitopsEntitySource `json:"source"`
	// Link to the git-source in git provider
	GsRepoLink *string `json:"gsRepoLink"`
	// Sync status
	GsSyncStatus SyncStatus `json:"gsSyncStatus"`
}

func (GitSourceNotification) IsNotificationInfo() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}
func (GitUnknownEventPayloadData) IsEventPayloadData()          {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Events
type GithubEventArgs struct {
	Action     string                   `json:"action"`
	Filters    []*EventDependencyFilter `json:"filters"`
	Parameters []*TriggerParameter      `json:"parameters"`
}

// Github source arguments
type GithubSourceArgs struct {
	Repository string             `json:"repository"`
	Events     []*GithubEventArgs `json:"events"`
}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource"`
	// Repo URL
	RepoURL *string `json:"repoURL"`
	// Path
	Path *string `json:"path"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL"`
	// Git revision
	Revision *string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage"`
	// Git commit date
	CommitDate *string `json:"commitDate"`
	// Git commit web url
	CommitURL *string `json:"commitURL"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor"`
	// Author web profile url
	ProfileURL *string `json:"profileURL"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL"`
	// Git manifest
	GitManifest *string `json:"gitManifest"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction"`
}

// Gitops Release Entity
type GitopsRelease struct {
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
	// History id
	HistoryID int `json:"historyId"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
}

// Release Edge
type GitopsReleaseEdge struct {
	// Node contains the actual application data
	Node *GitopsRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter release
type GitopsReleaseFilterArgs struct {
	// Runtime
	Runtime *string `json:"runtime"`
	// Name
	Name *string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Group
	Group *string `json:"group"`
	// Version
	Version *string `json:"version"`
	// Kind
	Kind *string `json:"kind"`
	// HistoryId
	HistoryID *int `json:"historyId"`
}

// Gitops Release Slice
type GitopsReleaseSlice struct {
	// Release edges
	Edges []*GitopsReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// Health Error Input
type HealthErrorInput struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Message
	Message string `json:"message"`
}

// Image binary entity
type ImageBinary struct {
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// ImageName
	ImageName string `json:"imageName"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Branch
	Branch *string `json:"branch"`
	// Commit
	Commit *string `json:"commit"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg"`
	// CommitURL
	CommitURL *string `json:"commitURL"`
	// Git repository
	GitRepository *string `json:"gitRepository"`
	//  AccountId
	AccountID string `json:"accountId"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	// Size
	Size *int `json:"size"`
	// OS
	Os *string `json:"os"`
	// Architecture
	Architecture *string `json:"architecture"`
	// Info
	Info *string `json:"info"`
	// Image registry
	ImageRegistryDomains []*ImageRegistryType `json:"imageRegistryDomains"`
}

func (ImageBinary) IsEntity() {}

// Image Binary Edge
type ImageBinaryEdge struct {
	// Node contains the actual image binary data
	Node *ImageBinary `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageBinaryEdge) IsEdge() {}

//  ImageBinaryInput
type ImageBinaryOutput struct {
	//  Id
	ID string `json:"id"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch"`
	//  Commit
	Commit *string `json:"commit"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg"`
	//  CommitURL
	CommitURL *string `json:"commitURL"`
	//  DockerFile
	DockerFile *string `json:"dockerFile"`
	//  Size
	Size *int `json:"size"`
	//  Os
	Os *string `json:"os"`
	//  Architecture
	Architecture *string `json:"architecture"`
	//  Info
	Info *string `json:"info"`
}

// Images Binary Slice
type ImageBinarySlice struct {
	// Image edges
	Edges []*ImageBinaryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageBinarySlice) IsSlice() {}

// Image Registry entity
type ImageRegistry struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	//  AccountId
	AccountID string `json:"accountId"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTag `json:"tags"`
	// Registry
	Registry *Registry `json:"registry"`
}

func (ImageRegistry) IsEntity() {}

// Image Registry Edge
type ImageRegistryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRegistry `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRegistryEdge) IsEdge() {}

//  ImageRegistryInput
type ImageRegistryOutput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest string `json:"repoDigest"`
	// Tags
	Tags []*ImageTagOutput `json:"tags"`
	// Registry
	Registry *RegistryOutput `json:"registry"`
}

// Images Registry Slice
type ImageRegistrySlice struct {
	// Image registry edges
	Edges []*ImageRegistryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRegistrySlice) IsSlice() {}

// Image Repo Tag entity
type ImageRepoTag struct {
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Created Date
	Created string `json:"created"`
	// Related binaries
	Binaries []*ImageBinary `json:"binaries"`
}

func (ImageRepoTag) IsEntity() {}

// Image repo tag Edge
type ImageRepoTagEdge struct {
	// Node contains the actual image repo tag data
	Node *ImageRepoTag `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepoTagEdge) IsEdge() {}

// Images repo tag Slice
type ImageRepoTagSlice struct {
	// Image Repository edges
	Edges []*ImageRepoTagEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepoTagSlice) IsSlice() {}

// Image Repository entity
type ImageRepository struct {
	// Image repository name
	Name string `json:"name"`
	// Account Id
	AccountID string `json:"accountId"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// Image repository registry domain types
	RegistryDomains []*ImageRegistryType `json:"registryDomains"`
}

func (ImageRepository) IsEntity() {}

// Image Repository Edge
type ImageRepositoryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRepository `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepositoryEdge) IsEdge() {}

// Images Repository Slice
type ImageRepositorySlice struct {
	// Image Repository edges
	Edges []*ImageRepositoryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepositorySlice) IsSlice() {}

// ImageTag
type ImageTag struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagOutput struct {
	// Registry
	Registry *string `json:"registry"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// Images Entity
type Images struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Issue value
type IssueValue struct {
	// Issue url
	URL string `json:"url"`
	// Issue title
	Title string `json:"title"`
	// Issue status
	Status string `json:"status"`
	// Issue assignee
	Assignee string `json:"assignee"`
}

// K8s entity id
type K8sEntityID struct {
	// name
	Name string `json:"name"`
	// namespace
	Namespace *string `json:"namespace"`
}

// Logic entity id
type LogicEntityID struct {
	// id
	ID string `json:"id"`
}

// Mapping between the var name and the path within event payload
type Mapping struct {
	// Name of the variable
	VarName string `json:"varName"`
	// Description of the variable
	Description string `json:"description"`
	// Template used to retrieve the variable value
	Template string `json:"template"`
	// Indication if the var can be used as a suggestion for additional filters configuration in the wizard
	Filter bool `json:"filter"`
}

// Pipeline metric with trend
type MetricWithTrend struct {
	// Metric value
	Value int `json:"value"`
	// Percent Diff between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName string `json:"templateName"`
	// Node children
	Children []*string `json:"children"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Message
	Message *string `json:"message"`
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Inputs
	Inputs *string `json:"inputs"`
	// Outputs
	Outputs *string `json:"outputs"`
	// Script
	Script *string `json:"script"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id"`
	// Resources Duration
	ResourcesDuration *string `json:"resourcesDuration"`
	// Template Ref
	TemplateRef *string `json:"templateRef"`
	// Host node name
	HostNodeName *string `json:"hostNodeName"`
	// Template
	Template *string `json:"template"`
	// Template scope
	TemplateScope *string `json:"templateScope"`
}

// Notification source entity
type Notification struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Relevant notification info according to the notification type
	NotificationInfo NotificationInfo `json:"notificationInfo"`
	// The specific notification type, to use for the notification icon
	NotificationType *NotificationType `json:"notificationType"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Projects
	Projects []string `json:"projects"`
}

// Notification Edge
type NotificationEdge struct {
	// Node contains the actual notification data
	Node *Notification `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Notification Slice
type NotificationSlice struct {
	// Notification edges
	Edges []*NotificationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description"`
	// Namespace
	Namespace *string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels"`
	// Annotations
	Annotations []*StringPair `json:"annotations"`
	// Last updated
	LastUpdated *string `json:"lastUpdated"`
	// Created
	Created *string `json:"created"`
	// K8s object uid
	UID *string `json:"uid"`
	// Favorite
	Favorite *bool `json:"favorite"`
}

// Permission model
type Permission struct {
	// The user with the permission
	User *User `json:"user"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Permission inoput
type PermissionInput struct {
	// The id of the user the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self"`
	// History of the pipeline
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity"`
}

func (Pipeline) IsBaseEntity()         {}
func (Pipeline) IsK8sLogicEntity()     {}
func (Pipeline) IsProjectBasedEntity() {}
func (Pipeline) IsEntity()             {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time"`
	// Committers
	Committers *int `json:"committers"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time"`
	// Executions
	Executions *int `json:"executions"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace string `json:"pipelineNamespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame"`
	// Success Rate stats
	SuccessRateStats *MetricWithTrend `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
}

// Pipeline Reference
type PipelineRef struct {
	// Id
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Project
	Project string `json:"project"`
	// ProjectId
	ProjectID string `json:"projectId"`
}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats"`
}

// Pipeline Step
type PipelineStepStatistics struct {
	// Step Name
	StepName *string `json:"stepName"`
	// Template Name
	TemplateName *string `json:"templateName"`
	// Workflow Template
	WorkflowTemplate *string `json:"workflowTemplate"`
	// Node Type
	NodeType *string `json:"nodeType"`
	// Step Average duration
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats"`
	// Step Executions count
	ExecutionsStats *MetricWithTrend `json:"executionsStats"`
	// Step Average CPU usage
	CPUStats *MetricWithTrend `json:"cpuStats"`
	// Step Average Memory
	MemoryStats *MetricWithTrend `json:"memoryStats"`
	// Step Errors count
	ErrorsCountStats *MetricWithTrend `json:"errorsCountStats"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time"`
	// Success rate
	SuccessRate *int `json:"successRate"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name"`
}

// Pod Spec
type PodSpec struct {
	// Containers
	Containers []*DeploymentContainer `json:"containers"`
}

// PodTemplate Spec
type PodTemplateSpec struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Spec
	Spec *PodSpec `json:"spec"`
}

// Predefined Date filter
type PredefinedDataFilter struct {
	// Predefined variable key
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
	// Comparator compares the event data with a user given value. if left blank treated as equality
	Comparator *Comparator `json:"comparator"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// PullRequest
type PullRequest struct {
	// Url
	URL string `json:"url"`
	// Title
	Title string `json:"title"`
	// Committers
	Committers []*CommitterLabel `json:"committers"`
}

// PullRequestCommitter
type PullRequestCommitter struct {
	// userName
	UserName string `json:"userName"`
	// avatar
	Avatar string `json:"avatar"`
}

// PullRequest value
type PullRequestValue struct {
	// url
	URL string `json:"url"`
	// title
	Title string `json:"title"`
	// committers
	Committers []*PullRequestCommitter `json:"committers"`
}

// Read file from a git repository args
type ReadFileArgs struct {
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName"`
	// Git reference name (branch/revision)
	Ref string `json:"ref"`
	// Repository full name in format {owner}/{name}
	Repo string `json:"repo"`
	// File full path
	Path string `json:"path"`
}

// Register to Git integration args
type RegisterToGitIntegrationArgs struct {
	// Git integration name, if not provided will use the default one
	Name *string `json:"name"`
	// Token
	Token string `json:"token"`
}

// Registry
type Registry struct {
	// Domain
	Domain string `json:"domain"`
	// Registry type
	Type ImageRegistryType `json:"type"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// Original Repository Prefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// RegistryInput
type RegistryOutput struct {
	// Id
	ID *string `json:"id"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix"`
}

// Release Entity
type Release struct {
	// Release version
	Version string `json:"version"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images"`
	// Replicas
	Replicas *int `json:"replicas"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Runtime Errors Report Arguments
type ReportRuntimeErrorsArgs struct {
	// Name of the Runtime
	Runtime string `json:"runtime"`
	// Errors
	Errors []*HealthErrorInput `json:"errors"`
}

// Repositories filter arguments
type RepositoriesFilterArgs struct {
	// Filter repository by name
	Name *string `json:"name"`
}

// Repositories Page
type RepositoriesPage struct {
	// An aray of Repositories in the page
	Data []*Repository `json:"data"`
	// Page number
	Page int `json:"page"`
	// How many repo in a page
	Count int `json:"count"`
	// Has next page?
	HasNext bool `json:"hasNext"`
}

// Repository
type Repository struct {
	// Repo id
	ID string `json:"id"`
	// Git provider
	Provider GitProviders `json:"provider"`
	// Repository full name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Is the repo private ?
	IsRepoPrivate bool `json:"isRepoPrivate"`
	// Last time a commit was pushed to one of the branches
	PushedAt string `json:"pushedAt"`
	// Number of open issues
	OpenIssues int `json:"openIssues"`
	// Clone url
	CloneURL string `json:"cloneUrl"`
	// ssh url
	SSHURL string `json:"sshUrl"`
	// Repo owner login
	OwnerLogin string `json:"ownerLogin"`
	// Repo owner avatar url
	OwnerAvatarURL string `json:"ownerAvatarUrl"`
	// Repo creator
	RepoCreator *string `json:"repoCreator"`
	// Organization name
	Org *string `json:"org"`
	// Default branch name
	DefaultBranch string `json:"defaultBranch"`
	// Has admin permissions ?
	IsRepoAdmin *bool `json:"isRepoAdmin"`
	// Repository url
	WebURL string `json:"webUrl"`
	// Project name
	Project *string `json:"project"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self"`
	// History of the runtime
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Projects
	Projects []string `json:"projects"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

func (Runtime) IsBaseEntity()         {}
func (Runtime) IsProjectBasedEntity() {}
func (Runtime) IsK8sLogicEntity()     {}
func (Runtime) IsEntity()             {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Cluster
	Cluster string `json:"cluster"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo"`
}

// Runtime notification
type RuntimeNotification struct {
	// Runtime component name
	ModifiedComponent *string `json:"modifiedComponent"`
	// Sync status
	RuntimeSyncStatus *SyncStatus `json:"runtimeSyncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
}

func (RuntimeNotification) IsNotificationInfo() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the sensor
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
}

func (Sensor) IsGitopsEntity()       {}
func (Sensor) IsBaseEntity()         {}
func (Sensor) IsProjectBasedEntity() {}
func (Sensor) IsEntity()             {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Service entity
type ServiceEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// ServiceSpec
	Spec *ServiceSpec `json:"spec"`
	// Deployment Spec Part
	Deployments []*DeploymentSpecPart `json:"deployments"`
}

func (ServiceEntity) IsGitopsEntity()       {}
func (ServiceEntity) IsBaseEntity()         {}
func (ServiceEntity) IsProjectBasedEntity() {}
func (ServiceEntity) IsEntity()             {}

// Service Entity Edge
type ServiceEntityEdge struct {
	// Node contains the actual Service data
	Node *ServiceEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ServiceEntityEdge) IsEdge() {}

// Service Slice
type ServiceEntitySlice struct {
	// Service edges
	Edges []*ServiceEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ServiceEntitySlice) IsSlice() {}

// Service Item Entity
type ServiceItem struct {
	// Name
	Name *string `json:"name"`
}

// ServicePort
type ServicePort struct {
	// AppProtocol
	AppProtocol *string `json:"appProtocol"`
	// Name
	Name *string `json:"name"`
	// NodePort
	NodePort *int `json:"nodePort"`
	// Port
	Port *int `json:"port"`
	// Protocol
	Protocol *string `json:"protocol"`
	// TargetPort
	TargetPort *string `json:"targetPort"`
}

// ServiceSpec
type ServiceSpec struct {
	// AllocateLoadBalancerNodePorts
	AllocateLoadBalancerNodePorts *bool `json:"allocateLoadBalancerNodePorts"`
	// ClusterIP
	ClusterIP *string `json:"clusterIP"`
	// ClusterIPs
	ClusterIPs []*string `json:"clusterIPs"`
	// ExternalIPs
	ExternalIPs []*string `json:"externalIPs"`
	// ExternalName
	ExternalName *string `json:"externalName"`
	// ExternalTrafficPolicy
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy"`
	// HealthCheckNodePort
	HealthCheckNodePort *int `json:"healthCheckNodePort"`
	// InternalTrafficPolicy
	InternalTrafficPolicy *string `json:"internalTrafficPolicy"`
	// IpFamilies
	IPFamilies []*string `json:"ipFamilies"`
	// IpFamilyPolicy
	IPFamilyPolicy *string `json:"ipFamilyPolicy"`
	// LoadBalancerClass
	LoadBalancerClass *string `json:"loadBalancerClass"`
	// LoadBalancerIP
	LoadBalancerIP *string `json:"loadBalancerIP"`
	// LoadBalancerSourceRanges
	LoadBalancerSourceRanges []*string `json:"loadBalancerSourceRanges"`
	// Ports
	Ports []*ServicePort `json:"ports"`
	// PublishNotReadyAddresses
	PublishNotReadyAddresses *bool `json:"publishNotReadyAddresses"`
	// Selector
	Selector []*StringPair `json:"selector"`
	// SessionAffinity
	SessionAffinity *string `json:"sessionAffinity"`
	// SessionAffinityConfig
	SessionAffinityConfig *SessionAffinityConfig `json:"sessionAffinityConfig"`
	// Type
	Type *ServiceType `json:"type"`
}

// ServiceTransition Entity
type ServiceTransition struct {
	// Name
	Name *string `json:"name"`
	// From
	From *ReleaseServiceState `json:"from"`
	// To
	To *ReleaseServiceState `json:"to"`
}

// SessionAffinityConfig
type SessionAffinityConfig struct {
	// ClientIP
	ClientIP *ClientIP `json:"clientIP"`
}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains"`
}

// Args to set the permissions of a specific user to a git-source
type SetGitSourcePermissionArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The new permission to set
	Permission *PermissionInput `json:"permission"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after"`
	// Returns entities before the provided cursor
	Before *string `json:"before"`
	// Returns the first X entities
	First *int `json:"first"`
	// Returns the last X entities
	Last *int `json:"last"`
}

// Source arguments
type SourceArgs struct {
	Github   []*GithubSourceArgs   `json:"github"`
	Calendar []*CalendarSourceArgs `json:"calendar"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType"`
	// Display name
	DisplayName *string `json:"displayName"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message"`
}

// Lable
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// Event filter
type SupportedEventMapping struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name     string     `json:"name"`
	Mappings []*Mapping `json:"mappings"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion"`
	// The entity related to this error
	Object BaseEntity `json:"object"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context"`
}

func (SyncError) IsError() {}

// To State Entity
type ToState struct {
	// Services
	Services []*ServiceItem `json:"services"`
}

// Transition Entity
type Transition struct {
	// Services
	Services []*ServiceTransition `json:"services"`
}

// Trigger parameter
type TriggerParameter struct {
	// Src contains a source reference to the value of the parameter from a dependency
	Src *TriggerParameterSource `json:"src"`
	// Name is the argument parameter name in the workflowTemplate
	Name string `json:"name"`
	// Operation is what to do with the existing value at Dest, whether to ‘prepend’, ‘overwrite’, or ‘append’ it
	Operation string `json:"operation"`
}

// Trigger parameter source
type TriggerParameterSource struct {
	// DataTemplate is a go-template for extracting a string from the event’s data. If a DataTemplate is provided with a DataKey, the template will be evaluated first and fallback to the DataKey. The templating follows the standard go-template syntax as well as sprig’s extra functions. See https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/. in addition you can pass a predefined varibles as the following ${{ VAR }} - assuming VAR is predefiend varaible or just a simple value as 'var'
	DataTemplate string `json:"dataTemplate"`
	// Value is the default literal value to use for this parameter source This is only used if the DataKey is invalid. If the DataKey is invalid and this is not defined, this param source will produce an error
	Value *string `json:"value"`
}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event source name
	EventSource *string `json:"eventSource"`
	// The relevant event name in the event source
	EventName *string `json:"eventName"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// Args to update the permissions of a git-source
type UpdateGitSourcePermissionsArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace"`
	// The set of permissions
	Permissions []*PermissionInput `json:"permissions"`
}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount"`
	// The customers that this user is in
	Customers []Customer `json:"customers"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate"`
	// User chosen sso of active account
	Sso *string `json:"sso"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []string `json:"eventsPayload"`
	// Pipeline refernece
	Pipeline *Pipeline `json:"pipeline"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Workflow URL
	URL *string `json:"url"`
}

func (Workflow) IsProjectBasedEntity() {}
func (Workflow) IsBaseEntity()         {}
func (Workflow) IsK8sStandardEntity()  {}
func (Workflow) IsEntity()             {}

// Workflow conditions
type WorkflowConditions struct {
	// Type
	Type *string `json:"type"`
	// Status
	Status *string `json:"status"`
}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name"`
	// Image
	Image *string `json:"image"`
	// Command array
	Command []*string `json:"command"`
	// Args
	Args []*string `json:"args"`
	// Env map
	Env []*StringPair `json:"env"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon"`
	// Container
	Container *WorkflowContainerSpec `json:"container"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// "Repository data for workflows
type WorkflowRepository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow resources duration
type WorkflowResourcesDuration struct {
	// Cpu
	CPU *int `json:"cpu"`
	// Memory
	Memory *int `json:"memory"`
}

// Response for resubmitting a workflow
type WorkflowResubmitResponse struct {
	// The newly created workflow name
	NewWorkflowName string `json:"newWorkflowName"`
}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt"`
	// Finish time
	FinishedAt *string `json:"finishedAt"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *string `json:"progress"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes"`
	// Message
	Message *string `json:"message"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Stored Templates
	StoredTemplates *string `json:"storedTemplates"`
	// Stored workflow template spec
	StoredWorkflowTemplateSpec *string `json:"storedWorkflowTemplateSpec"`
	// Conditions
	Conditions []*WorkflowConditions `json:"conditions"`
	// Resources duration
	ResourcesDuration *WorkflowResourcesDuration `json:"resourcesDuration"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// History of the workflow-template
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus"`
	// Health message
	HealthMessage *string `json:"healthMessage"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest"`
	// Projects
	Projects []string `json:"projects"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity()       {}
func (WorkflowTemplate) IsBaseEntity()         {}
func (WorkflowTemplate) IsProjectBasedEntity() {}
func (WorkflowTemplate) IsEntity()             {}

// Workflow template arguments
type WorkflowTemplateArgs struct {
	// Workflow template name
	Name string `json:"name"`
	// Workflow template entrypoint
	Entrypoint *string `json:"entrypoint"`
}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow template filter arguments
type WorkflowTemplatesFilterArgs struct {
	// Filter WorkflowTemplates from a specific project
	Project *string `json:"project"`
	// Filter WorkflowTemplates from a specific runtime
	Runtime *string `json:"runtime"`
	// Filter WorkflowTemplates by name
	Name *string `json:"name"`
	// Filter WorkflowTemplates by git source
	GitSource *string `json:"gitSource"`
}

// Comparator values - “>=”, “>”, “=”, “!=”, “<”, or “<=”.
type Comparator string

const (
	ComparatorGt  Comparator = "GT"
	ComparatorGte Comparator = "GTE"
	ComparatorEq  Comparator = "EQ"
	ComparatorNe  Comparator = "NE"
	ComparatorLt  Comparator = "LT"
	ComparatorLte Comparator = "LTE"
)

var AllComparator = []Comparator{
	ComparatorGt,
	ComparatorGte,
	ComparatorEq,
	ComparatorNe,
	ComparatorLt,
	ComparatorLte,
}

func (e Comparator) IsValid() bool {
	switch e {
	case ComparatorGt, ComparatorGte, ComparatorEq, ComparatorNe, ComparatorLt, ComparatorLte:
		return true
	}
	return false
}

func (e Comparator) String() string {
	return string(e)
}

func (e *Comparator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Comparator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Comparator", str)
	}
	return nil
}

func (e Comparator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Git providers
type GitProviders string

const (
	// Github
	GitProvidersGithub GitProviders = "GITHUB"
	// Gitlab
	GitProvidersGitlab GitProviders = "GITLAB"
)

var AllGitProviders = []GitProviders{
	GitProvidersGithub,
	GitProvidersGitlab,
}

func (e GitProviders) IsValid() bool {
	switch e {
	case GitProvidersGithub, GitProvidersGitlab:
		return true
	}
	return false
}

func (e GitProviders) String() string {
	return string(e)
}

func (e *GitProviders) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitProviders(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitProviders", str)
	}
	return nil
}

func (e GitProviders) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Runtime Installation error
	HealthErrorCodesRuntimeInstallationError HealthErrorCodes = "RUNTIME_INSTALLATION_ERROR"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesRuntimeInstallationError,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesRuntimeInstallationError, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image registry domain types
type ImageRegistryType string

const (
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeOther,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeOther:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// jSON types
type JSONTypes string

const (
	JSONTypesArray   JSONTypes = "Array"
	JSONTypesBoolean JSONTypes = "Boolean"
	JSONTypesNumber  JSONTypes = "Number"
	JSONTypesObject  JSONTypes = "Object"
	JSONTypesString  JSONTypes = "String"
)

var AllJSONTypes = []JSONTypes{
	JSONTypesArray,
	JSONTypesBoolean,
	JSONTypesNumber,
	JSONTypesObject,
	JSONTypesString,
}

func (e JSONTypes) IsValid() bool {
	switch e {
	case JSONTypesArray, JSONTypesBoolean, JSONTypesNumber, JSONTypesObject, JSONTypesString:
		return true
	}
	return false
}

func (e JSONTypes) String() string {
	return string(e)
}

func (e *JSONTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JSONTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JsonTypes", str)
	}
	return nil
}

func (e JSONTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification type
type NotificationType string

const (
	// Component health status is in progress
	NotificationTypeComponentHealthProgressing NotificationType = "COMPONENT_HEALTH_PROGRESSING"
	// Component health status is unhealthy
	NotificationTypeComponentHealthUnhealthy NotificationType = "COMPONENT_HEALTH_UNHEALTHY"
	// Component sync failed
	NotificationTypeComponentSyncFail NotificationType = "COMPONENT_SYNC_FAIL"
	// Component sync completed successfully
	NotificationTypeComponentSyncSuccess NotificationType = "COMPONENT_SYNC_SUCCESS"
	// Component sync is in progress
	NotificationTypeComponentSyncSyncing NotificationType = "COMPONENT_SYNC_SYNCING"
	// Git-source created
	NotificationTypeGsCreated NotificationType = "GS_CREATED"
	// Git-source sync removed
	NotificationTypeGsRemoved NotificationType = "GS_REMOVED"
	// Git-source sync failed
	NotificationTypeGsSyncFail NotificationType = "GS_SYNC_FAIL"
	// Git-source sync completed successfully
	NotificationTypeGsSyncSuccess NotificationType = "GS_SYNC_SUCCESS"
	// Git-source sync is in progress
	NotificationTypeGsSyncSyncing NotificationType = "GS_SYNC_SYNCING"
	// Runtime install failed
	NotificationTypeRuntimeInstallFail NotificationType = "RUNTIME_INSTALL_FAIL"
	// Runtime install is in progress
	NotificationTypeRuntimeInstallProgressing NotificationType = "RUNTIME_INSTALL_PROGRESSING"
	// Runtime install completed successfully
	NotificationTypeRuntimeInstallSuccess NotificationType = "RUNTIME_INSTALL_SUCCESS"
	// Runtime uninstall failed
	NotificationTypeRuntimeUninstallFail NotificationType = "RUNTIME_UNINSTALL_FAIL"
	// Runtime uninstall is in progress
	NotificationTypeRuntimeUninstallProgressing NotificationType = "RUNTIME_UNINSTALL_PROGRESSING"
	// Runtime uninstall completed successfully
	NotificationTypeRuntimeUninstallSuccess NotificationType = "RUNTIME_UNINSTALL_SUCCESS"
	// Runtime upgrade failed
	NotificationTypeRuntimeUpgradeFail NotificationType = "RUNTIME_UPGRADE_FAIL"
	// Runtime upgrade is in progress
	NotificationTypeRuntimeUpgradeProgressing NotificationType = "RUNTIME_UPGRADE_PROGRESSING"
	// Runtime upgrade completed successfully
	NotificationTypeRuntimeUpgradeSuccess NotificationType = "RUNTIME_UPGRADE_SUCCESS"
)

var AllNotificationType = []NotificationType{
	NotificationTypeComponentHealthProgressing,
	NotificationTypeComponentHealthUnhealthy,
	NotificationTypeComponentSyncFail,
	NotificationTypeComponentSyncSuccess,
	NotificationTypeComponentSyncSyncing,
	NotificationTypeGsCreated,
	NotificationTypeGsRemoved,
	NotificationTypeGsSyncFail,
	NotificationTypeGsSyncSuccess,
	NotificationTypeGsSyncSyncing,
	NotificationTypeRuntimeInstallFail,
	NotificationTypeRuntimeInstallProgressing,
	NotificationTypeRuntimeInstallSuccess,
	NotificationTypeRuntimeUninstallFail,
	NotificationTypeRuntimeUninstallProgressing,
	NotificationTypeRuntimeUninstallSuccess,
	NotificationTypeRuntimeUpgradeFail,
	NotificationTypeRuntimeUpgradeProgressing,
	NotificationTypeRuntimeUpgradeSuccess,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeComponentHealthProgressing, NotificationTypeComponentHealthUnhealthy, NotificationTypeComponentSyncFail, NotificationTypeComponentSyncSuccess, NotificationTypeComponentSyncSyncing, NotificationTypeGsCreated, NotificationTypeGsRemoved, NotificationTypeGsSyncFail, NotificationTypeGsSyncSuccess, NotificationTypeGsSyncSyncing, NotificationTypeRuntimeInstallFail, NotificationTypeRuntimeInstallProgressing, NotificationTypeRuntimeInstallSuccess, NotificationTypeRuntimeUninstallFail, NotificationTypeRuntimeUninstallProgressing, NotificationTypeRuntimeUninstallSuccess, NotificationTypeRuntimeUpgradeFail, NotificationTypeRuntimeUpgradeProgressing, NotificationTypeRuntimeUpgradeSuccess:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service Sorting field
type ServiceSortingField string

const (
	// Last Update
	ServiceSortingFieldLastUpdate ServiceSortingField = "lastUpdate"
	// Service Name
	ServiceSortingFieldServiceName ServiceSortingField = "serviceName"
)

var AllServiceSortingField = []ServiceSortingField{
	ServiceSortingFieldLastUpdate,
	ServiceSortingFieldServiceName,
}

func (e ServiceSortingField) IsValid() bool {
	switch e {
	case ServiceSortingFieldLastUpdate, ServiceSortingFieldServiceName:
		return true
	}
	return false
}

func (e ServiceSortingField) String() string {
	return string(e)
}

func (e *ServiceSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceSortingField", str)
	}
	return nil
}

func (e ServiceSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ServiceType
type ServiceType string

const (
	ServiceTypeClusterIP    ServiceType = "ClusterIP"
	ServiceTypeExternalName ServiceType = "ExternalName"
	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
	ServiceTypeNodePort     ServiceType = "NodePort"
)

var AllServiceType = []ServiceType{
	ServiceTypeClusterIP,
	ServiceTypeExternalName,
	ServiceTypeLoadBalancer,
	ServiceTypeNodePort,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeClusterIP, ServiceTypeExternalName, ServiceTypeLoadBalancer, ServiceTypeNodePort:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sharing policy
type SharingPolicy string

const (
	// Only account admins see this integration
	SharingPolicyAccountAdmins SharingPolicy = "ACCOUNT_ADMINS"
	// All users in account can see this integration
	SharingPolicyAllUsersInAccount SharingPolicy = "ALL_USERS_IN_ACCOUNT"
)

var AllSharingPolicy = []SharingPolicy{
	SharingPolicyAccountAdmins,
	SharingPolicyAllUsersInAccount,
}

func (e SharingPolicy) IsValid() bool {
	switch e {
	case SharingPolicyAccountAdmins, SharingPolicyAllUsersInAccount:
		return true
	}
	return false
}

func (e SharingPolicy) String() string {
	return string(e)
}

func (e *SharingPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SharingPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SharingPolicy", str)
	}
	return nil
}

func (e SharingPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting field
type SortingField string

const (
	// healthStatus
	SortingFieldHealthStatus SortingField = "healthStatus"
	// kind
	SortingFieldKind SortingField = "kind"
	// last deployment date
	SortingFieldLastUpdated SortingField = "lastUpdated"
	// name
	SortingFieldName SortingField = "name"
	// runtime
	SortingFieldRuntime SortingField = "runtime"
	// syncStatus
	SortingFieldSyncStatus SortingField = "syncStatus"
)

var AllSortingField = []SortingField{
	SortingFieldHealthStatus,
	SortingFieldKind,
	SortingFieldLastUpdated,
	SortingFieldName,
	SortingFieldRuntime,
	SortingFieldSyncStatus,
}

func (e SortingField) IsValid() bool {
	switch e {
	case SortingFieldHealthStatus, SortingFieldKind, SortingFieldLastUpdated, SortingFieldName, SortingFieldRuntime, SortingFieldSyncStatus:
		return true
	}
	return false
}

func (e SortingField) String() string {
	return string(e)
}

func (e *SortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingField", str)
	}
	return nil
}

func (e SortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting order
type SortingOrder string

const (
	// ascending
	SortingOrderAsc SortingOrder = "asc"
	// descending
	SortingOrderDesc SortingOrder = "desc"
)

var AllSortingOrder = []SortingOrder{
	SortingOrderAsc,
	SortingOrderDesc,
}

func (e SortingOrder) IsValid() bool {
	switch e {
	case SortingOrderAsc, SortingOrderDesc:
		return true
	}
	return false
}

func (e SortingOrder) String() string {
	return string(e)
}

func (e *SortingOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingOrder", str)
	}
	return nil
}

func (e SortingOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

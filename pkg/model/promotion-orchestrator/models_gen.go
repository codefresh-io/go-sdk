// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/codefresh-io/go-sdk/pkg/model"
)

// Analysis run spec object base fields
type AnalysisRunMetricSpecBase interface {
	IsAnalysisRunMetricSpecBase()
}

// Application tree item might be Application or ApplicationSet
type ApplicationTreeItem interface {
	IsApplicationTreeItem()
}

// ArgoCD Notification
type ArgoCDNotification interface {
	IsArgoCDNotification()
}

// ArgoEvents Notification
type ArgoEventsNotification interface {
	IsArgoEventsNotification()
}

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// Result of a single promotion policy resolution when resolved as a batch.
type BatchResolvePromotionPolicyResult interface {
	IsBatchResolvePromotionPolicyResult()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// Favorable
type Favorable interface {
	IsFavorable()
}

// Favorable
type FavorableNotK8s interface {
	IsFavorableNotK8s()
}

// Favorable Not K8s Entity
type FavorableNotK8sEntity interface {
	IsFavorableNotK8sEntity()
}

// Notification That is part of a process
type GitOpsNotification interface {
	IsGitOpsNotification()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	IsBaseEntity()
	IsGitopsEntity()
}

// IDP Entity
type IDP interface {
	IsIDP()
}

// Product Release step issue
type Issue interface {
	IsIssue()
}

// Issue kind options
type IssueKind interface {
	IsIssueKind()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Notification Base type
type Notification interface {
	IsNotification()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

type PromotionOrReleaseNode interface {
	IsPromotionOrReleaseNode()
}

// PromotionTemplateFields
type PromotionTemplateFields interface {
	IsPromotionTemplateFields()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// AbacAllActionsValidatedEntity
type AbacAllActionsValidatedEntityAction struct {
	// Action name
	Action AbacActionNames `json:"action"`
	// Enabled
	Enabled bool `json:"enabled"`
}

// AbacAllActionsValidationResult
type AbacAllActionsValidationResult struct {
	// Entity
	Entity string `json:"entity"`
	// Validation result
	ValidationResult []*AbacAllActionsValidatedEntityAction `json:"validationResult"`
}

// AbacAttribute
type AbacAttribute struct {
	// Name
	Name AbacAttributeNames `json:"name"`
	// Key
	Key *string `json:"key,omitempty"`
	// Value
	Value string `json:"value"`
}

// AbacValidationResult
type AbacValidationResult struct {
	// Is access validated
	IsValid bool `json:"isValid"`
	// Validation message
	Message *string `json:"message,omitempty"`
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name,omitempty"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features,omitempty"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations,omitempty"`
	// Users that are attached to this account
	Users []*User `json:"users,omitempty"`
	// Ids of all users that have account admin permission to this account
	Admins []string `json:"admins,omitempty"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains,omitempty"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains,omitempty"`
	// Account security
	Security *SecurityInfo `json:"security,omitempty"`
	// Collaborators
	Collaborators *AccountCollaborators `json:"collaborators,omitempty"`
	// Private account owner
	PrivateAccountOwner *string `json:"privateAccountOwner,omitempty"`
	// The git provider of the shared config repo
	GitProvider *GitProviders `json:"gitProvider,omitempty"`
	// The api url of the shared config repo git server
	GitAPIURL *string `json:"gitApiUrl,omitempty"`
	// Shared config repo url
	SharedConfigRepo *string `json:"sharedConfigRepo,omitempty"`
	// CSDP settings validated
	CsdpValidated *bool `json:"csdpValidated,omitempty"`
	// Features supported by all runtimes
	RuntimeFeatures []*RuntimeFeature `json:"runtimeFeatures"`
	// Supports Managed Runtime
	SupportsManagedRuntime *bool `json:"supportsManagedRuntime,omitempty"`
	// Pipeline settings
	PipelineConfig *PipelineConfig `json:"pipelineConfig,omitempty"`
	// System type
	SystemType *SystemType `json:"systemType,omitempty"`
	// System type prev
	SystemTypePrev *SystemType `json:"systemTypePrev,omitempty"`
	// Account badge token
	BadgeToken *string `json:"badgeToken,omitempty"`
	// Cloud Builds
	CloudBuilds *CloudBuilds `json:"cloudBuilds,omitempty"`
	// Account Settings
	Settings *AccountSettings `json:"settings,omitempty"`
	// Support Plan
	SupportPlan *SupportPlan `json:"supportPlan,omitempty"`
	// Payment Plan
	PaymentPlan *PaymentPlan `json:"paymentPlan,omitempty"`
}

// AccountCollaborators
type AccountCollaborators struct {
	// Limit
	Limit *int `json:"limit,omitempty"`
	// Used
	Used *int `json:"used,omitempty"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle,omitempty"`
	// Add ability to create/edit pipeline from UI in the configuration tab
	CreatePipelineArguments *bool `json:"createPipelineArguments,omitempty"`
	// Add ability to see workflow templates list page
	CsdpWorkflowTemplates *bool `json:"csdpWorkflowTemplates,omitempty"`
	// Add ability to see additonal widgets on the dashboard in home page
	CsdpDashboardWidgets *bool `json:"csdpDashboardWidgets,omitempty"`
	// Add ability to see and access DORA metrics page
	CsdpDoraMetrics *bool `json:"csdpDoraMetrics,omitempty"`
	// Add ability to see and access integration widgets on the dashboard
	CsdpManagedArgo *bool `json:"csdpManagedArgo,omitempty"`
	// Add ability to force reload route when navigation failed due to chunk error
	CsdpReloadOnChunkErrorFeature *bool `json:"csdpReloadOnChunkErrorFeature,omitempty"`
	// Show CSDP runtime resources in applications list
	ShowCSDPRuntimeResources *bool `json:"showCSDPRuntimeResources,omitempty"`
	// Shows button that links to classic codefresh
	ShowClassicCodefreshButton *bool `json:"showClassicCodefreshButton,omitempty"`
	// Support ability to use oauth2 for automatic registration
	Oauth2AutomaticRegistration *bool `json:"oauth2AutomaticRegistration,omitempty"`
	// Support ability to add integrations
	CsdpIntegrations *bool `json:"csdpIntegrations,omitempty"`
	// Support ability to add Amazon ECR integration
	CsdpAmazonECRIntegration *bool `json:"csdpAmazonECRIntegration,omitempty"`
	// Support ability to add authentications
	CsdpAuthentication *bool `json:"csdpAuthentication,omitempty"`
	// Adds ability to set SSH connection credentials to allow applications and sub modules to connect to a repository over SSH
	SupportSSHCreds *bool `json:"supportSSHCreds,omitempty"`
	// Gives access to application current state graph
	ShowAppCurrentStateGraph *bool `json:"showAppCurrentStateGraph,omitempty"`
	// Gives access to application release rollout details drawer
	ShowAppRolloutDetails *bool `json:"showAppRolloutDetails,omitempty"`
	// Gives access to application release analysis run details drawer
	ShowAppAnalysisRunsDetails *bool `json:"showAppAnalysisRunsDetails,omitempty"`
	// To build correct references beetween apps and appSets we always define metadata.cluster=https://kubernetes.default.svc because they always within same cluster
	UseDefaultSvcApplicationClusterMetadata *bool `json:"useDefaultSvcApplicationClusterMetadata,omitempty"`
	// Sets default codefresh authentication for runtime
	UseCodefreshAuthForManagedRuntime *bool `json:"useCodefreshAuthForManagedRuntime,omitempty"`
	// Retrieve runtime features for the active account
	CsdpRuntimesCompatibility *bool `json:"csdpRuntimesCompatibility,omitempty"`
	// Ability to sync application
	CsdpApplicationSync *bool `json:"csdpApplicationSync,omitempty"`
	// Ability to refresh application
	CsdpApplicationRefresh *bool `json:"csdpApplicationRefresh,omitempty"`
	// Adds ability to disable Sync from UI
	CsdpDisableSyncFromUI *bool `json:"csdpDisableSyncFromUi,omitempty"`
	// Ability to show application details
	CsdpApplicationDetails *bool `json:"csdpApplicationDetails,omitempty"`
	// Allows to send csdp audit events to classic platform
	CsdpAudit *bool `json:"csdpAudit,omitempty"`
	// Hides first release till it doesn't have attached rollout
	CsdpHideFirstRelease *bool `json:"csdpHideFirstRelease,omitempty"`
	// Applications dashboard cards view
	ApplicationsDashboardCardsView *bool `json:"applicationsDashboardCardsView,omitempty"`
	// Updated resources section in app release
	CsdpAppReleaseResourceDiff *bool `json:"csdpAppReleaseResourceDiff,omitempty"`
	// Application events tab
	ApplicationEventsTab *bool `json:"applicationEventsTab,omitempty"`
	// Ability to resume rollout
	CsdpRolloutResume *bool `json:"csdpRolloutResume,omitempty"`
	// Enable refresh token logic
	CsdpRefreshToken *bool `json:"csdpRefreshToken,omitempty"`
	// Adds ability to add jira oauth integration
	CsdpJiraOauthIntegration *bool `json:"csdpJiraOauthIntegration,omitempty"`
	// Supports GitLab for managed runtime
	GitlabSupportForManagedRuntime *bool `json:"gitlabSupportForManagedRuntime,omitempty"`
	// Supports Bitbucket for managed runtime
	BitbucketSupportForManagedRuntime *bool `json:"bitbucketSupportForManagedRuntime,omitempty"`
	// Adds ability to connect Gerrit as git provider
	SupportGerrit *bool `json:"supportGerrit,omitempty"`
	// Show new errors drawer for runtime
	NewRuntimeErrorsDrawer *bool `json:"newRuntimeErrorsDrawer,omitempty"`
	// Adds manifest field to resource tree object (temporary)
	ResourceTreeWithManifest *bool `json:"resourceTreeWithManifest,omitempty"`
	// Show require pruning label to resource
	RequirePruningLabelToResource *bool `json:"requirePruningLabelToResource,omitempty"`
	// Disables all actions for rollout resource: in playe (rollout details drawer), current state (three dot menu), release / services / section
	DisableRolloutActionsWithoutRbac *bool `json:"disableRolloutActionsWithoutRBAC,omitempty"`
	// Gives access to Modules page with sidemenu settings
	ModulesConfigurationPage *bool `json:"modulesConfigurationPage,omitempty"`
	// UI Execution Context page in the account settings
	ExecutionContext *bool `json:"executionContext,omitempty"`
	// Account has ABAC support
	Abac *bool `json:"abac,omitempty"`
	// New ABAC permissions page
	AbacV2 *bool `json:"abacV2,omitempty"`
	// Adds ability to rollback rollout from rollout drawer in app timeline
	GitOpsRolloutRollback *bool `json:"gitOpsRolloutRollback,omitempty"`
	// Shows Beamer widget for all platforms (What's new)
	BeamerWidget *bool `json:"beamerWidget,omitempty"`
	// Enables codefreshV2 for admins
	CodefreshV2 *bool `json:"codefreshV2,omitempty"`
	// Enables codefreshV2 for non admins
	CodefreshV2NonAdmins *bool `json:"codefreshV2NonAdmins,omitempty"`
	// Adds ability for account admins to switch account type
	ProjectOneSwitch *bool `json:"projectOneSwitch,omitempty"`
	// Adds ability to expand graph
	GraphExpand *bool `json:"graphExpand,omitempty"`
	// Theme configurations depend on systemType & prevSystemType fields
	ProjectOneSystemTypes *bool `json:"projectOneSystemTypes,omitempty"`
	// Shows gitops page in classic
	EnvironmentsV2Flag *bool `json:"environmentsV2Flag,omitempty"`
	// Shows gitOps home dashboard inside the project one menu only for gitOps users
	ShowGitOpsHomeDashboardInTheProjectOneMenu *bool `json:"showGitOpsHomeDashboardInTheProjectOneMenu,omitempty"`
	// Enables Unified Dashboard for Project One
	CommonDashboardProjectOne *bool `json:"commonDashboardProjectOne,omitempty"`
	// Adds ability to rollback release in native argo cd way
	GitopsArgoCdRollback *bool `json:"gitopsArgoCdRollback,omitempty"`
	// Enables CommandBar in the client
	Commandbar *bool `json:"commandbar,omitempty"`
	// Adds ability to group applications by annotation 'codefresh.io/app-group'
	GitopsAppGroups *bool `json:"gitopsAppGroups,omitempty"`
	// Enables environments view for gitops platform
	GitopsEnvironments *bool `json:"gitopsEnvironments,omitempty"`
	// Adds ability to copy link with account specific info
	AccountInfoCopyButton *bool `json:"accountInfoCopyButton,omitempty"`
	// Allows the creation of a restricted git source
	RestrictedGitSource *bool `json:"restrictedGitSource,omitempty"`
	// When enabled, the UI will use system fonts instead of custom fonts
	SystemFonts *bool `json:"systemFonts,omitempty"`
	// Enables Codefresh to track user activity with Fullstory in the UI
	Fullstory *bool `json:"fullstory,omitempty"`
	// Enables showing Delighted CX surveys in the UI
	DelightedSurvey *bool `json:"delightedSurvey,omitempty"`
	// Enables environments view used in the classic platform
	ClassicEnvironments *bool `json:"classicEnvironments,omitempty"`
	// Hide git-sources and related applications without git permissions and when permissions are not provided
	CsdpFilterAppsByGitPermissions *bool `json:"csdpFilterAppsByGitPermissions,omitempty"`
	// Gitops Application Tree optimization. It will use improved MongoDB agregation pipeline when enabled. Gitops apps and app sets will be extracted from DB without heavy manifest fields (when need to read >2k items)
	CsdpAppAndAppSetWithoutManifestFields *bool `json:"csdpAppAndAppSetWithoutManifestFields,omitempty"`
	// Hide Compositions item in navigation menu
	HideCompositionsMenuItem *bool `json:"hideCompositionsMenuItem,omitempty"`
	// Hide Helm Boards item in navigation menu
	HideHelmBoardsMenuItem *bool `json:"hideHelmBoardsMenuItem,omitempty"`
	// Hide Kubernetes Services item in navigation menu
	HideKubernetesServicesMenuItem *bool `json:"hideKubernetesServicesMenuItem,omitempty"`
	// Hide Helm Releases item in navigation menu
	HideHelmReleasesMenuItem *bool `json:"hideHelmReleasesMenuItem,omitempty"`
	// Hide Helm Charts item in navigation menu
	HideHelmChartsMenuItem *bool `json:"hideHelmChartsMenuItem,omitempty"`
	// Hide all pipelines-related menu items.
	HidePipelinesMenuItems *bool `json:"hidePipelinesMenuItems,omitempty"`
	// Hide usage menu item.
	HideUsageMenuItem *bool `json:"hideUsageMenuItem,omitempty"`
	// Hide images menu item.
	HideImagesMenuItem *bool `json:"hideImagesMenuItem,omitempty"`
	// Hide ability to manage apps directly from the product view
	HideProductManageApps *bool `json:"hideProductManageApps,omitempty"`
	// Shows promotion workflows in the application menu
	PromotionWorkflows *bool `json:"promotionWorkflows,omitempty"`
	// Allows product components to be draggable and enables a promotion flow
	PromotionFlow *bool `json:"promotionFlow,omitempty"`
	// Feature provides a visual representation of the differences between the normalizedLiveState and predictedLiveState
	AppDiffView *bool `json:"appDiffView,omitempty"`
	// Install hosted runtimes using the gitops runtime helm chart
	HelmHostedRuntime *bool `json:"helmHostedRuntime,omitempty"`
	// Enables usage of argo-platform-broadcaster service instead of api-graphql for subscriptions
	APIBroadcasterEnabled *bool `json:"apiBroadcasterEnabled,omitempty"`
	// Enables promotion flows view
	PromotionFlowsManagement *bool `json:"promotionFlowsManagement,omitempty"`
	// Enables ability to display application info from AppProxy
	HeaderLiveState *bool `json:"headerLiveState,omitempty"`
	// Enables promotion orchestration for products including product's releases API and promotion flow API
	PromotionOrchestration *bool `json:"promotionOrchestration,omitempty"`
	// Enables the main releases page, allowing users to view releases from all products
	MainReleasesPage *bool `json:"mainReleasesPage,omitempty"`
	// Enables promotion policies view
	PromotionPolicies *bool `json:"promotionPolicies,omitempty"`
	// Enables git commit statuses for product release promotions
	PromotionCommitStatuses *bool `json:"promotionCommitStatuses,omitempty"`
	// Enables ability to display runtime observability
	GitopsRuntimeObservability *bool `json:"gitopsRuntimeObservability,omitempty"`
	// When enabled instead of showing the account switch dialog the account will automatically be switched
	AutoBuildSwitchAccount *bool `json:"autoBuildSwitchAccount,omitempty"`
	// Enables ability to display rolloout + analysis run info from AppProxy
	RolloutPlayerLiveState *bool `json:"rolloutPlayerLiveState,omitempty"`
	// Enables Product CRD functionality
	ProductCrd *bool `json:"productCRD,omitempty"`
	// Enables ability to create a shared service account user that's not tied to any specific person and holds account api-keys
	ServiceAccounts *bool `json:"serviceAccounts,omitempty"`
	// This flag is used for performance optimization to retrieve references via findAll instead of findOne (in batch by resource kind)
	BatchRefsResolvmentAPIGraphql *bool `json:"batchRefsResolvmentApiGraphql,omitempty"`
	// When enabled UI prevents user from doing forbidden actions or selecting forbidden options
	AbacV2UIEnforcement *bool `json:"abacV2UIEnforcement,omitempty"`
	// Limit amount of applicationTree with errors requests
	LimitAmountOfApplicationTreeWithErrorsRequests *bool `json:"limitAmountOfApplicationTreeWithErrorsRequests,omitempty"`
	// Show new logo
	NewLogo *bool `json:"newLogo,omitempty"`
	// Show welcome screen in Project One
	WelcomeScreenProjectOne *bool `json:"welcomeScreenProjectOne,omitempty"`
	// A component that displays YAML as a tree, allowing users to select a path and generate a corresponding JSONPath from it.
	YamlTreeJSONPathBuilder *bool `json:"yamlTreeJsonPathBuilder,omitempty"`
	// Dynamically expand the current state chart nodes based on their content
	CurrentStateNodeExpand *bool `json:"currentStateNodeExpand,omitempty"`
	// Shows gitOps Groups page
	GitopsGroupsPage *bool `json:"gitopsGroupsPage,omitempty"`
	// Adds UX tips to GitOps platform in order to improve user flow and provide better onboarding.
	GitopsOnboarding *bool `json:"gitopsOnboarding,omitempty"`
	// Enables new runtime installation flow wizard
	RuntimeInstallationWizard *bool `json:"runtimeInstallationWizard,omitempty"`
	// Enables ArgoHub welcome screen.
	ArgoHubWelcomeScreen *bool `json:"argoHubWelcomeScreen,omitempty"`
	// Enables ArgoHub payments view.
	ArgoHubPayments *bool `json:"argoHubPayments,omitempty"`
	// Enables audit view.
	Auditing *bool `json:"auditing,omitempty"`
	// Disabling app-proxy Apollo's queryDeduplication feature.
	DisableAppProxyApolloQueryDeduplication *bool `json:"disableAppProxyApolloQueryDeduplication,omitempty"`
	// Enables Promotion Hooks
	PromotionHooks *bool `json:"promotionHooks,omitempty"`
	// Enables Workflow Pipelines page
	WorkflowPipelinesPage *bool `json:"workflowPipelinesPage,omitempty"`
	// Enables new users and teams pages
	NewUsersAndTeamsPages *bool `json:"newUsersAndTeamsPages,omitempty"`
	// Hide activity logs
	HideActivityLogsFeature *bool `json:"hideActivityLogsFeature,omitempty"`
	// Hide classic related sections from user settings
	HideClassicRelatedSectionsFromUserSettings *bool `json:"hideClassicRelatedSectionsFromUserSettings,omitempty"`
	// Disabling ability to add Codefresh CI integration in GitOps
	HideCodefreshCIIntegration *bool `json:"hideCodefreshCIIntegration,omitempty"`
	// Hides modules column in the modules page
	HideModulesSelection *bool `json:"hideModulesSelection,omitempty"`
	// Enables unmapped apps view in the product view
	UnmappedAppsProductView *bool `json:"unmappedAppsProductView,omitempty"`
	// Hide native workflow link
	HideNativeWorkflowLink *bool `json:"hideNativeWorkflowLink,omitempty"`
	// Enable enforcement according to GitOps Plan. Includes monitoring resource limits and disabling actions, showing banners when plan limits reached.
	GitopsPlanEnforcement *bool `json:"gitopsPlanEnforcement,omitempty"`
	// Hides delete, resubmit, terminate and suspend workflow actions
	HideWorkflowActions *bool `json:"hideWorkflowActions,omitempty"`
	// Use only Github repository for ISC
	IscGithubRepo *bool `json:"iscGithubRepo,omitempty"`
	// Enables new products list view
	NewProductsList *bool `json:"newProductsList,omitempty"`
	// Moves the helpHub to the sidebar
	HelpHubInSidebar *bool `json:"helpHubInSidebar,omitempty"`
	// Enable enforcement according to GitOps Plan. Includes locking user on billing page when not paying.
	GitopsFreePlanEnforcement *bool `json:"gitopsFreePlanEnforcement,omitempty"`
	// Enables grouped mode for environments view
	GitopsEnvironmentsGroupedMode *bool `json:"gitopsEnvironmentsGroupedMode,omitempty"`
	// Adds ability to promote files from relative path
	RelativeFilesPromotions *bool `json:"relativeFilesPromotions,omitempty"`
	// Adds ability to connect Gitlab as git provider in runtime installation wizard
	GitlabSupportInRuntimeWizard *bool `json:"gitlabSupportInRuntimeWizard,omitempty"`
	// Adds ability to connect Bitbucket as git provider in runtime installation wizard
	BitbucketSupportInRuntimeWizard *bool `json:"bitbucketSupportInRuntimeWizard,omitempty"`
	// Shows warning message that promotions are in early access
	PromotionsEarlyAccessWarning *bool `json:"promotionsEarlyAccessWarning,omitempty"`
	// Enables new user settings page based on Gitops UI under /2.0 path
	NewUserSettingsPage *bool `json:"newUserSettingsPage,omitempty"`
	// Hides classic-only related sections from new user settings page
	HideClassicRelatedSectionsFromNewUserSettingsPage *bool `json:"hideClassicRelatedSectionsFromNewUserSettingsPage,omitempty"`
	// Uses new endpoints for retrieval of product promotions(releases) across all corresponding views.
	NewPromotionEndpoints *bool `json:"newPromotionEndpoints,omitempty"`
	// Enables product CRD commit flow
	ProductCRDCommitFlow *bool `json:"productCRDCommitFlow,omitempty"`
	// Disables the application tree if the number of applications exceeds the limit. The limit can be overridden using the APPLICATION_TREE_SIZE_LIMIT variable
	DisableApplicationTreeViewForLargeTrees *bool `json:"disableApplicationTreeViewForLargeTrees,omitempty"`
	// Enable support for runtime release channels. Use pre-computed release data from GitHub Pages instead of GitHub API.
	UseRuntimeUpdateChannels *bool `json:"useRuntimeUpdateChannels,omitempty"`
}

// Account Gitops Usage
type AccountGitopsUsage struct {
	// UpdatedAt
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Applications
	Applications *UsageState `json:"applications,omitempty"`
	// Clusters
	Clusters *UsageState `json:"clusters,omitempty"`
}

// Account Settings will hold a generic object with settings used by the UI
type AccountSettings struct {
	// Account Settings
	Settings string `json:"settings"`
	// Schema Version
	SchemaVersion string `json:"schemaVersion"`
	// Updated At
	UpdatedAt time.Time `json:"updatedAt"`
}

// Account Usage
type AccountUsage struct {
	// Applications counter
	Applications int `json:"applications"`
	// Clusters counter
	Clusters int `json:"clusters"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso,omitempty"`
}

// Arguments to create an ad-hoc release with a commit
type AhHocProductReleaseCommitFilesArgs struct {
	// Application Id
	AppID *ApplicationIDInput `json:"appId"`
	// Commit messege
	Msg *string `json:"msg,omitempty"`
	// Commit Description
	Description *string `json:"description,omitempty"`
	// Files
	Files []*File `json:"files"`
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName,omitempty"`
}

// Arguments to create an ad-hoc release with a Pull Request
type AhHocProductReleasePullRequestFilesArgs struct {
	// Application Id
	AppID *ApplicationIDInput `json:"appId"`
	// Branch name
	Head *string `json:"head,omitempty"`
	// Pull request title
	Title *string `json:"title,omitempty"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Commit messege
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Commit Description
	CommitDescription *string `json:"commitDescription,omitempty"`
	// Files
	Files []*File `json:"files"`
	// Git integration name, if not provided will use the default one
	IntegrationName *string `json:"integrationName,omitempty"`
}

// Arguments to create an ad-hoc promotion with a commit
type AhHocPromotionCommitFilesArgs struct {
	// Application Id
	AppID *ApplicationIDInput `json:"appId"`
	// Commit message
	Msg *string `json:"msg,omitempty"`
	// Commit Description
	Description *string `json:"description,omitempty"`
}

// Arguments to create an ad-hoc promotion with a Pull Request
type AhHocPromotionPullRequestFilesArgs struct {
	// Application Id
	AppID *ApplicationIDInput `json:"appId"`
	// Branch name
	Head *string `json:"head,omitempty"`
	// Pull request title
	Title *string `json:"title,omitempty"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Commit Description
	CommitDescription *string `json:"commitDescription,omitempty"`
}

// AnalysisRun
type AnalysisRun struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Live manifest
	LiveManifest *string `json:"liveManifest,omitempty"`
	// Rollout revision
	Revision int `json:"revision"`
	// Analysis Run Status
	Status *AnalysisRunStatus `json:"status"`
	// Analysis Run spec
	Spec *AnalysisRunSpec `json:"spec"`
}

func (AnalysisRun) IsK8sStandardEntity() {}

func (AnalysisRun) IsEntity() {}

// Analysis Datadog Spec
type AnalysisRunDatadogSpec struct {
	// Query
	Query string `json:"query"`
}

// AnalysisRun Edge
type AnalysisRunEdge struct {
	// Node contains the actual analysis run data
	Node *AnalysisRun `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (AnalysisRunEdge) IsEdge() {}

// Analysis Kayenta Spec
type AnalysisRunKayentaSpec struct {
	// Address
	Address string `json:"address"`
}

// Analysis run spec object
type AnalysisRunMetricSpec struct {
	// Name
	Name string `json:"name"`
	// Interval
	Interval *string `json:"interval,omitempty"`
	// Success Condition
	SuccessCondition *string `json:"successCondition,omitempty"`
	// Failure Condition
	FailureCondition *string `json:"failureCondition,omitempty"`
	// Failure Limit
	FailureLimit *string `json:"failureLimit,omitempty"`
	// Inconclusive Limit
	InconclusiveLimit *string `json:"inconclusiveLimit,omitempty"`
	// Consecutive Error Limit
	ConsecutiveErrorLimit *string `json:"consecutiveErrorLimit,omitempty"`
	// Count
	Count *string `json:"count,omitempty"`
	// Initial Delay
	InitialDelay *string `json:"initialDelay,omitempty"`
	// Analysis run spec object calculated - after processing template variables
	CalculatedValues *AnalysisRunMetricSpecCalculated `json:"calculatedValues,omitempty"`
	// Provider
	Provider *AnalysisRunProviderSpec `json:"provider"`
}

func (AnalysisRunMetricSpec) IsAnalysisRunMetricSpecBase() {}

// Analysis run spec object with calculated values - all fields conditinal
type AnalysisRunMetricSpecCalculated struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Interval
	Interval *string `json:"interval,omitempty"`
	// Success Condition
	SuccessCondition *string `json:"successCondition,omitempty"`
	// Failure Condition
	FailureCondition *string `json:"failureCondition,omitempty"`
	// Failure Limit
	FailureLimit *string `json:"failureLimit,omitempty"`
	// Inconclusive Limit
	InconclusiveLimit *string `json:"inconclusiveLimit,omitempty"`
	// Consecutive Error Limit
	ConsecutiveErrorLimit *string `json:"consecutiveErrorLimit,omitempty"`
	// Count
	Count *string `json:"count,omitempty"`
	// Initial Delay
	InitialDelay *string `json:"initialDelay,omitempty"`
}

func (AnalysisRunMetricSpecCalculated) IsAnalysisRunMetricSpecBase() {}

// Analysis NewRelic Spec
type AnalysisRunNewRelicSpec struct {
	// Query
	Query string `json:"query"`
}

// Analysis Run Prometheus spec
type AnalysisRunPrometheusSpec struct {
	// Address
	Address string `json:"address"`
	// Query
	Query string `json:"query"`
}

// Analysis status object
type AnalysisRunProviderSpec struct {
	// Job
	Job *string `json:"job,omitempty"`
	// Prometheus
	Prometheus *AnalysisRunPrometheusSpec `json:"prometheus,omitempty"`
	// Datadog
	Datadog *AnalysisRunDatadogSpec `json:"datadog,omitempty"`
	// New Relic
	NewRelic *AnalysisRunNewRelicSpec `json:"newRelic,omitempty"`
	// Wavefront
	Wavefront *AnalysisRunWavefrontSpec `json:"wavefront,omitempty"`
	// Web
	Web *AnalysisRunWebSpec `json:"web,omitempty"`
	// Kayenta
	Kayenta *AnalysisRunKayentaSpec `json:"kayenta,omitempty"`
	// Cloud Watch
	CloudWatch *string `json:"cloudWatch,omitempty"`
}

// AnalysisRun Slice
type AnalysisRunSlice struct {
	// Analysis run edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (AnalysisRunSlice) IsSlice() {}

// Analysis run spec metrics
type AnalysisRunSpec struct {
	// Metrics
	Metrics []*AnalysisRunMetricSpec `json:"metrics"`
}

// Analysis status object
type AnalysisRunStatus struct {
	// Message
	Message *string `json:"message,omitempty"`
	// Metric results
	MetricResults []*MetricResult `json:"metricResults"`
	// Total Successful
	TotalSuccessful int `json:"totalSuccessful"`
	// Total Failed
	TotalFailed int `json:"totalFailed"`
	// Total Inconclusive
	TotalInconclusive int `json:"totalInconclusive"`
	// Total Error
	TotalError int `json:"totalError"`
	// Entire state of analysis
	Phase *AnalysisPhases `json:"phase,omitempty"`
}

// Analysis Wavefront Spec
type AnalysisRunWavefrontSpec struct {
	// Address
	Address string `json:"address"`
	// Query
	Query string `json:"query"`
}

// Analysis Web Spec
type AnalysisRunWebSpec struct {
	// Url
	URL string `json:"url"`
}

// Analytics app group dropdown list
type AnalyticsAppGroupList struct {
	// App Groups
	AppGroups []string `json:"appGroups"`
}

// Analytics application dropdown list
type AnalyticsApplicationsList struct {
	// Applications
	Applications []string `json:"applications"`
}

// Classic Analytics Pipeline Dropdown
type AnalyticsClassicPipeline struct {
	// Pipeline Id
	PipelineID string `json:"pipelineId"`
	// Pipeline Name
	PipelineName string `json:"pipelineName"`
	// Pipeline Full Name
	PipelineFullName string `json:"pipelineFullName"`
	// Is pipeline deleted
	IsDeleted bool `json:"isDeleted"`
}

// Classic Analytics Pipeline Tags Dropdown
type AnalyticsClassicPipelineTag struct {
	// Tag Id
	TagID string `json:"tagId"`
	// Tag Name
	TagName string `json:"tagName"`
}

// Analytics classic pipelines dropdown list
type AnalyticsClassicPipelinesList struct {
	// Pipelines
	Pipelines []*AnalyticsClassicPipeline `json:"pipelines"`
}

// Classic Analytics Proejcts Dropdown
type AnalyticsClassicProject struct {
	// Project Id
	ProjectID string `json:"projectId"`
	// Project Name
	ProjectName string `json:"projectName"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Analytics classic projects dropdown list
type AnalyticsClassicProjectsList struct {
	// Projects
	Projects []*AnalyticsClassicProject `json:"projects"`
}

// Analytics classic pipelines dropdown list
type AnalyticsClassicTagsList struct {
	// Tags
	Tags []*AnalyticsClassicPipelineTag `json:"tags"`
}

// Analytics cluster dropdown list
type AnalyticsClustersList struct {
	// Cluster Names
	ClusterNamesList []*ClusterNamesDDRecord `json:"clusterNamesList"`
	// Cluster Names
	ClusterUrlsList []*ClusterURLDDRecord `json:"clusterUrlsList"`
}

// Analytics environment dropdown list
type AnalyticsEnvironmentList struct {
	// Environments
	Environments []string `json:"environments"`
}

// Analytics product dropdown list
type AnalyticsProductList struct {
	// Products
	Products []string `json:"products"`
}

// Analytics runtime dropdown list
type AnalyticsRuntimesList struct {
	// Runtimes
	RuntimeNames []string `json:"runtimeNames"`
}

// Annotation
type Annotation struct {
	// Annotation id
	ID *string `json:"id,omitempty"`
	// Annotation type
	Type string `json:"type"`
	// Annotation value
	Value *string `json:"value,omitempty"`
	// Annotation accountId
	AccountID *string `json:"accountId,omitempty"`
	// Annotation classicId
	ClassicID *string `json:"classicId,omitempty"`
	// Annotation entityId
	EntityID string `json:"entityId"`
	// Annotation entityType
	EntityType string `json:"entityType"`
	// Annotation key
	Key string `json:"key"`
}

// Args to set annotation for entity
type AnnotationArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId,omitempty"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId,omitempty"`
	// Event-source entityType
	EntityType string `json:"entityType"`
	// Event-source key
	Key string `json:"key"`
	// Event-source type
	Type string `json:"type"`
	// Annotation classicId
	ClassicID *string `json:"classicId,omitempty"`
	// Event-source issueValue
	IssueValue *IssueValue `json:"issueValue,omitempty"`
	// Event-source pullRequestValue
	PullRequestValue *PullRequestValue `json:"pullRequestValue,omitempty"`
	// Event-source genericValue
	GenericValue *string `json:"genericValue,omitempty"`
}

// Application Edge
type AnnotationEdge struct {
	// Node contains the actual application data
	Node *Annotation `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter annotation
type AnnotationFilterArgs struct {
	// Event-source id
	ID *string `json:"id,omitempty"`
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId,omitempty"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId,omitempty"`
	// Event-source entityType
	EntityType *string `json:"entityType,omitempty"`
	// Annotation classicId
	ClassicID *string `json:"classicId,omitempty"`
	// Event-source key
	Key *string `json:"key,omitempty"`
	// Event-source type
	Type *string `json:"type,omitempty"`
}

// Annotation Slice
type AnnotationSlice struct {
	// Annotation edges
	Edges []*AnnotationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// ApiKey
type APIKey struct {
	// ApiKey id
	ID string `json:"id"`
	// ApiKey name
	Name string `json:"name"`
	// ApiKey tokenPrefix
	TokenPrefix string `json:"tokenPrefix"`
	// ApiKey scopes
	Scopes []*string `json:"scopes"`
	// ApiKey scopeSnapshot
	ScopeSnapshot *APIKeyScopeSnapshot `json:"scopeSnapshot,omitempty"`
	// ApiKey subject
	Subject *APIKeySubject `json:"subject"`
	// ApiKey created
	Created *string `json:"created,omitempty"`
}

// ApiKeyArgs
type APIKeyArgs struct {
	// ApiKey name
	Name string `json:"name"`
	// ApiKey scopes
	Scopes []*string `json:"scopes"`
}

// "ApiKeyScope Entity
type APIKeyScope struct {
	// Resource full access scope name
	Name string `json:"name"`
	// Resource full access description
	Description string `json:"description"`
	// Resource full access title
	Title string `json:"title"`
	// Resource other scopes
	Scopes []*APIKeyScope `json:"scopes"`
}

// ApiKeyScopeSnapshot
type APIKeyScopeSnapshot struct {
	// ApiKeyScopeSnapshot ID
	ID string `json:"id"`
	// ApiKeyScopeSnapshot scopes
	Scopes []*string `json:"scopes"`
	// ApiKeyScopeSnapshot date
	Date *string `json:"date,omitempty"`
}

// ApiKeySubject
type APIKeySubject struct {
	// ApiKeySubject type
	Type *string `json:"type,omitempty"`
	// ApiKeySubject ref
	Ref *string `json:"ref,omitempty"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token,omitempty"`
}

// AppAndAppSet Edge
type AppAndAppSetEdge struct {
	// Node contains the actual application data
	Node ApplicationTreeItem `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// AppAndAppSet Slice
type AppAndAppSetSlice struct {
	// Application edges
	Edges []*AppAndAppSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// App Info Issue
type AppInfoIssue struct {
	// Issue Date
	Date string `json:"date"`
	// Issue message
	Message string `json:"message"`
	// Issue error level
	Level ErrorLevels `json:"level"`
	// Issue type
	Type IssueType `json:"type"`
	// Issue Sync Status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
	// Issue Health Status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Issue Resource Metadata
	ApplicationResourceMetadata *ResourceMetadata `json:"applicationResourceMetadata,omitempty"`
}

// RestrictedGitSource destination
type AppProjectDestination struct {
	// The destination server name (CAN NOT contain wildcards)
	Name *string `json:"name,omitempty"`
	// The destination server url (can contain wildcards)
	Server *string `json:"server,omitempty"`
	// The destination namespace (can contain wildcards)
	Namespace string `json:"namespace"`
}

// App-Proxy Info
type AppProxyInfo struct {
	// Description
	Description *string `json:"description,omitempty"`
	// Status
	Status AppProxyStatus `json:"status"`
}

// AppResourceDifference
type AppResourceDifference struct {
	// Current record
	CurrentRecord *AppResourceDifferenceRecord `json:"currentRecord"`
	// Previous record
	PreviousRecord *AppResourceDifferenceRecord `json:"previousRecord,omitempty"`
}

// AppResourceDifferenceRecord
type AppResourceDifferenceRecord struct {
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
}

// Repo Resource Manifest response input
type AppResourceGitManifestInput struct {
	// Resource git manifest
	Content string `json:"content"`
	// Resource source
	Source *RepoResourceSourceInput `json:"source"`
	// Synced revision metadata
	SyncedRevisionMetadata *SyncedRevisionMetadataInput `json:"syncedRevisionMetadata,omitempty"`
}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations,omitempty"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission,omitempty"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Updated At
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// RepoURL
	RepoURL *string `json:"repoURL,omitempty"`
	// Number of resources
	Size *int `json:"size,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Argo CD application destination config
	Destination *ArgoCDApplicationDestination `json:"destination,omitempty"`
	// Argo CD application spec source config
	SpecSource *ArgoCDApplicationSpecSource `json:"specSource,omitempty"`
	// Argo CD application spec sources config
	SpecSources []*ArgoCDApplicationSpecSource `json:"specSources,omitempty"`
	// Include files
	Include *string `json:"include,omitempty"`
	// Exclude files
	Exclude *string `json:"exclude,omitempty"`
	// Operation State (argo)
	OperationState *ApplicationOperationState `json:"operationState,omitempty"`
	// Sync info (argo)
	Sync *ApplicationSyncStatus `json:"sync,omitempty"`
	// Sync policy
	SyncPolicy *AppSyncPolicies `json:"syncPolicy,omitempty"`
	// Is HELM app flag
	IsHelmApp *bool `json:"isHelmApp,omitempty"`
	// Is git source app flag
	IsGitSource *bool `json:"isGitSource,omitempty"`
	// Indicates whenether application is multi sourced
	IsMultiSourced *bool `json:"isMultiSourced,omitempty"`
	// Related groups names list
	RelatedGroups []*string `json:"relatedGroups"`
	// Version of application and dependencies
	AppVersions *ProductComponentVersions `json:"appVersions,omitempty"`
	// Resolved when product app attached to specific product or null if unassigned. Normally should be 1 or 0. If more this means that collision in relation present and component belongs to different products
	Products []*Product `json:"products,omitempty"`
	// Resolved when product app attached to specific environment or null if unassigned
	Environments []*Environment `json:"environments,omitempty"`
}

func (Application) IsApplicationTreeItem() {}

func (Application) IsGitopsEntity() {}

func (Application) IsBaseEntity() {}

func (Application) IsProjectBasedEntity() {}

func (Application) IsFavorable() {}

func (Application) IsEntity() {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

// ApplicationField Entity
type ApplicationField struct {
	// Destination info
	Destination *ApplicationFormDestination `json:"destination,omitempty"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status,omitempty"`
	// Argo CD application spec sources config - multi-sourced apps
	SpecSources []*ArgoCDApplicationSpecSource `json:"specSources,omitempty"`
	// Issues
	Issues []*Annotation `json:"issues,omitempty"`
	// PullRequest
	Prs []*Annotation `json:"prs,omitempty"`
	// Committers
	Committers []*CommitterLabel `json:"committers,omitempty"`
	// ArgoCD application target revision
	Revision *string `json:"revision,omitempty"`
	// Build
	Builds []*Build `json:"builds,omitempty"`
}

// Application form data object
type ApplicationFormData struct {
	// Metadata
	Metadata *ApplicationFormMetadata `json:"metadata"`
	// Destination info
	Destination *ApplicationFormDestination `json:"destination"`
	// Application source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Application sources - multi-sourced apps
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
	// Project of application
	Project string `json:"project"`
	// Sync policy settings
	SyncPolicy *ApplicationFormSyncPolicy `json:"syncPolicy,omitempty"`
	// Ignore differences list
	IgnoreDifferences []*ApplicationFormIgnoreDifferences `json:"ignoreDifferences,omitempty"`
}

// Application form Destination
type ApplicationFormDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Destination namespace
	Namespace *string `json:"namespace,omitempty"`
	// Cluster address
	Server *string `json:"server,omitempty"`
}

// Application ignore differences
type ApplicationFormIgnoreDifferences struct {
	// Group of ignored resource
	Group *string `json:"group,omitempty"`
	// Kind of ignored resource
	Kind string `json:"kind"`
	// Name of ignored resource
	Name *string `json:"name,omitempty"`
	// Namespace of ignored resource
	Namespace *string `json:"namespace,omitempty"`
	// Ignored json paths
	JSONPointers []string `json:"jsonPointers,omitempty"`
	// Jq Path Expressions
	JqPathExpressions []string `json:"jqPathExpressions,omitempty"`
	// ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take precedence over the desired state defined in the SCM and won't be displayed in diffs
	ManagedFieldsManagers []string `json:"managedFieldsManagers,omitempty"`
}

// Application form metadata
type ApplicationFormMetadata struct {
	// Application name
	Name string `json:"name"`
	// Application namespace
	Namespace *string `json:"namespace,omitempty"`
	// Application finalizers
	Finalizers []string `json:"finalizers,omitempty"`
	// Annotations
	Annotations *string `json:"annotations,omitempty"`
	// Labels
	Labels *string `json:"labels,omitempty"`
}

// Application form Source
type ApplicationFormSource struct {
	// Path
	Path *string `json:"path,omitempty"`
	// Repository url
	RepoURL string `json:"repoURL"`
	// Target revision
	TargetRevision *string `json:"targetRevision,omitempty"`
	// Helm chart
	Chart *string `json:"chart,omitempty"`
	// Directory
	Directory *ApplicationFormSourceDirectory `json:"directory,omitempty"`
	// HEML
	Helm *ApplicationFormSourceHelm `json:"helm,omitempty"`
	// Kustomize
	Kustomize *ApplicationFormSourceKustomize `json:"kustomize,omitempty"`
	// Ksonnet
	Ksonnet *ApplicationFormSourceKsonnet `json:"ksonnet,omitempty"`
	// Plugin
	Plugin *ApplicationFormSourcePlugin `json:"plugin,omitempty"`
	// Name of ref source
	Ref *string `json:"ref,omitempty"`
}

// Application form Source Directory
type ApplicationFormSourceDirectory struct {
	// Directory recurse
	Recurse *bool `json:"recurse,omitempty"`
	// Exclude
	Exclude *string `json:"exclude,omitempty"`
	// Include
	Include *string `json:"include,omitempty"`
	// Directory jsonnet options
	Jsonnet *ApplicationFormSourceDirectoryJsonnet `json:"jsonnet,omitempty"`
}

// Application form Source Directory Jsonnet
type ApplicationFormSourceDirectoryJsonnet struct {
	// Top level vars
	Tlas []*NameValueCodeOutput `json:"tlas,omitempty"`
	// External vars
	ExtVars []*NameValueCodeOutput `json:"extVars,omitempty"`
	// Libs
	Libs []string `json:"libs,omitempty"`
}

// Application form Source Helm
type ApplicationFormSourceHelm struct {
	// Values
	Values *string `json:"values,omitempty"`
	// Value files
	ValueFiles []string `json:"valueFiles,omitempty"`
	// Parameters
	Parameters []*NameValueOutput `json:"parameters,omitempty"`
	// File Parameters
	FileParameters []*ArgoCdDTOHelmFileParameter `json:"fileParameters,omitempty"`
	// Ignore Missing Value Files
	IgnoreMissingValueFiles *bool `json:"ignoreMissingValueFiles,omitempty"`
	// Pass Credentials
	PassCredentials *bool `json:"passCredentials,omitempty"`
	// Release Name
	ReleaseName *string `json:"releaseName,omitempty"`
	// Skip Crds
	SkipCrds *bool `json:"skipCrds,omitempty"`
	// Values Object
	ValuesObject *ArgoCdDTORuntimeRawExtension `json:"valuesObject,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// Application form Source Ksonnet
type ApplicationFormSourceKsonnet struct {
	// Environment
	Environment string `json:"environment"`
}

// Application form Source Kustomize
type ApplicationFormSourceKustomize struct {
	// Name prefix
	NamePrefix *string `json:"namePrefix,omitempty"`
	// Name suffix
	NameSuffix *string `json:"nameSuffix,omitempty"`
	// Images
	Images []string `json:"images,omitempty"`
	// CommonAnnotations
	CommonAnnotations *string `json:"commonAnnotations,omitempty"`
	// CommonAnnotationsEnvsubst
	CommonAnnotationsEnvsubst *bool `json:"commonAnnotationsEnvsubst,omitempty"`
	// CommonLabels
	CommonLabels *string `json:"commonLabels,omitempty"`
	// Components
	Components []*string `json:"components,omitempty"`
	// ForceCommonAnnotations
	ForceCommonAnnotations *bool `json:"forceCommonAnnotations,omitempty"`
	// ForceCommonLabels
	ForceCommonLabels *bool `json:"forceCommonLabels,omitempty"`
	// ForceNamespace
	ForceNamespace *bool `json:"forceNamespace,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Patches
	Patches []*ArgoCdDTOKustomizePatch `json:"patches,omitempty"`
	// Replicas
	Replicas []*ArgoCdDTOKustomizeReplica `json:"replicas,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// Application form Source Plugin
type ApplicationFormSourcePlugin struct {
	// Plagin name
	Name *string `json:"name,omitempty"`
	// Plagin parameters
	Parameters []*ArgoCdDTOApplicationSourcePluginParameter `json:"parameters,omitempty"`
	// Array of env variables
	Env []*NameValueOutput `json:"env,omitempty"`
}

// Application form Sync Automated Policy
type ApplicationFormSyncAutomatedPolicy struct {
	// Prune policy flag
	Prune *bool `json:"prune,omitempty"`
	// Self heal policy flag
	SelfHeal *bool `json:"selfHeal,omitempty"`
	// AllowEmpty allows apps have zero live resources
	AllowEmpty *bool `json:"allowEmpty,omitempty"`
}

// Application form Sync Policy
type ApplicationFormSyncPolicy struct {
	// Automated sync policy options
	Automated *ApplicationFormSyncAutomatedPolicy `json:"automated,omitempty"`
	// Sync options - e.g. ['key=value']
	SyncOptions []string `json:"syncOptions,omitempty"`
	// Retry options
	Retry *ApplicationFormSyncRetryOptions `json:"retry,omitempty"`
	// Managed namespace metadata
	ManagedNamespaceMetadata *ArgoCdDTOManagedNamespaceMetadata `json:"managedNamespaceMetadata,omitempty"`
}

// Application form Sync Policy retry options
type ApplicationFormSyncRetryBackoffOptions struct {
	// Duration
	Duration string `json:"duration"`
	// Max duration
	MaxDuration string `json:"maxDuration"`
	// Factor
	Factor int `json:"factor"`
}

// Application form Sync Policy retry options
type ApplicationFormSyncRetryOptions struct {
	// Retries amount
	Limit *int `json:"limit,omitempty"`
	// Backoff options
	Backoff *ApplicationFormSyncRetryBackoffOptions `json:"backoff,omitempty"`
}

// Application Group Entity
type ApplicationGroup struct {
	// Entity db id
	ID string `json:"id"`
	// Group name
	Name string `json:"name"`
	// Group Applications count
	ApplicationCount *int `json:"applicationCount,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Is group marked as favorite (user scope)
	Favorite *bool `json:"favorite,omitempty"`
}

func (ApplicationGroup) IsFavorableNotK8s() {}

func (ApplicationGroup) IsFavorableNotK8sEntity() {}

func (ApplicationGroup) IsEntity() {}

// ApplicationGroup Edge
type ApplicationGroupEdge struct {
	// Node contains the actual application group data
	Node *ApplicationGroup `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationGroupEdge) IsEdge() {}

// Args to filter ApplicationGroup
type ApplicationGroupFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
}

// Application Group Slice
type ApplicationGroupSlice struct {
	// Application Group edges
	Edges []*ApplicationGroupEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationGroupSlice) IsSlice() {}

// Application Groups sorting arguments
type ApplicationGroupSortArg struct {
	// Field for sorting
	Field ApplicationGroupsSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Application Id
type ApplicationID struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Namespace
	Namespace string `json:"namespace"`
	// Name
	Name string `json:"name"`
}

// Application Id
type ApplicationIDInput struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Namespace
	Namespace string `json:"namespace"`
	// Name
	Name string `json:"name"`
}

// Application Info
type ApplicationInfo struct {
	// Application id
	ApplicationID *ApplicationID `json:"applicationId"`
	// Commit sha made for application promotion
	CommitSha *string `json:"commitSha,omitempty"`
	// Pull request made for application promotion
	Pr *PullRequest `json:"pr,omitempty"`
	// Application status
	Status ExtendedWorkflowPhases `json:"status"`
	// Application issues
	Issues []*AppInfoIssue `json:"issues,omitempty"`
	// Application status history
	StatusHistory []*ProductReleaseAppStepStatusEntry `json:"statusHistory"`
	// Application action body
	ActionBody *string `json:"actionBody,omitempty"`
	// Restarted
	Restarted *bool `json:"restarted,omitempty"`
}

// Product Release step application issue
type ApplicationIssue struct {
	// Application Name
	ApplicationName string `json:"applicationName"`
	// Runtime name
	Runtime *string `json:"runtime,omitempty"`
	// Application namespace
	Namespace *string `json:"namespace,omitempty"`
	// Issue date
	Date string `json:"date"`
	// Error message
	Message string `json:"message"`
	// Kind
	Kind string `json:"kind"`
	// Application sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Application health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Issue type
	Type IssueType `json:"type"`
	// Error level
	Level ErrorLevels `json:"level"`
	// Resource metadata
	ResourceMetadata *ResourceMetadata `json:"resourceMetadata,omitempty"`
}

func (ApplicationIssue) IsIssueKind() {}

func (ApplicationIssue) IsIssue() {}

// Application manifest hierarchy
type ApplicationManifestHierarchy struct {
	// Block name
	Name string `json:"name"`
	// Block line number
	Line *int `json:"line,omitempty"`
	// Nested items
	Children []*ApplicationManifestHierarchy `json:"children"`
}

// Application Operation
type ApplicationOperation struct {
	// Initiated By
	InitiatedBy *ApplicationOperationInitiatedBy `json:"initiatedBy,omitempty"`
	// Retry
	Retry *ApplicationOperationRetryOptions `json:"retry,omitempty"`
	// Info
	Info []*NameValueOutput `json:"info,omitempty"`
	// Sync
	Sync *ApplicationOperationSync `json:"sync,omitempty"`
}

// ApplicationOperationInitiator
type ApplicationOperationInitiatedBy struct {
	// Automated
	Automated *bool `json:"automated,omitempty"`
	// Username
	Username *string `json:"username,omitempty"`
}

// Application form Sync Policy retry options
type ApplicationOperationRetryBackoffOptions struct {
	// Duration
	Duration *string `json:"duration,omitempty"`
	// Max duration
	MaxDuration *string `json:"maxDuration,omitempty"`
	// Factor
	Factor *int `json:"factor,omitempty"`
}

// ApplicationOperationRetryOptions
type ApplicationOperationRetryOptions struct {
	// Limit is the maximum Int of attempts for retrying a failed sync. If set to 0, no retries will be performed.
	Limit *int `json:"limit,omitempty"`
	// Backoff
	Backoff *ApplicationOperationRetryBackoffOptions `json:"backoff,omitempty"`
}

// Application Operation State
type ApplicationOperationState struct {
	// Finished At
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Started At
	StartedAt string `json:"startedAt"`
	// Message
	Message *string `json:"message,omitempty"`
	// Phase
	Phase SyncOperationPhase `json:"phase"`
	// Type
	Type AppOperationType `json:"type"`
	// Retry Count
	RetryCount *int `json:"retryCount,omitempty"`
	// Operation
	Operation *ApplicationOperation `json:"operation"`
	// Sync Result
	SyncResult *ApplicationSyncResult `json:"syncResult,omitempty"`
}

// ArgoCdDTO SyncOperation object
type ApplicationOperationSync struct {
	// Prune
	Prune *bool `json:"prune,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// Sync Options - e.g. ['key=value']
	SyncOptions []string `json:"syncOptions,omitempty"`
	// Resources
	Resources []*ApplicationOperationSyncResource `json:"resources,omitempty"`
	// Sync Strategy
	SyncStrategy *ApplicationOperationSyncStrategy `json:"syncStrategy,omitempty"`
	// DryRun
	DryRun *bool `json:"dryRun,omitempty"`
	// Manifests
	Manifests []*string `json:"manifests,omitempty"`
	// Revisions is the list of revision (Git) or chart version (Helm) which to sync each source in sources field for the application to. If omitted, will use the revision specified in app spec.
	Revisions []*string `json:"revisions,omitempty"`
	// Change Revision - monorepo support
	ChangeRevision *string `json:"changeRevision,omitempty"`
	// Change Revisions - monorepo support
	ChangeRevisions []*string `json:"changeRevisions,omitempty"`
	// Source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Sources
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
}

// ApplicationOperationSyncResource
type ApplicationOperationSyncResource struct {
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Group
	Group *string `json:"group,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// ApplicationOperationSyncStrategy
type ApplicationOperationSyncStrategy struct {
	// Apply
	Apply *ArgoCdDTOSyncStrategyApply `json:"apply,omitempty"`
	// Hook
	Hook *ArgoCdDTOSyncStrategyHook `json:"hook,omitempty"`
}

// ApplicationOrderedStatistics
type ApplicationOrderedStatistics struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Applications stats
	ApplicationsStats []*ApplicationOrderedStatisticsData `json:"applicationsStats"`
}

// Ordered Application Stats single application statistics
type ApplicationOrderedStatisticsData struct {
	// Application
	Application string `json:"application"`
	// Namespace
	Namespace string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Cluster
	Cluster string `json:"cluster"`
	// Application deployment statistics by status
	DeploymentStatusBreakdown []*DeploymentStatisticsInfo `json:"deploymentStatusBreakdown"`
	// Total deployments
	TotalDeployments *MetricWithTrend `json:"totalDeployments"`
}

// Application ref
type ApplicationRef struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Is reference was cut during tree normalizing
	IsReferenceCut *bool `json:"isReferenceCut,omitempty"`
}

// ApplicationSet entity
type ApplicationSet struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations,omitempty"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Updated At
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// RepoURL
	RepoURL *string `json:"repoURL,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// Number of resources
	Size *int `json:"size,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
}

func (ApplicationSet) IsBaseEntity() {}

func (ApplicationSet) IsProjectBasedEntity() {}

func (ApplicationSet) IsFavorable() {}

func (ApplicationSet) IsApplicationTreeItem() {}

func (ApplicationSet) IsEntity() {}

// Application Set Edge
type ApplicationSetEdge struct {
	// Node contains the actual application set data
	Node *ApplicationSet `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationSetEdge) IsEdge() {}

// ApplicationSet Slice
type ApplicationSetSlice struct {
	// Application edges
	Edges []*ApplicationSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSetSlice) IsSlice() {}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Application Sync Compared To
type ApplicationSyncComparedTo struct {
	// Destination
	Destination *ApplicationFormDestination `json:"destination"`
	// Source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Sources - present for multisourced apps
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
}

// ApplicationSyncResult
type ApplicationSyncResult struct {
	// Revision
	Revision string `json:"revision"`
	// Revisions
	Revisions []string `json:"revisions,omitempty"`
	// Resources
	Resources []*SyncResultResource `json:"resources,omitempty"`
	// Source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Sources - present for multisourced apps
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
}

// Application Sync Status
type ApplicationSyncStatus struct {
	// Status
	Status SyncStatus `json:"status"`
	// Revision - null is not multisourced
	Revision *string `json:"revision,omitempty"`
	// Revisions - present if multisourced
	Revisions []string `json:"revisions,omitempty"`
	// ComparedTo
	ComparedTo *ApplicationSyncComparedTo `json:"comparedTo,omitempty"`
}

// Application Tree Health Status Statistic
type ApplicationTreeHealthStatusStatisticRecord struct {
	// Health Status
	Type HealthStatus `json:"type"`
	// Count
	Count int `json:"count"`
}

// Application relations
type AppsRelations struct {
	// Entities referencing this entity
	ReferencedBy []*ApplicationRef `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []*ApplicationRef `json:"references,omitempty"`
}

// Argo CD Application destination config
type ArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Cluster url
	Server *string `json:"server,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Argo CD Application spec source
type ArgoCDApplicationSpecSource struct {
	// Path
	Path *string `json:"path,omitempty"`
	// Repo url
	RepoURL string `json:"repoURL"`
	// Branch/Tag or chart version (for helm)
	TargetRevision *string `json:"targetRevision,omitempty"`
	// Chart name
	Chart *string `json:"chart,omitempty"`
	// Source ref - used in multi-source apps
	Ref *string `json:"ref,omitempty"`
}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt,omitempty"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt,omitempty"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Revision
	Revision string `json:"revision"`
	// Version
	Version string `json:"version"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// CommitAvatar
	CommitAvatar *string `json:"commitAvatar,omitempty"`
	// CommitUrl
	CommitURL *string `json:"commitUrl,omitempty"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage,omitempty"`
	// CommitDate
	CommitDate *string `json:"commitDate,omitempty"`
	// Sync Revisions commits info
	SyncRevisions []*SourceRevisionInfo `json:"syncRevisions,omitempty"`
	// Change Revisions commits info
	ChangeRevisions []*SourceRevisionInfo `json:"changeRevisions,omitempty"`
	// History Id
	HistoryID *int `json:"historyId,omitempty"`
	// History Id
	MinHistoryID *int `json:"minHistoryId,omitempty"`
}

// ArgoCdDTOApplicationSourcePluginParameter
type ArgoCdDTOApplicationSourcePluginParameter struct {
	// Array is the value of an array type parameter.
	Array []*string `json:"array,omitempty"`
	// Map is the value of a map type parameter. {[k: String]: String }
	Map *string `json:"map,omitempty"`
	// Name is the name identifying a parameter.
	Name *string `json:"name,omitempty"`
	// String_ is the value of a String type parameter.
	String *string `json:"string,omitempty"`
}

// ArgoCdDTOHelmFileParameter
type ArgoCdDTOHelmFileParameter struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
}

// ArgoCdDTOIntstrIntOrString
type ArgoCdDTOIntstrIntOrString struct {
	// IntVal
	IntVal *int `json:"intVal,omitempty"`
	// StrVal
	StrVal *string `json:"strVal,omitempty"`
	// Type
	Type *int `json:"type,omitempty"`
}

// ArgoCdDTOKustomizeGvk
type ArgoCdDTOKustomizeGvk struct {
	// Group
	Group *string `json:"group,omitempty"`
	// Kind
	Kind *string `json:"kind,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// ArgoCdDTOKustomizePatch
type ArgoCdDTOKustomizePatch struct {
	// { [k: String]: Boolean }
	Options *string `json:"options,omitempty"`
	// Patch
	Patch *string `json:"patch,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Target
	Target *ArgoCdDTOKustomizeSelector `json:"target,omitempty"`
}

// ArgoCdDTOKustomizeReplica
type ArgoCdDTOKustomizeReplica struct {
	// Count
	Count *ArgoCdDTOIntstrIntOrString `json:"count"`
	// Name
	Name string `json:"name"`
}

// ArgoCdDTOKustomizeResId
type ArgoCdDTOKustomizeResID struct {
	// Gvk
	Gvk *ArgoCdDTOKustomizeGvk `json:"gvk,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// ArgoCdDTOKustomizeSelector
type ArgoCdDTOKustomizeSelector struct {
	// AnnotationSelector
	AnnotationSelector *string `json:"annotationSelector,omitempty"`
	// LabelSelector
	LabelSelector *string `json:"labelSelector,omitempty"`
	// ResId
	ResID *ArgoCdDTOKustomizeResID `json:"resId,omitempty"`
}

// ArgoCdDTOManagedNamespaceMetadata
type ArgoCdDTOManagedNamespaceMetadata struct {
	// { [k: String]: String }
	Annotations *string `json:"annotations,omitempty"`
	// { [k: String]: String }
	Labels *string `json:"labels,omitempty"`
}

// RawExtension is used to hold extensions in external versions. To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
type ArgoCdDTORuntimeRawExtension struct {
	// Raw
	Raw *string `json:"raw,omitempty"`
}

// ArgoCdDTOSyncStrategyApply
type ArgoCdDTOSyncStrategyApply struct {
	// Force indicates whether or not to supply the --force flag to `kubectl apply`. The --force flag deletes and re-create the resource, when PATCH encounters conflict and has retried for 5 times.
	Force *bool `json:"force,omitempty"`
}

// SyncStrategyHook will perform a sync using hooks annotations. If no hook annotation is specified falls back to `kubectl apply`.
type ArgoCdDTOSyncStrategyHook struct {
	// SyncStrategyApply
	SyncStrategyApply *ArgoCdDTOSyncStrategyApply `json:"syncStrategyApply,omitempty"`
}

// Argo Hub Template
type ArgoHubTemplate struct {
	// Version
	ID *string `json:"id,omitempty"`
	// Manifest
	Manifest *string `json:"manifest,omitempty"`
	// Manifest url
	ManifestURL *string `json:"manifestUrl,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// Categories
	Categories []*string `json:"categories,omitempty"`
}

// Argo Hub Templates
type ArgoHubTemplates struct {
	// Starter template name
	Data []*ArgoHubTemplatesSlice `json:"data,omitempty"`
}

// Argo Hub templates filter arguments
type ArgoHubTemplatesFilterArgs struct {
	// Filter Argo Hub Templates by category
	Category *string `json:"category,omitempty"`
	// Filter Argo Hub Templates by name
	Name *string `json:"name,omitempty"`
}

// Argo Hub Templates Slice
type ArgoHubTemplatesSlice struct {
	// Template name
	Name *string `json:"name,omitempty"`
	// Versions
	Versions []*ArgoHubTemplate `json:"versions,omitempty"`
	// Latest version
	LatestVersion *ArgoHubTemplate `json:"latestVersion,omitempty"`
}

// Audit Edge
type AuditEdge struct {
	// Node contains the actual audit record
	Node *AuditEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Audit Entity Record
type AuditEntity struct {
	// Timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// AccountId
	AccountID *string `json:"accountId,omitempty"`
	// AccountName
	AccountName *string `json:"accountName,omitempty"`
	// UserId
	UserID *string `json:"userId,omitempty"`
	// UserName
	UserName *string `json:"userName,omitempty"`
	// Action
	Action string `json:"action"`
	// AuthEntityType
	AuthEntityType string `json:"authEntityType"`
	// EventType
	EventType string `json:"eventType"`
	// EntityType
	EntityType string `json:"entityType"`
	// EntityId
	EntityID *string `json:"entityId,omitempty"`
	// EntityName
	EntityName string `json:"entityName"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// IP
	IP *string `json:"ip,omitempty"`
	// Method
	Method *string `json:"method,omitempty"`
	// Url
	URL *string `json:"url,omitempty"`
	// Params
	Params *string `json:"params,omitempty"`
	// Query
	Query *string `json:"query,omitempty"`
	// Headers
	Headers *string `json:"headers,omitempty"`
	// Payload
	Payload *string `json:"payload,omitempty"`
	// Status
	Status *int `json:"status,omitempty"`
	// Response
	Response *string `json:"response,omitempty"`
}

// Args to filter audit
type AuditFilterArgs struct {
	// Status
	Status *int `json:"status,omitempty"`
}

// Audit Slice
type AuditSlice struct {
	// Audit edges
	Edges []*AuditEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Auth0SSO
type Auth0sso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
}

func (Auth0sso) IsIDP() {}

// Stats for avg change failure rate
type AvgChangeFailureRateStatistics struct {
	// Avg change failure rate data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Avg change failure rate info
	Info *DoraStatisticsSummery `json:"info"`
}

// Stats for Avg time to restore service
type AvgTimeToRestoreServiceStatistics struct {
	// Avg time to restore service data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Avg time to restore service info
	Info *DoraStatisticsSummery `json:"info"`
}

// AzureSSO
type AzureSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// Tenant
	Tenant *string `json:"tenant,omitempty"`
	// Object Id in Azure
	AppID *string `json:"appId,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Cookie key
	CookieKey *string `json:"cookieKey,omitempty"`
	// Cookie iv
	CookieIv *string `json:"cookieIv,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// Remove deactivated users after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
	// Admin teams
	AdminTeams *string `json:"adminTeams,omitempty"`
	// Remove other admins after sync
	RemoveOtherAdminsAfterSync *bool `json:"removeOtherAdminsAfterSync,omitempty"`
}

func (AzureSso) IsIDP() {}

// BasePrice
type BasePrice struct {
	// Month
	Month *int `json:"month,omitempty"`
	// Year
	Year *int `json:"year,omitempty"`
}

// references info
type BaseReference struct {
	// Object metadata
	Metadata *EntityReferenceMeta `json:"metadata,omitempty"`
}

// Simplified team
type BasicTeam struct {
	// Team name
	Name string `json:"name"`
	// Team ID
	ID string `json:"id"`
	// Account ID
	Account *string `json:"account,omitempty"`
	// List of users in team
	Users []*string `json:"users,omitempty"`
	// Team tags
	Tags []*string `json:"tags,omitempty"`
	// Team type
	Type *TeamType `json:"type,omitempty"`
	// Team ref id
	RefID *string `json:"refId,omitempty"`
	// Team source
	Source *TeamSource `json:"source,omitempty"`
}

// Result of the batch promotion policy resolution error.
type BatchResolvePromotionPolicyError struct {
	// Product Name
	ProductName string `json:"productName"`
	// Target Environment Name
	TargetEnvironmentName string `json:"targetEnvironmentName"`
	// Error message
	Error string `json:"error"`
}

func (BatchResolvePromotionPolicyError) IsBatchResolvePromotionPolicyResult() {}

// Result of the batch promotion policy successful resolution.
type BatchResolvePromotionPolicySuccess struct {
	// Product Name
	ProductName string `json:"productName"`
	// Target Environment Name
	TargetEnvironmentName string `json:"targetEnvironmentName"`
	// Resolved Promotion Policy
	ResolvedPolicy *ResolvedPromotionPolicy `json:"resolvedPolicy"`
}

func (BatchResolvePromotionPolicySuccess) IsBatchResolvePromotionPolicyResult() {}

// BitbucketCloud trigger conditions
type BitbucketCloudTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
	// Repo filter argumets
	Repo *RepoBitbucketCloudFilterArgs `json:"repo"`
}

// BitbucketCloud trigger conditions
type BitbucketCloudTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// repo filter argumets
	Repo *RepoBitbucketCloudFilterArgsInput `json:"repo"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// BitbucketServer trigger conditions
type BitbucketServerTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Bitbucket Server url
	BaseURL string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// BitbucketServer trigger conditions
type BitbucketServerTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Base url
	BaseURL string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// Build Entity
type Build struct {
	// Build Id
	ID string `json:"id"`
	// PipelineRef
	Pipeline *PipelineRef `json:"pipeline"`
}

// ClusterCacheInfo contains information about the cluster cache
type CacheInfo struct {
	// ResourcesCount holds number of observed Kubernetes resources
	ResourcesCount *int `json:"resourcesCount,omitempty"`
	// APIsCount holds number of observed Kubernetes API count
	ApisCount *int `json:"apisCount,omitempty"`
	// LastCacheSyncTime holds time of most recent cache synchronization
	LastCacheSyncTime *string `json:"lastCacheSyncTime,omitempty"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// TBD
	Schedule *string `json:"schedule,omitempty"`
	// TBD
	Interval *string `json:"interval,omitempty"`
	// TBD
	Timezone *string `json:"timezone,omitempty"`
	// TBD
	Metadata *string `json:"metadata,omitempty"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// Calendar trigger conditions
type CalendarTriggerConditions struct {
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Number of seconds, minutes, hours, etc..
	Interval *string `json:"interval,omitempty"`
	// Cron expression
	Schedule *string `json:"schedule,omitempty"`
	// TimeZone
	Timezone *string `json:"timezone,omitempty"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Calendar trigger conditions
type CalendarTriggerConditionsArgs struct {
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Number of seconds, minutes, hours, etc..
	Interval *string `json:"interval,omitempty"`
	// Cron expression
	Schedule *string `json:"schedule,omitempty"`
	// TimeZone
	Timezone *string `json:"timezone,omitempty"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Channel-specific release data
type ChannelReleases struct {
	// All releases in this channel
	Releases []*Release `json:"releases"`
	// Latest (newest) chart version in this channel, null if no releases
	LatestChartVersion *string `json:"latestChartVersion,omitempty"`
}

// ChildApplicationField Entity
type ChildApplicationField struct {
	// Name
	Name string `json:"name"`
	// Repo
	Repo *string `json:"repo,omitempty"`
	// Cluster
	Cluster *string `json:"cluster,omitempty"`
	// Status
	Status *SyncStatus `json:"status,omitempty"`
}

// Child workflow reference
type ChildWorkflowRef struct {
	// Child workflow
	Workflow *Workflow `json:"workflow,omitempty"`
	// Child workflow type
	Type *string `json:"type,omitempty"`
	// Node ref
	NodeRef *string `json:"nodeRef,omitempty"`
}

// Classic pipeline duration stats
type ClassicPipelineDurationMetric struct {
	// Duration Name
	DurationName DurationName `json:"durationName"`
	// Duration statistics
	DurationStats *ClassicPipelineMetric `json:"durationStats"`
}

// Classic pipeline metric
type ClassicPipelineMetric struct {
	// Info
	Info *PipelineClassicStatsInfo `json:"info"`
	// Data
	Data []*TimeSeriesDataRecord `json:"data"`
}

// Classic Pipeline Performance Record
type ClassicPipelinePerformanceRecord struct {
	// Pipeline Id
	PipelineID string `json:"pipelineId"`
	// Pipeline Name
	PipelineName string `json:"pipelineName"`
	// Project Id
	ProjectID *string `json:"projectId,omitempty"`
	// Project Name
	ProjectName *string `json:"projectName,omitempty"`
	// Number of exeuctions statistic
	Executions *MetricWithTrend `json:"executions"`
	// Pipeline Duration Statitstic
	Duration *MetricWithTrend `json:"duration"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Pipeline statistics to be used in analytics module
type ClassicPipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *ClassicPipelineMetric `json:"successRateStats"`
	// Duration stats
	DurationStats []*ClassicPipelineDurationMetric `json:"durationStats"`
}

// Classic Pipelines Performance Statistics
type ClassicPipelinesPerformanceStatistics struct {
	// Performance stats
	PerformancesStats []*ClassicPipelinePerformanceRecord `json:"performancesStats"`
	// Duration type
	DurationType *PipelineClassicStatisticDurationMetricType `json:"durationType,omitempty"`
	// Time dimension info
	Info *StatsTimePeriodData `json:"info,omitempty"`
}

// ClientIP
type ClientIP struct {
	// TimeoutSeconds
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// Cloud Builds
type CloudBuilds struct {
	// Is cloud builds activated
	IsActivated *bool `json:"isActivated,omitempty"`
	// Who was it performed by
	PerformedBy *string `json:"performedBy,omitempty"`
	// Is cloud builds requested
	IsRequested *bool `json:"isRequested,omitempty"`
	// Date
	Date *string `json:"date,omitempty"`
}

// Cluster entity
type Cluster struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Server is the API server URL of the Kubernetes cluster
	Server string `json:"server"`
	// Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
	Namespaces []string `json:"namespaces"`
	// RefreshRequestedAt holds time when cluster cache refresh has been requested
	RefreshRequestedAt *string `json:"refreshRequestedAt,omitempty"`
	// Shard contains optional shard number. Calculated on the fly by the application controller if not specified.
	Shard *int `json:"shard,omitempty"`
	// Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
	ClusterResources bool `json:"clusterResources"`
	// Info holds information about cluster cache and state
	Info *ClusterInfo `json:"info"`
	// Indicated if cluster considered inactive due to missing events from the app-proxy
	Inactive *bool `json:"inactive,omitempty"`
	// UpdatedAt holds time when cluster has been updated
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

func (Cluster) IsBaseEntity() {}

func (Cluster) IsEntity() {}

// Cluster Edge
type ClusterEdge struct {
	// Node contains the actual cluster data
	Node *Cluster `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ClusterEdge) IsEdge() {}

// ClusterInfo contains information about the cluster
type ClusterInfo struct {
	// ConnectionState contains information about the connection to the cluster
	ConnectionState *ConnectionState `json:"connectionState"`
	// ServerVersion contains information about the Kubernetes version of the cluster
	ServerVersion *string `json:"serverVersion,omitempty"`
	// CacheInfo contains information about the cluster cache
	CacheInfo *CacheInfo `json:"cacheInfo,omitempty"`
	// ApplicationsCount is the number of applications managed by Argo CD on the cluster
	ApplicationsCount int `json:"applicationsCount"`
	// APIVersions contains list of API versions supported by the cluster
	APIVersions []*string `json:"apiVersions,omitempty"`
}

// Cluster Names Record For Dropdown
type ClusterNamesDDRecord struct {
	// Name
	Name string `json:"name"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Cluster Slice
type ClusterSlice struct {
	// Cluster edges
	Edges []*ClusterEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ClusterSlice) IsSlice() {}

// Cluster Url Record For Dropdown
type ClusterURLDDRecord struct {
	// Name
	Name string `json:"name"`
	// Url
	URL string `json:"url"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Clusters statistics
type ClustersStatistics struct {
	// Total clusters number
	Total int `json:"total"`
	// Number of connected runtimes
	Connected int `json:"connected"`
	// Number of failed connection clusters
	Failed int `json:"failed"`
	// Number of unknown connection clusters
	Unknown int `json:"unknown"`
}

// Commit info
type CommitInfo struct {
	// Commit sha
	Sha string `json:"sha"`
	// Committer name
	Committer string `json:"committer"`
	// Commit date
	Date time.Time `json:"date"`
	// Commit message
	Message string `json:"message"`
	// Commit repository url
	RepoURL string `json:"repoURL"`
	// Commit revision (= branch)
	Revision string `json:"revision"`
}

// CommitInfoArgs
type CommitInfoArgs struct {
	// Commit sha
	Sha string `json:"sha"`
	// Committer name
	Committer string `json:"committer"`
	// Committer avatar url
	CommitterAvatarURL *string `json:"committerAvatarUrl,omitempty"`
	// Commit date
	Date *time.Time `json:"date,omitempty"`
	// Commit message
	Message string `json:"message"`
	// Commit repository url
	RepoURL string `json:"repoURL"`
	// Commit revision (= branch)
	Revision string `json:"revision"`
}

// Commits
type Commits struct {
	// url
	URL *string `json:"url,omitempty"`
	// userName
	UserName *string `json:"userName,omitempty"`
	// sha
	Sha *string `json:"sha,omitempty"`
	// message
	Message *string `json:"message,omitempty"`
	// commitDate
	CommitDate *string `json:"commitDate,omitempty"`
}

// Commits output
type CommitsOutput struct {
	// Commit url
	URL string `json:"url"`
	// Commit author
	UserName string `json:"userName"`
	// Commit sha
	Sha string `json:"sha"`
	// Commit message
	Message string `json:"message"`
}

// Committer Label
type CommitterLabel struct {
	// UserName
	UserName string `json:"userName"`
	// Avatar
	Avatar *string `json:"avatar,omitempty"`
	// Committer commits list
	Commits []*CommitsOutput `json:"commits,omitempty"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self,omitempty"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity() {}

func (Component) IsK8sLogicEntity() {}

func (Component) IsProjectBasedEntity() {}

func (Component) IsEntity() {}

// Yaml contents of dependencies description
type ComponentDependenciesContent struct {
	// Source of dependencies
	Source *string `json:"source,omitempty"`
	// Yaml of dependencies
	Content *string `json:"content,omitempty"`
}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// Component Notification
type ComponentNotification struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (ComponentNotification) IsNotification() {}

func (ComponentNotification) IsArgoCDNotification() {}

func (ComponentNotification) IsGitOpsNotification() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// ConfigMap Form Data object
type ConfigMapFormData struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata,omitempty"`
	// Data
	Data *string `json:"data,omitempty"`
	// Data
	BinaryData *string `json:"binaryData,omitempty"`
	// Sync status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
}

// ConfigMapMetadata
type ConfigMapMetadata struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Labels
	Labels []*StringPair `json:"labels,omitempty"`
}

// ConnectionState contains information about remote resource connection state, currently used for clusters and repositories
type ConnectionState struct {
	// Status contains the current status indicator for the connection
	Status ClusterConnectionStatus `json:"status"`
	// Message contains human readable information about the connection status
	Message *string `json:"message,omitempty"`
	// AttemptedAt contains the timestamp when this connection status has been determined
	AttemptedAt *string `json:"attemptedAt,omitempty"`
}

// Coupon
type Coupon struct {
	// Id
	ID string `json:"id"`
	// Object
	Object string `json:"object"`
	// Amount Off
	AmountOff *int `json:"amountOff,omitempty"`
	// Created
	Created int `json:"created"`
	// Currency
	Currency *string `json:"currency,omitempty"`
	// Duration
	Duration CouponDuration `json:"duration"`
	// Duration In Months
	DurationInMonths *int `json:"durationInMonths,omitempty"`
	// Live Mode
	Livemode bool `json:"livemode"`
	// Max Redemptions
	MaxRedemptions *int `json:"maxRedemptions,omitempty"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Percent Off
	PercentOff *float64 `json:"percentOff,omitempty"`
	// Redeem By
	RedeemBy *int `json:"redeemBy,omitempty"`
	// Times Redeemed
	TimesRedeemed int `json:"timesRedeemed"`
	// Valid
	Valid bool `json:"valid"`
}

// Create Audit Classic Record Response
type CreateAuditClassicRecordResponse struct {
	// IsError
	IsError bool `json:"isError"`
	// Error message
	Message *string `json:"message,omitempty"`
}

// Create commit ad hoc product release arguments
type CreateCommitAdHocProductReleaseInput struct {
	// Product name
	ProductName string `json:"productName"`
	// Source application id
	SrcAppID *ApplicationIDInput `json:"srcAppId"`
	// Source environment name
	SrcEnvironment string `json:"srcEnvironment"`
	// Destination environment name
	DestEnvironment string `json:"destEnvironment"`
	// Promotion policy
	Policy *PromotionPolicyDefinitionInput `json:"policy"`
	// Last commit info of source application
	CommitInfo *CommitInfoArgs `json:"commitInfo"`
	// List of destination applications ids, commit data and files
	Payload []*AhHocProductReleaseCommitFilesArgs `json:"payload"`
	// Promotion hooks
	Hooks *PromotionHooksDefinitionInput `json:"hooks,omitempty"`
}

// Create commit ad hoc promotion arguments
type CreateCommitAdHocPromotionInput struct {
	// Source application id
	SrcAppID *ApplicationIDInput `json:"srcAppId"`
	// Source environment name
	SrcEnvironment string `json:"srcEnvironment"`
	// Destination environment name
	DestEnvironment string `json:"destEnvironment"`
	// Promotion policy
	Policy *PromotionPolicyDefinitionInput `json:"policy"`
	// Last commit info of source application
	CommitInfo *CommitInfoArgs `json:"commitInfo"`
	// List of destination applications ids and commit data
	Payload []*AhHocPromotionCommitFilesArgs `json:"payload"`
}

// Create Environment Input
type CreateEnvironmentArgs struct {
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// List of clusters that belong to this environment
	Clusters []*EnvironmentClusterInput `json:"clusters"`
	// Label pairs array strings(key=value)
	LabelPairs []string `json:"labelPairs"`
}

// Input for git-source placeholder
type CreateGitSourcePlaceholderInput struct {
	// App name
	AppName string `json:"appName"`
	// The path to the source watched by the git-source
	AppSpecifier string `json:"appSpecifier"`
	// The server on which the resources will be applied
	DestServer string `json:"destServer"`
	// The server on which the resources will be applied
	DestNamespace string `json:"destNamespace"`
	// The labels of the git-source
	Labels *string `json:"labels,omitempty"`
	// Files to be included
	Include *string `json:"include,omitempty"`
	// Files to be excluded
	Exclude *string `json:"exclude,omitempty"`
	// Is this a codefresh internal git-source
	IsInternal *bool `json:"isInternal,omitempty"`
	// Is this a restricted git-source
	IsRestricted *bool `json:"isRestricted,omitempty"`
}

// Create Product Input
type CreateProductArgs struct {
	// Product name
	Name string `json:"name"`
	// Tags list
	Tags []*string `json:"tags"`
}

// Create Pull Request ad hoc product release arguments
type CreatePullRequestAdHocProductReleaseInput struct {
	// Product name
	ProductName string `json:"productName"`
	// Source application id
	SrcAppID *ApplicationIDInput `json:"srcAppId"`
	// Source environment name
	SrcEnvironment string `json:"srcEnvironment"`
	// Destination environment name
	DestEnvironment string `json:"destEnvironment"`
	// Promotion policy
	Policy *PromotionPolicyDefinitionInput `json:"policy"`
	// Last commit info of source application
	CommitInfo *CommitInfoArgs `json:"commitInfo"`
	// List of destination applications ids, pr data and files
	Payload []*AhHocProductReleasePullRequestFilesArgs `json:"payload"`
	// Promotion hooks
	Hooks *PromotionHooksDefinitionInput `json:"hooks,omitempty"`
}

// Create Pull Request ad hoc promotion arguments
type CreatePullRequestAdHocPromotionInput struct {
	// Source application id
	SrcAppID *ApplicationIDInput `json:"srcAppId"`
	// Source environment name
	SrcEnvironment string `json:"srcEnvironment"`
	// Destination environment name
	DestEnvironment string `json:"destEnvironment"`
	// Promotion policy
	Policy *PromotionPolicyDefinitionInput `json:"policy"`
	// Last commit info of source application
	CommitInfo *CommitInfoArgs `json:"commitInfo"`
	// List of destination applications ids and pull request data
	Payload []*AhHocPromotionPullRequestFilesArgs `json:"payload"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilter struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template,omitempty"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilterArgs struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template,omitempty"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// DataRetention
type DataRetention struct {
	// Weeks
	Weeks *int `json:"weeks,omitempty"`
}

// DefaultDindResources
type DefaultDindResources struct {
	// Requests
	Requests *ResourcesRequests `json:"requests,omitempty"`
}

// Delete Environment Input
type DeleteEnvironmentArgs struct {
	// Id of the environment
	ID string `json:"id"`
}

// Delete Product Input
type DeleteProductArgs struct {
	// Id of the Product
	ID string `json:"id"`
}

// Deployment entity
type Deployment struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Deployment Entity
	Spec *DeploymentSpec `json:"spec"`
	// Deployment Status
	Status *DeploymentStatus `json:"status,omitempty"`
}

func (Deployment) IsGitopsEntity() {}

func (Deployment) IsBaseEntity() {}

func (Deployment) IsProjectBasedEntity() {}

func (Deployment) IsEntity() {}

// Container
type DeploymentContainer struct {
	// Containers
	Name *string `json:"name,omitempty"`
	// Image
	Image *string `json:"image,omitempty"`
	// ImagePullPolicy
	ImagePullPolicy *ImagePullPolicy `json:"imagePullPolicy,omitempty"`
}

// Deployment Edge
type DeploymentEdge struct {
	// Node contains the actual Deployment data
	Node *Deployment `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (DeploymentEdge) IsEdge() {}

// Stats for deployment frequency
type DeploymentFrequencyStatistics struct {
	// Deployment frequency statistics data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Deployments frequency info
	Info *DoraStatisticsSummery `json:"info"`
}

// Deployment Slice
type DeploymentSlice struct {
	// Deployment edges
	Edges []*DeploymentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (DeploymentSlice) IsSlice() {}

// Deployment Spec
type DeploymentSpec struct {
	// Template
	Template *PodTemplateSpec `json:"template,omitempty"`
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
}

// DeploymentSpecPart
type DeploymentSpecPart struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	// Status
	Status *DeploymentStatus `json:"status,omitempty"`
	// Containers
	Containers []*DeploymentContainer `json:"containers,omitempty"`
}

// Deployment statistics
type DeploymentStatistics struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Deployment statistics data
	Data []*DeploymentStatisticsData `json:"data"`
	// Deplyment statistics total
	Info []*DeploymentStatisticsInfo `json:"info"`
}

// Stats data for deployments - holds daily stats
type DeploymentStatisticsData struct {
	// Time
	Time string `json:"time"`
	// Deployment status
	Status DeploymentStatisticsStatus `json:"status"`
	// Number Of Syncs
	Value int `json:"value"`
}

// Stats info for deployments holds total data for each of the statuses
type DeploymentStatisticsInfo struct {
	// Deployment status
	Status DeploymentStatisticsStatus `json:"status"`
	// Total number of deployments in the given time period
	TotalDeployments *MetricWithTrend `json:"totalDeployments"`
	// Last deployment
	LastDeployment *MetricWithTrend `json:"lastDeployment,omitempty"`
}

// Deployment Status
type DeploymentStatus struct {
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
	// AvailableReplicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
	// ReadyReplicas
	ReadyReplicas *int `json:"readyReplicas,omitempty"`
	// UnavailableReplicas
	UnavailableReplicas *int `json:"unavailableReplicas,omitempty"`
	// UpdatedReplicas
	UpdatedReplicas *int `json:"updatedReplicas,omitempty"`
}

// General stats data
type DoraGeneralStatistics struct {
	// Total
	Total float64 `json:"total"`
}

// General dora metrics stats data
type DoraMetricsGeneralStatistics struct {
	// Deployments
	Deployments *DoraGeneralStatistics `json:"deployments"`
	// Rollback
	Rollbacks *DoraGeneralStatistics `json:"rollbacks"`
	// Failure rate
	FailureRate *DoraGeneralStatistics `json:"failureRate"`
	// Commit / pull request
	CommitOrPullRequests *DoraGeneralStatistics `json:"commitOrPullRequests"`
}

// Stats data for deployment frequency
type DoraStatisticsData struct {
	// Time
	Time string `json:"time"`
	// Number of deployment
	Value float64 `json:"value"`
}

// Stats summery for all dora graphs
type DoraStatisticsSummery struct {
	// Avg
	Summery float64 `json:"summery"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso,omitempty"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

// EntityAbacRules
type EntityAbacRules struct {
	// Id
	ID *string `json:"id,omitempty"`
	// AccountId
	AccountID string `json:"accountId"`
	// EntityType
	EntityType AbacEntityValues `json:"entityType"`
	// Teams
	Teams []string `json:"teams"`
	// Tags
	Tags []*string `json:"tags,omitempty"`
	// Actions
	Actions []AbacActionNames `json:"actions"`
	// Attributes
	Attributes []*AbacAttribute `json:"attributes"`
}

// Entity Reference Meta
type EntityReferenceMeta struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// Environment Entity
type Environment struct {
	// Entity db id
	ID string `json:"id"`
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// Position of the environment on the dashboard
	Position float64 `json:"position"`
	// List of clusters that belong to this environment
	Clusters []*EnvironmentCluster `json:"clusters,omitempty"`
	// List of userIds that mark resource as favorite
	Favorites []string `json:"favorites,omitempty"`
	// Is favorite
	Favorite bool `json:"favorite"`
	// Label pairs array strings(key=value)
	LabelPairs []string `json:"labelPairs,omitempty"`
}

func (Environment) IsFavorableNotK8s() {}

func (Environment) IsFavorableNotK8sEntity() {}

// Environment Cluster
type EnvironmentCluster struct {
	// Runtime name
	RuntimeName string `json:"runtimeName"`
	// Cluster name
	Name string `json:"name"`
	// Cluster address - resolved dynamically, null if cluster doesn't exist
	Server *string `json:"server,omitempty"`
	// Cluster namespaces
	Namespaces []string `json:"namespaces"`
	// Indicate if the cluster still exists
	Exists bool `json:"exists"`
}

// Environment Cluster
type EnvironmentClusterInput struct {
	// Runtime name
	RuntimeName string `json:"runtimeName"`
	// Cluster name
	Name string `json:"name"`
	// Cluster address
	Server *string `json:"server,omitempty"`
	// Cluster namespaces
	Namespaces []string `json:"namespaces"`
}

// EnvironmentConcurrency
type EnvironmentConcurrency struct {
	// Price
	Price *BasePrice `json:"price,omitempty"`
	// Amount
	Amount *int `json:"amount,omitempty"`
	// Min
	Min *int `json:"min,omitempty"`
}

// Args to filter ApplicationGroup
type EnvironmentFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
}

// Environment workflows steps view
type EnvironmentsWorkflowsSteps struct {
	// Environment name
	Environment string `json:"environment"`
	// Product release environment step pre workflows steps view
	PreWorkflowsStepsView []*WorkflowsStepView `json:"preWorkflowsStepsView"`
	// Product release environment step post workflows steps view
	PostWorkflowsStepsView []*WorkflowsStepView `json:"postWorkflowsStepsView"`
	// Pending Pull Requests
	PendingPullRequests []*PullRequest `json:"pendingPullRequests,omitempty"`
	// Applications promoted during the release
	Applications []*ReleaseStepApplicationStatus `json:"applications,omitempty"`
	// Release environment hooks
	Hooks *ProductReleaseHooks `json:"hooks,omitempty"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Git commit date
	CommitDate *string `json:"commitDate,omitempty"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line,omitempty"`
	// Commit url
	CommitURL *string `json:"commitUrl,omitempty"`
	// Commit url with file
	FileURL *string `json:"fileUrl,omitempty"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid,omitempty"`
	// Content of the event
	Data *string `json:"data,omitempty"`
	// Time
	Time *string `json:"time,omitempty"`
	// Event source
	EventSource *EventSource `json:"eventSource,omitempty"`
	// Event name
	EventName *string `json:"eventName,omitempty"`
	// Event type
	EventType *string `json:"eventType,omitempty"`
	// Account
	Account *string `json:"account,omitempty"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
}

func (EventSource) IsBaseEntity() {}

func (EventSource) IsGitopsEntity() {}

func (EventSource) IsProjectBasedEntity() {}

func (EventSource) IsEntity() {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Event source type
type EventSourceType struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// List of the supported events by this event source type. CAP know how to filter this kind of events.
	Events []*SupportedEventMapping `json:"events"`
}

// Args to set favorite for entity
type FavoriteInfoArgs struct {
	// Event-source kind
	Kind string `json:"kind"`
	// Event-source group
	Group string `json:"group"`
	// Event-source group
	Version string `json:"version"`
	// Event-source runtime name
	Runtime string `json:"runtime"`
	// Event-source name
	Name string `json:"name"`
	// Event-source namespace
	Namespace *string `json:"namespace,omitempty"`
	// Event-source cluster URL
	Cluster *string `json:"cluster,omitempty"`
}

// File
type File struct {
	// File full path
	Path string `json:"path"`
	// File revision
	Revision *string `json:"revision,omitempty"`
	// File data
	Data string `json:"data"`
}

// FileSource entity
type FileSource struct {
	// File path
	File string `json:"file"`
	// JSON path to the value in the file
	JSONPath string `json:"jsonPath"`
}

// Flow step
type FlowStep struct {
	// Environment name
	Environment string `json:"environment"`
	// DependsOn array
	DependsOn []string `json:"dependsOn"`
	// Policy
	Policy *PromotionPolicyDefinition `json:"policy,omitempty"`
	// Hooks
	Hooks *PromotionFlowHooks `json:"hooks,omitempty"`
}

// From State Entity
type FromState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Returns runtimes and clusters statistics
type GeneralStatistics struct {
	// Runtimes statistics
	Runtimes *RuntimesStatistics `json:"runtimes"`
	// Clusters statistics
	Clusters *ClustersStatistics `json:"clusters"`
}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
}

func (GenericEntity) IsGitopsEntity() {}

func (GenericEntity) IsBaseEntity() {}

func (GenericEntity) IsProjectBasedEntity() {}

func (GenericEntity) IsEntity() {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// Argo events generic Error Notification
type GenericErrorNotification struct {
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Notification type
	Type *string `json:"type,omitempty"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
}

func (GenericErrorNotification) IsNotification() {}

func (GenericErrorNotification) IsArgoEventsNotification() {}

// GitAuthConfig
type GitAuthConfig struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata,omitempty"`
	// Data
	Data *GitAuthProvidersData `json:"data,omitempty"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Entity source
	Source *GitConfigEntitySource `json:"source,omitempty"`
}

// GitAuthConfig form data object
type GitAuthConfigFormData struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata,omitempty"`
	// Data
	Data *GitAuthProvidersData `json:"data"`
	// Sync status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
}

// GitAuthProviderConfigData
type GitAuthProviderConfig struct {
	// Provider
	Provider string `json:"provider"`
	// Mode
	Mode GitAuthMode `json:"mode"`
	// AppName
	AppName *string `json:"appName,omitempty"`
	// Secret
	Secret *SecretData `json:"secret,omitempty"`
}

// GitAuthProvidersData
type GitAuthProvidersData struct {
	// Config
	Config *GitAuthProviderConfig `json:"config,omitempty"`
}

// GitConfigEntitySource
type GitConfigEntitySource struct {
	// GitSource
	GitSource *string `json:"gitSource,omitempty"`
	// RepoURL
	RepoURL *string `json:"repoURL,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage,omitempty"`
	// CommitDate
	CommitDate *string `json:"commitDate,omitempty"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// SyncStartedAt
	SyncStartedAt *string `json:"syncStartedAt,omitempty"`
	// SyncFinishedAt
	SyncFinishedAt *string `json:"syncFinishedAt,omitempty"`
	// ResourceAction
	ResourceAction *ResourceAction `json:"resourceAction,omitempty"`
}

// Product Release step git issue
type GitIssue struct {
	// Application Name
	ApplicationName string `json:"applicationName"`
	// Issue date
	Date string `json:"date"`
	// Error message
	Message string `json:"message"`
	// Issue type
	Type IssueType `json:"type"`
	// Error level
	Level ErrorLevels `json:"level"`
}

func (GitIssue) IsIssueKind() {}

func (GitIssue) IsIssue() {}

// GitOpsLimits
type GitOpsLimits struct {
	// Applications limit
	Applications *int `json:"applications,omitempty"`
	// Clusters limit
	Clusters *int `json:"clusters,omitempty"`
}

// GitOps settings
type GitOpsSettings struct {
	// Account id
	AccountID string `json:"accountId"`
	// Is hide runtime hosted boxes in ui
	IsHideHostedRuntimeBoxes bool `json:"isHideHostedRuntimeBoxes"`
}

// GitOpsUsage
type GitOpsUsage struct {
	// Applications usage
	Applications *int `json:"applications,omitempty"`
	// Clusters usage
	Clusters *int `json:"clusters,omitempty"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged,omitempty"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork,omitempty"`
	// PR comment
	Comment *GitPRComment `json:"comment,omitempty"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles,omitempty"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation,omitempty"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// PR data
	Pr *GitPr `json:"pr,omitempty"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}

func (GitPREventPayloadData) IsEventPayloadData() {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *WorkflowRepository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles,omitempty"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha,omitempty"`
	// SHA URL
	ShaURL *string `json:"shaURL,omitempty"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}

func (GitPushEventPayloadData) IsEventPayloadData() {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles,omitempty"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// Release data
	Release *GitRelease `json:"release,omitempty"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}

func (GitReleaseEventPayloadData) IsEventPayloadData() {}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self,omitempty"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Is this a restricted git-source
	IsRestricted bool `json:"isRestricted"`
	// Restricted Git Source details
	RestrictedDetails *RestrictedGitSourceDetails `json:"restrictedDetails,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Permissions to this git source
	Permissions []*Permission `json:"permissions"`
}

func (GitSource) IsK8sLogicEntity() {}

func (GitSource) IsBaseEntity() {}

func (GitSource) IsProjectBasedEntity() {}

func (GitSource) IsEntity() {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git Source Notification
type GitSourceNotification struct {
	// Commit information that triggered sync
	Source *GitopsEntitySource `json:"source,omitempty"`
	// Link to the git-source in git provider
	GsRepoLink *string `json:"gsRepoLink,omitempty"`
	// Sync status
	GsSyncStatus SyncStatus `json:"gsSyncStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (GitSourceNotification) IsNotification() {}

func (GitSourceNotification) IsArgoCDNotification() {}

func (GitSourceNotification) IsGitOpsNotification() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}

func (GitUnknownEventPayloadData) IsEventPayloadData() {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Github trigger conditions
type GithubTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Base url for github enterprise
	BaseURL *string `json:"baseUrl,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters chosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Github trigger conditions
type GithubTriggerConditionsArgs struct {
	// Specific github event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Base url for github enterprise
	BaseURL *string `json:"baseUrl,omitempty"`
	// Repositories
	Repositories []*string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// Gitlab trigger conditions
type GitlabTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Gitlab enterprise url
	BaseURL *string `json:"baseUrl,omitempty"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Gitlab trigger conditions
type GitlabTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Base url
	BaseURL *string `json:"baseUrl,omitempty"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// GitopsAccount
type GitopsAccount struct {
	// AccountId
	ID string `json:"id"`
	// GitopsUsage
	GitopsUsage *AccountGitopsUsage `json:"gitopsUsage,omitempty"`
}

// Gitops entity source
type GitopsEntitySource struct {
	// Source application name
	AppName *string `json:"appName,omitempty"`
	// Source application namespace
	AppNamespace *string `json:"appNamespace,omitempty"`
	// Entity codefresh git source
	GitSource *GitSource `json:"gitSource,omitempty"`
	// Repo URL
	RepoURL *string `json:"repoURL,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL,omitempty"`
	// Git revision
	Revision *string `json:"revision,omitempty"`
	// Git commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Git commit date
	CommitDate *string `json:"commitDate,omitempty"`
	// Git commit web url
	CommitURL *string `json:"commitURL,omitempty"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// Author web profile url
	ProfileURL *string `json:"profileURL,omitempty"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL,omitempty"`
	// Git manifest
	GitManifest *string `json:"gitManifest,omitempty"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction,omitempty"`
}

// Gitops Release Entity
type GitopsRelease struct {
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
	// History id
	HistoryID int `json:"historyId"`
	// Sync operation revision. For multi-sourced apps it's revisions joined by underscore
	SyncOperationRevision string `json:"syncOperationRevision"`
	// Related argocd history id
	ArgoHistoryID *int `json:"argoHistoryId,omitempty"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Operation State (argo)
	OperationState *ApplicationOperationState `json:"operationState,omitempty"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState,omitempty"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
	// Current release flag
	Current *bool `json:"current,omitempty"`
}

// Args to define application
type GitopsReleaseApplicationArgs struct {
	// App Group name
	AppGroupName *string `json:"appGroupName,omitempty"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Group
	Group *string `json:"group,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
	// Kind
	Kind *string `json:"kind,omitempty"`
}

// Gitops Release chart record
type GitopsReleaseChartRecord struct {
	// Date
	Date string `json:"date"`
	// Date
	Releases []*GitopsReleaseChartRelease `json:"releases"`
}

// Gitops Release chart release
type GitopsReleaseChartRelease struct {
	// Date
	SyncStartedAt *string `json:"syncStartedAt,omitempty"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// History id
	HistoryID int `json:"historyId"`
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
}

// Release Edge
type GitopsReleaseEdge struct {
	// Node contains the actual application data
	Node *GitopsRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter release
type GitopsReleaseFilterArgs struct {
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Group
	Group *string `json:"group,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
	// Kind
	Kind *string `json:"kind,omitempty"`
	// HistoryId
	HistoryID *int `json:"historyId,omitempty"`
	// Issue key
	IssueKey *string `json:"issueKey,omitempty"`
	// PR key
	PrKey *string `json:"prKey,omitempty"`
	// Committer
	Committer *string `json:"committer,omitempty"`
	// Issue key array
	IssueKeys []string `json:"issueKeys,omitempty"`
	// PR key array
	PrKeys []string `json:"prKeys,omitempty"`
	// Committers array
	Committers []string `json:"committers,omitempty"`
	// Filter workflows from a specific start date
	SyncStartDateFrom *string `json:"syncStartDateFrom,omitempty"`
	// Filter workflows to a specific start date
	SyncStartDateTo *string `json:"syncStartDateTo,omitempty"`
	// Start date
	StartDate *string `json:"startDate,omitempty"`
	// End date
	EndDate *string `json:"endDate,omitempty"`
	// Jira report filter
	JiraReportFilter *bool `json:"jiraReportFilter,omitempty"`
	// App Group name
	AppGroupName *string `json:"appGroupName,omitempty"`
}

// Gitops Release Slice
type GitopsReleaseSlice struct {
	// Release edges
	Edges []*GitopsReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// GoogleSSO
type GoogleSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// ClientHost
	ClientHost *string `json:"clientHost,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Keyfile
	Keyfile *string `json:"keyfile,omitempty"`
	// Subject
	Subject *string `json:"subject,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// SyncField
	SyncField *string `json:"syncField,omitempty"`
}

func (GoogleSso) IsIDP() {}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion,omitempty"`
	// The entity related to this error
	Object BaseEntity `json:"object,omitempty"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// Health Error Input
type HealthErrorInput struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Message
	Message string `json:"message"`
}

// Workflow template ref Hierarchy
type HierarchyRef struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Ref line number
	Line *int `json:"line,omitempty"`
}

// WorkflowTemplate Hierarchy Step
type HierarchyStep struct {
	// Step name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line,omitempty"`
}

// WorkflowTemplate Steps Template
type HierarchyTemplate struct {
	// Template name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line,omitempty"`
	// Steps
	Steps []*HierarchyStep `json:"steps,omitempty"`
}

// WorkflowTemplate templates hierarchy
type HierarchyTemplates struct {
	// WorkflowTemlate name
	Name *string `json:"name,omitempty"`
	// WorkflowTemlate name line number
	Line *int `json:"line,omitempty"`
	// WorkflowTemplate templates structer heiarchy
	Steps []*HierarchyTemplate `json:"steps,omitempty"`
	// WorkflowTemplate templates structer heiarchy
	Refs []*HierarchyRef `json:"refs,omitempty"`
}

// Hook Error
type HookError struct {
	// Hook error message
	Message string `json:"message"`
	// Hook error date
	Date string `json:"date"`
}

// Image application
type ImageApplication struct {
	// Application Ref metadata
	ApplicationRef *ObjectMeta `json:"applicationRef"`
	// Argo CD application destination config
	ApplicationDestination *ArgoCDApplicationDestination `json:"applicationDestination,omitempty"`
	// Application git info
	ApplicationGitInfo *ImageApplicationGitInfo `json:"applicationGitInfo,omitempty"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Image service name
	ServiceName *string `json:"serviceName,omitempty"`
	// Related binary
	Binary *ImageBinary `json:"binary,omitempty"`
	// Currently deployed
	CurrentlyDeployed bool `json:"currentlyDeployed"`
	// Image name
	ImageName *string `json:"imageName,omitempty"`
	// Image registry domain
	ImageRegistryDomain ImageRegistryType `json:"imageRegistryDomain"`
}

// Application Commit Author
type ImageApplicationCommitAuthor struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Profile Url
	ProfileURL *string `json:"profileUrl,omitempty"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// Image Application Git Info
type ImageApplicationGitInfo struct {
	// Git repo url
	RepoURL *string `json:"repoURL,omitempty"`
	// Git branch
	Branch *string `json:"branch,omitempty"`
	// Commit author
	Author *ImageApplicationCommitAuthor `json:"author,omitempty"`
	// Commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Commit url
	CommitURL *string `json:"commitUrl,omitempty"`
}

// Image binary info
type ImageBinariesInfo struct {
	// ImageBinaries
	Images []*ImageBinary `json:"images"`
	// PRs annotations
	Prs []*Annotation `json:"prs,omitempty"`
	// Issues annotations
	Issues []*Annotation `json:"issues,omitempty"`
	// Generic annotations
	Annotations []*Annotation `json:"annotations,omitempty"`
	// Dockerfile
	DockerFile *string `json:"dockerFile,omitempty"`
	// Branch
	Branch *string `json:"branch,omitempty"`
	// Commit
	Commit *string `json:"commit,omitempty"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	// CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	// Git repository
	GitRepository *string `json:"gitRepository,omitempty"`
	//  Runtime
	Runtime *RuntimeInfo `json:"runtime,omitempty"`
	// Author
	Author *ImageBinaryAuthor `json:"author,omitempty"`
}

// Image binary entity
type ImageBinary struct {
	//  Runtime
	Runtime *RuntimeInfo `json:"runtime,omitempty"`
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// ImageName
	ImageName string `json:"imageName"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Branch
	Branch *string `json:"branch,omitempty"`
	// Commit
	Commit *string `json:"commit,omitempty"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	// CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	// Git repository
	GitRepository *string `json:"gitRepository,omitempty"`
	// Git provider
	GitProvider *string `json:"gitProvider,omitempty"`
	//  AccountId
	AccountID string `json:"accountId"`
	//  DockerFile
	DockerFile *string `json:"dockerFile,omitempty"`
	// Size
	Size *float64 `json:"size,omitempty"`
	// OS
	Os *string `json:"os,omitempty"`
	// Architecture
	Architecture *string `json:"architecture,omitempty"`
	// Info
	Info *string `json:"info,omitempty"`
	// Author
	Author *ImageBinaryAuthor `json:"author,omitempty"`
	// Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CI provider
	CiProvider *string `json:"ciProvider,omitempty"`
	// Logs url
	LogsURL *string `json:"logsUrl,omitempty"`
	// Image registry
	ImageRegistryDomains []ImageRegistryType `json:"imageRegistryDomains"`
	// Image hash
	Hash *string `json:"hash,omitempty"`
	// Image internal ID
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Image repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Image domain
	ImageDomain ImageRegistryType `json:"imageDomain"`
}

func (ImageBinary) IsEntity() {}

// ImageBinaryAuthor
type ImageBinaryAuthor struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Full name
	FullName *string `json:"fullName,omitempty"`
	// Profile Url
	ProfileURL *string `json:"profileUrl,omitempty"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// ImageBinaryAuthorOutput
type ImageBinaryAuthorOutput struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Avatar URL
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// Image Binary Edge
type ImageBinaryEdge struct {
	// Node contains the actual image binary data
	Node *ImageBinary `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageBinaryEdge) IsEdge() {}

// ImageBinaryOutput
type ImageBinaryOutput struct {
	//  Id
	ID string `json:"id"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch,omitempty"`
	//  Commit
	Commit *string `json:"commit,omitempty"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	//  CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	//  DockerFile
	DockerFile *string `json:"dockerFile,omitempty"`
	//  Size
	Size *float64 `json:"size,omitempty"`
	//  Os
	Os *string `json:"os,omitempty"`
	//  Architecture
	Architecture *string `json:"architecture,omitempty"`
	//  Info
	Info *string `json:"info,omitempty"`
	//  Info
	Author *ImageBinaryAuthorOutput `json:"author,omitempty"`
	//  Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CI provider
	CiProvider *string `json:"ciProvider,omitempty"`
	// Logs url
	LogsURL *string `json:"logsUrl,omitempty"`
	// Image hash
	Hash *string `json:"hash,omitempty"`
	// Image internal ID
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Image repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
}

// Images Binary Slice
type ImageBinarySlice struct {
	// Image edges
	Edges []*ImageBinaryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageBinarySlice) IsSlice() {}

// Image Details
type ImageDetails struct {
	// Image name
	Name *string `json:"name,omitempty"`
	// Registry type
	Type *ImageRegistryType `json:"type,omitempty"`
	// Link
	Link *string `json:"link,omitempty"`
}

// ImageLayerOutput
type ImageLayerOutput struct {
	// Created
	Created string `json:"created"`
	// Instruction
	Instruction string `json:"instruction"`
	// Size
	Size float64 `json:"size"`
	// Args
	Args *string `json:"args,omitempty"`
}

// ImageLayersOutput
type ImageLayersOutput struct {
	// AccountId
	AccountID string `json:"accountId"`
	// Created
	Created string `json:"created"`
	// Image
	Image string `json:"image"`
	// LayerDigests
	LayerDigests []string `json:"layerDigests,omitempty"`
	// Layers
	Layers []*ImageLayerOutput `json:"layers"`
}

// Image Registry entity
type ImageRegistry struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	//  AccountId
	AccountID string `json:"accountId"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Tags
	Tags []*ImageTag `json:"tags"`
	// Registry
	Registry *Registry `json:"registry"`
	// Image internal id
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Architecture
	Architecture *string `json:"architecture,omitempty"`
	// Parent repo digest
	ParentRepoDigest *string `json:"parentRepoDigest,omitempty"`
	// Is object is manifest list
	ManifestList *bool `json:"manifestList,omitempty"`
}

func (ImageRegistry) IsEntity() {}

// Image Registry Edge
type ImageRegistryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRegistry `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRegistryEdge) IsEdge() {}

// ImageRegistryOutput
type ImageRegistryOutput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName *string `json:"imageName,omitempty"`
	// Repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Tags
	Tags []*ImageTagOutput `json:"tags,omitempty"`
	// Registry
	Registry *RegistryOutput `json:"registry,omitempty"`
	// Image internal id
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Parent repo digest
	ParentRepoDigest *string `json:"parentRepoDigest,omitempty"`
	// Is object is manifest list.
	ManifestList *bool `json:"manifestList,omitempty"`
}

// Images Registry Slice
type ImageRegistrySlice struct {
	// Image registry edges
	Edges []*ImageRegistryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRegistrySlice) IsSlice() {}

// Image Repo Tag entity
type ImageRepoTag struct {
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Created Date
	Created string `json:"created"`
	// Related binaries
	Binaries []*ImageBinary `json:"binaries,omitempty"`
	// Image applications
	Applications []*ImageApplication `json:"applications,omitempty"`
}

func (ImageRepoTag) IsEntity() {}

// Image repo tag Edge
type ImageRepoTagEdge struct {
	// Node contains the actual image repo tag data
	Node *ImageRepoTag `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepoTagEdge) IsEdge() {}

// Images repo tag Slice
type ImageRepoTagSlice struct {
	// Image Repository edges
	Edges []*ImageRepoTagEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepoTagSlice) IsSlice() {}

// Image Repository entity
type ImageRepository struct {
	// Image repository name
	Name string `json:"name"`
	// Account Id
	AccountID string `json:"accountId"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// Image repository registry domain types
	RegistryDomains []ImageRegistryType `json:"registryDomains"`
	// Image applications
	Applications []*ImageApplication `json:"applications"`
}

func (ImageRepository) IsEntity() {}

// Image Repository Edge
type ImageRepositoryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRepository `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepositoryEdge) IsEdge() {}

// Images Repository Slice
type ImageRepositorySlice struct {
	// Image Repository edges
	Edges []*ImageRepositoryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepositorySlice) IsSlice() {}

// ImageTag
type ImageTag struct {
	// Registry
	Registry *string `json:"registry,omitempty"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagOutput struct {
	// Registry
	Registry *string `json:"registry,omitempty"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// Images Entity
type Images struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Image
	Image *string `json:"image,omitempty"`
	// RepositoryName
	RepositoryName *string `json:"repositoryName,omitempty"`
	// BinaryId
	BinaryID *string `json:"binaryId,omitempty"`
	// Image tag
	Tag *string `json:"tag,omitempty"`
	// WorkflowName
	WorkflowName *string `json:"workflowName,omitempty"`
	// WorkflowUrl
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CiProvider
	CiProvider *string `json:"ciProvider,omitempty"`
}

// Ingress
type Ingress struct {
	// Hostname
	Hostname *string `json:"hostname,omitempty"`
	// Ip
	IP *string `json:"ip,omitempty"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Input for Argo CD Application destination config
type InputArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Cluster url
	Server *string `json:"server,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Integration entity
type IntegrationConfig struct {
	// Object Metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this entity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self,omitempty"`
	// Integration Type
	IntegrationType string `json:"integrationType"`
	// Integration Type
	ProviderInfo *string `json:"providerInfo,omitempty"`
}

func (IntegrationConfig) IsBaseEntity() {}

func (IntegrationConfig) IsGitopsEntity() {}

func (IntegrationConfig) IsProjectBasedEntity() {}

// Application Edge
type IntegrationEdge struct {
	// Node contains the actual application data
	Node *IntegrationEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Integration
type IntegrationEntity struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Integration type usually consists of `<type>.<subtype>`, for example `issue.jira`.
	//
	// Take a look on libs/db/src/entities/common/integration/operation-state.types.ts to see the allowed values
	Type *string `json:"type,omitempty"`
	// Provider info contains all non-secure data related to the integration,
	// for example `host` and `username` for `registry.quay` integration.
	//
	// Depends on the integration `type`
	ProviderInfo *string `json:"providerInfo,omitempty"`
	// Runtimes
	Runtimes []string `json:"runtimes,omitempty"`
	// Sync Status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
	// All runtimes enabled
	IsAllRuntimes *bool `json:"isAllRuntimes,omitempty"`
	// Enabled integration consumers
	EnabledIntegrationConsumers []*IntegrationConsumer `json:"enabledIntegrationConsumers,omitempty"`
}

// Args to filter annotation
type IntegrationFilterArgs struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Integration type usually consists of `<type>.<subtype>`, for example `issue.jira`.
	//
	// Take a look on libs/db/src/entities/common/integration/operation-state.types.ts to see the allowed values
	Type *string `json:"type,omitempty"`
	// Category type
	CategoryType *string `json:"categoryType,omitempty"`
	// Ci tool
	CiTool *SupportedCITools `json:"ciTool,omitempty"`
	// Runtime name
	Runtime *string `json:"runtime,omitempty"`
	// Include default integrations
	IncludeDefaultIntegrations *bool `json:"includeDefaultIntegrations,omitempty"`
	// Enabled Integration Consumers
	EnabledIntegrationConsumers []*IntegrationConsumer `json:"enabledIntegrationConsumers,omitempty"`
	// Exclude not supported enrichment integrations
	ExcludeNotSupportedEnrichment *bool `json:"excludeNotSupportedEnrichment,omitempty"`
}

// IntegrationGenerationInput
type IntegrationGenerationInput struct {
	// Metadata
	Metadata *IntegrationGenerationMetadata `json:"metadata"`
	// Provider info
	ProviderInfo string `json:"providerInfo"`
	// Intended operation over integration
	Operation ResourceOperation `json:"operation"`
	// Yaml containing encrypted sealed secret
	SealedSecretYaml *string `json:"sealedSecretYaml,omitempty"`
	// Sealet secret git details of currently existing integration
	SealedSecretGitData *AppResourceGitManifestInput `json:"sealedSecretGitData,omitempty"`
	// Config map git details of currently existing integration
	ConfigMapGitData *AppResourceGitManifestInput `json:"configMapGitData,omitempty"`
}

// IntegrationGenerationInput
type IntegrationGenerationMetadata struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
	// Runtimes
	Runtimes []string `json:"runtimes"`
	// IsAllRuntimes
	IsAllRuntimes bool `json:"isAllRuntimes"`
	// Enabled Integration Consumers
	EnabledIntegrationConsumers []*IntegrationConsumer `json:"enabledIntegrationConsumers,omitempty"`
}

// IntegrationGenerationInput
type IntegrationGenerationOutput struct {
	// Operations
	Operations []*RuntimeOperation `json:"operations"`
	// Manifests
	Manifests []*ResourceManifest `json:"manifests"`
}

// Integration entity
type IntegrationSecret struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self,omitempty"`
	// Integration Type
	IntegrationType string `json:"integrationType"`
	// Integration Name
	IntegrationName string `json:"integrationName"`
	// Secret Type
	SecretType SecretType `json:"secretType"`
}

func (IntegrationSecret) IsBaseEntity() {}

func (IntegrationSecret) IsGitopsEntity() {}

func (IntegrationSecret) IsProjectBasedEntity() {}

// Integration Slice
type IntegrationSlice struct {
	// Integration edges
	Edges []*IntegrationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Invoice
type Invoice struct {
	// Id
	ID string `json:"id"`
	// Number
	Number *string `json:"number,omitempty"`
	// Created
	Created int `json:"created"`
	// Invoice Pdf
	InvoicePDF *string `json:"invoicePdf,omitempty"`
	// Amount Paid
	AmountPaid int `json:"amountPaid"`
	// Total
	Total int `json:"total"`
	// Paid At
	PaidAt *int `json:"paidAt,omitempty"`
	// Payment Method
	PaymentMethod *PaymentMethod `json:"paymentMethod,omitempty"`
	// Status
	Status InvoiceStatus `json:"status"`
}

// Issue value
type IssueValue struct {
	// Issue url
	URL string `json:"url"`
	// Issue title
	Title string `json:"title"`
	// Issue status
	Status string `json:"status"`
	// Issue avatar URL
	AvatarURL *string `json:"avatarURL,omitempty"`
	// Issue assignee
	Assignee *string `json:"assignee,omitempty"`
}

// Jira command
type JiraCommand struct {
	// Command
	Command *string `json:"command,omitempty"`
}

// Jira Deployments
type JiraDeployment struct {
	// DeploymentSequenceNumber
	DeploymentSequenceNumber float64 `json:"deploymentSequenceNumber"`
	// UpdateSequenceNumber
	UpdateSequenceNumber float64 `json:"updateSequenceNumber"`
	// IssueKeys
	IssueKeys []*string `json:"issueKeys,omitempty"`
	// Associations
	Associations []*string `json:"associations,omitempty"`
	// DisplayName
	DisplayName string `json:"displayName"`
	// Url
	URL string `json:"url"`
	// Description
	Description string `json:"description"`
	// LastUpdated
	LastUpdated string `json:"lastUpdated"`
	// Label
	Label *string `json:"label,omitempty"`
	// State
	State *string `json:"state,omitempty"`
	// Pipeline
	Pipeline *JiraPipeline `json:"pipeline"`
	// Environment
	Environment *JiraEnvironment `json:"environment"`
	// Commands
	Commands []*JiraCommand `json:"commands,omitempty"`
	// SchemaVersion
	SchemaVersion *string `json:"schemaVersion,omitempty"`
}

// jira Deployments output
type JiraDeploymentsOutput struct {
	// Jira Deployment
	Deployments []*JiraDeployment `json:"deployments"`
	// Exist Candidates To Report
	ExistCandidatesToReport *bool `json:"existCandidatesToReport,omitempty"`
}

// Jira environment
type JiraEnvironment struct {
	// Id
	ID string `json:"id"`
	// DisplayName
	DisplayName string `json:"displayName"`
	// Type
	Type string `json:"type"`
}

// Jira pipeline
type JiraPipeline struct {
	// Id
	ID string `json:"id"`
	// DisplayName
	DisplayName string `json:"displayName"`
	// Url
	URL string `json:"url"`
}

// K8s entity id
type K8sEntityID struct {
	// name
	Name string `json:"name"`
	// namespace
	Namespace *string `json:"namespace,omitempty"`
}

// KeycloakSSO
type KeycloakSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Host
	Host *string `json:"host,omitempty"`
	// Realm
	Realm *string `json:"realm,omitempty"`
}

func (KeycloakSso) IsIDP() {}

// Label arrays
type LabelArrays struct {
	// Key
	Key string `json:"key"`
	// Value
	Value []string `json:"value"`
}

// LdapSSO
type LdapSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Password
	Password *string `json:"password,omitempty"`
	// URL
	URL *string `json:"url,omitempty"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// Search base
	SearchBase *string `json:"searchBase,omitempty"`
	// Search filter
	SearchFilter *string `json:"searchFilter,omitempty"`
	// Certificate
	Certificate *string `json:"certificate,omitempty"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync,omitempty"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync,omitempty"`
	// Remove deactivated users after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
	// AutoGroupSync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
}

func (LdapSso) IsIDP() {}

// Stats for lead time for changes statistics
type LeadTimeForChangesStatistics struct {
	// Lead time for changes statistics data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Lead time for changes statistics info
	Info *DoraStatisticsSummery `json:"info"`
}

// LimitsStatus
type LimitsStatus struct {
	// Plan Type
	PlanType PlanTypes `json:"planType"`
	// Usage
	Usage *GitOpsUsage `json:"usage"`
	// Limits
	Limits *GitOpsLimits `json:"limits"`
	// Status
	Status bool `json:"status"`
}

// LoadBalancer
type LoadBalancer struct {
	// Ingress
	Ingress []*Ingress `json:"ingress,omitempty"`
}

// Logic entity id
type LogicEntityID struct {
	// id
	ID string `json:"id"`
}

// Mapping between the var name and the path to the value in event payload
type Mapping struct {
	// Name of the variable
	VarName string `json:"varName"`
	// Description of the variable
	Description string `json:"description"`
	// Indicates if the mapping should be used in filtering expressions. Some mappings can be useless for filtering, like GIT_REPO that will be the same for each event.
	Filter bool `json:"filter"`
}

// MetricMeasurement
type MetricMeasurement struct {
	// Finished at date
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Started at date
	StartedAt *string `json:"startedAt,omitempty"`
	// Analysis Phase
	Phase *AnalysisPhases `json:"phase,omitempty"`
	// Measurements metadata object (@job-name etc.)
	Metadata *string `json:"metadata,omitempty"`
	// Measurement value
	Value *string `json:"value,omitempty"`
}

// Metric result
type MetricResult struct {
	// Name
	Name string `json:"name"`
	// Provider type
	ProviderType AnalysisMetricProviderTypes `json:"providerType"`
	// Phase
	Phase AnalysisPhases `json:"phase"`
	// Measurements
	Measurements []*MetricMeasurement `json:"measurements"`
	// Message
	Message *string `json:"message,omitempty"`
	// Successful measurements
	Successful *int `json:"successful,omitempty"`
	// Failed measurements
	Failed *int `json:"failed,omitempty"`
	// Inconclusive measurements
	Inconclusive *int `json:"inconclusive,omitempty"`
	// Error measurements
	Error *int `json:"error,omitempty"`
	// Failure Limit
	FailureLimit *int `json:"failureLimit,omitempty"`
	// Inconclusive Limit
	InconclusiveLimit *int `json:"inconclusiveLimit,omitempty"`
	// Measurements count
	Count *int `json:"count,omitempty"`
	// Consecutive error limit
	ConsecutiveErrorLimit *int `json:"consecutiveErrorLimit,omitempty"`
}

// Pipeline metric with trend
type MetricWithTrend struct {
	// Metric value
	Value int `json:"value"`
	// Percent Diff between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Mutation root
type Mutation struct {
}

// Object with name / value / code fields
type NameValueCodeOutput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
	// Code
	Code *bool `json:"code,omitempty"`
}

// Object with name and value fields
type NameValueOutput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
}

// Named Resource
type NamedResource struct {
	// Name
	Name string `json:"name"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName *string `json:"templateName,omitempty"`
	// Node children
	Children []*string `json:"children,omitempty"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase,omitempty"`
	// Progress
	Progress *string `json:"progress,omitempty"`
	// Message
	Message *string `json:"message,omitempty"`
	// Start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Inputs
	Inputs *string `json:"inputs,omitempty"`
	// Outputs
	Outputs *string `json:"outputs,omitempty"`
	// Script
	Script *string `json:"script,omitempty"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id,omitempty"`
	// Resources Duration
	ResourcesDuration *string `json:"resourcesDuration,omitempty"`
	// Template Ref
	TemplateRef *string `json:"templateRef,omitempty"`
	// Host node name
	HostNodeName *string `json:"hostNodeName,omitempty"`
	// Template
	Template *string `json:"template,omitempty"`
	// Template scope
	TemplateScope *string `json:"templateScope,omitempty"`
}

// Notification Edge
type NotificationEdge struct {
	// Node contains the actual notification data
	Node Notification `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Notification Slice
type NotificationSlice struct {
	// Notification edges
	Edges []*NotificationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Runtime
	Runtime string `json:"runtime"`
	// Cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels,omitempty"`
	// Annotations
	Annotations []*StringPair `json:"annotations,omitempty"`
	// Last updated
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Created
	Created *string `json:"created,omitempty"`
	// K8s object uid
	UID *string `json:"uid,omitempty"`
	// Favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Revision number
	Revision *int `json:"revision,omitempty"`
}

// OktaSSO
type OktaSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// AutoGroupSync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// App Id
	AppID *string `json:"appId,omitempty"`
	// Sync mirror accounts
	SyncMirrorAccounts []*string `json:"syncMirrorAccounts,omitempty"`
	// Remove deactivated users after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
}

func (OktaSso) IsIDP() {}

// "get one time token for a user
type OneTimeToken struct {
	// One time access token
	AccessToken string `json:"accessToken"`
}

// OneloginSSO
type OneloginSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// API client id
	APIClientID *string `json:"apiClientId,omitempty"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret,omitempty"`
}

func (OneloginSso) IsIDP() {}

// Pack
type Pack struct {
	// Metadata
	Metadata *PackMetadata `json:"metadata,omitempty"`
	// Workflows
	Workflows *WorkflowConcurrency `json:"workflows,omitempty"`
	// Runtime
	Runtime *PackRuntime `json:"runtime,omitempty"`
	// Id
	ID *string `json:"id,omitempty"`
}

// PackMetadata
type PackMetadata struct {
	// Description
	Description *string `json:"description,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
}

// PackRuntime
type PackRuntime struct {
	// DefaultDindResources
	DefaultDindResources *DefaultDindResources `json:"defaultDindResources,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// OS
	Os *string `json:"os,omitempty"`
	// Architecture
	Architecture *string `json:"architecture,omitempty"`
	// CPU
	CPU *string `json:"cpu,omitempty"`
	// Memory
	Memory *string `json:"memory,omitempty"`
	// Storage
	Storage *string `json:"storage,omitempty"`
	// DindStorage
	DindStorage *string `json:"dindStorage,omitempty"`
}

// Parent workflow reference
type ParentWorkflowRef struct {
	// Parent workflow
	Workflow *Workflow `json:"workflow,omitempty"`
	// Parent workflow type
	Type *string `json:"type,omitempty"`
}

// PastDue
type PastDue struct {
	// IsPastDue
	IsPastDue *bool `json:"isPastDue,omitempty"`
	// ShowPastDueWarning
	ShowPastDueWarning *bool `json:"showPastDueWarning,omitempty"`
}

// PaymentMethod
type PaymentMethod struct {
	// Type
	Type PaymentType `json:"type"`
	// Brand
	Brand *string `json:"brand,omitempty"`
	// Last 4 digits
	Last4 *string `json:"last4,omitempty"`
	// Bank Name
	BankName *string `json:"bankName,omitempty"`
}

// Payment Plan
type PaymentPlan struct {
	// Trial Data
	Trial *Trial `json:"trial,omitempty"`
	// Plan Id
	ID *string `json:"id,omitempty"`
	// IsWiredTransfer
	IsWiredTransfer *bool `json:"isWiredTransfer,omitempty"`
	// Payment Provider
	Provider *string `json:"provider,omitempty"`
	// PlanType
	PlanType *PlanTypes `json:"planType,omitempty"`
}

// Payment Source
type PaymentSource struct {
	// Id
	ID string `json:"id"`
	// Object
	Object string `json:"object"`
	// Address City
	AddressCity *string `json:"addressCity,omitempty"`
	// Address Country
	AddressCountry *string `json:"addressCountry,omitempty"`
	// Address Line1
	AddressLine1 *string `json:"addressLine1,omitempty"`
	// Address Line1 Check
	AddressLine1Check *string `json:"addressLine1Check,omitempty"`
	// Address Line2
	AddressLine2 *string `json:"addressLine2,omitempty"`
	// Address State
	AddressState *string `json:"addressState,omitempty"`
	// Address Zip
	AddressZip *string `json:"addressZip,omitempty"`
	// Address Zip Check
	AddressZipCheck *string `json:"addressZipCheck,omitempty"`
	// Brand
	Brand string `json:"brand"`
	// Country
	Country *string `json:"country,omitempty"`
	// Customer
	Customer *string `json:"customer,omitempty"`
	// CVC Check
	CvcCheck *string `json:"cvcCheck,omitempty"`
	// Dynamic Last4
	DynamicLast4 *string `json:"dynamicLast4,omitempty"`
	// Exp Month
	ExpMonth *int `json:"expMonth,omitempty"`
	// Exp Year
	ExpYear *int `json:"expYear,omitempty"`
	// Fingerprint
	Fingerprint *string `json:"fingerprint,omitempty"`
	// Funding
	Funding string `json:"funding"`
	// Last4
	Last4 string `json:"last4"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Tokenization Method
	TokenizationMethod *string `json:"tokenizationMethod,omitempty"`
	// Wallet
	Wallet *string `json:"wallet,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
}

// Permission model
type Permission struct {
	// The id of the user with the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
	// Deprecated: The user with the permission
	User *User `json:"user"`
}

// Permission input
type PermissionInput struct {
	// The id of the user the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self,omitempty"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics,omitempty"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity,omitempty"`
}

func (Pipeline) IsBaseEntity() {}

func (Pipeline) IsK8sLogicEntity() {}

func (Pipeline) IsProjectBasedEntity() {}

func (Pipeline) IsEntity() {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration,omitempty"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Stats info for pipeline success rate.
type PipelineClassicStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Value for the all time period
	Value *MetricWithTrend `json:"value,omitempty"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Committers
	Committers *int `json:"committers,omitempty"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Pipeline config
type PipelineConfig struct {
	// General Pipeline Config
	General *PipelineConfigGeneral `json:"general,omitempty"`
	// Pipeline YAML Config
	Yaml *PipelineConfigYaml `json:"yaml,omitempty"`
	// Pipeline Execution Config
	Execution *PipelineConfigExecution `json:"execution,omitempty"`
	// Pending Approval Config
	PendingApproval *PipelineConfigPendingApproval `json:"pendingApproval,omitempty"`
	// Pipeline service account
	ServiceAccount *string `json:"serviceAccount,omitempty"`
	// Enable argo workflows pipelines
	EnableArgoWorkflows *bool `json:"enableArgoWorkflows,omitempty"`
}

// Pipeline Execution Config
type PipelineConfigExecution struct {
	// Keeping PVS for pending approval steps
	KeepPVCsForPendingApproval *bool `json:"keepPVCsForPendingApproval,omitempty"`
	// Include builds that are pending for approval to the number of concurrent builds
	PendingApprovalConcurrencyApplied *bool `json:"pendingApprovalConcurrencyApplied,omitempty"`
	// Marketplace registry
	MarketplaceRegistry *string `json:"marketplaceRegistry,omitempty"`
}

// General Pipeline Config
type PipelineConfigGeneral struct {
	// Templates
	Templates *bool `json:"templates,omitempty"`
	// Clone
	Clone *bool `json:"clone,omitempty"`
}

// Pipeline Execution Config
type PipelineConfigPendingApproval struct {
	// Pending approval confirmation modal window
	PendingApprovalConfirmation *string `json:"pendingApprovalConfirmation,omitempty"`
}

// Pipeline YAML Config
type PipelineConfigYaml struct {
	// Enable inline YAMLs
	Inline *bool `json:"inline,omitempty"`
	// Enable YAMLs from repository
	Git *bool `json:"git,omitempty"`
	// Enable YAMLs from URL
	URL *bool `json:"url,omitempty"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Executions
	Executions *int `json:"executions,omitempty"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace string `json:"pipelineNamespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame,omitempty"`
	// Success Rate stats
	SuccessRateStats *MetricWithTrend `json:"successRateStats,omitempty"`
	// Average duration stats
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats,omitempty"`
	// Execution stats
	ExecutionsStats *MetricWithTrend `json:"executionsStats,omitempty"`
}

// Pipeline Reference
type PipelineRef struct {
	// Id
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Project
	Project string `json:"project"`
	// ProjectId
	ProjectID string `json:"projectId"`
}

// Pipeline reference metadata
type PipelineReferenceMetadata struct {
	// Name of the entity
	Name string `json:"name"`
	// Namespace of the entity
	Namespace *string `json:"namespace,omitempty"`
	// Runtime of the entity
	Runtime *string `json:"runtime,omitempty"`
	// Group of the entity
	Group *string `json:"group,omitempty"`
	// Kind of the entity
	Kind *string `json:"kind,omitempty"`
	// Version of the entity
	Version *string `json:"version,omitempty"`
}

// Pipeline reference with git manifest
type PipelineReferenceWithGitManifest struct {
	// Pipeline reference metadata
	Metadata *PipelineReferenceMetadata `json:"metadata"`
	// Pipeline reference git manifest file path
	Path string `json:"path"`
	// Pipeline reference git manifest
	GitManifest string `json:"gitManifest"`
}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats,omitempty"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats,omitempty"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats,omitempty"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats,omitempty"`
}

// Pipeline Step
type PipelineStepStatistics struct {
	// Step Name
	StepName *string `json:"stepName,omitempty"`
	// Template Name
	TemplateName *string `json:"templateName,omitempty"`
	// Workflow Template
	WorkflowTemplate *string `json:"workflowTemplate,omitempty"`
	// Node Type
	NodeType *string `json:"nodeType,omitempty"`
	// Step Average duration
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats,omitempty"`
	// Step Executions count
	ExecutionsStats *MetricWithTrend `json:"executionsStats,omitempty"`
	// Step Average CPU usage
	CPUStats *MetricWithTrend `json:"cpuStats,omitempty"`
	// Step Average Memory
	MemoryStats *MetricWithTrend `json:"memoryStats,omitempty"`
	// Step Errors count
	ErrorsCountStats *MetricWithTrend `json:"errorsCountStats,omitempty"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Success rate
	SuccessRate *int `json:"successRate,omitempty"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project,omitempty"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace,omitempty"`
	// Filter pipelines from a specific cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name,omitempty"`
	// Filter pipelines from a specific groups
	Groups []*string `json:"groups,omitempty"`
	// Filter pipelines from a specific versions
	Versions []*string `json:"versions,omitempty"`
	// Filter pipelines by workflowTemplate
	WorkflowTemplate *string `json:"workflowTemplate,omitempty"`
}

// Plan
type Plan struct {
	// Stripe
	Stripe *Stripe `json:"stripe,omitempty"`
	// Trial
	Trial *Trial `json:"trial,omitempty"`
	// BasePrice
	BasePrice *BasePrice `json:"basePrice,omitempty"`
	// Workflows
	Workflows *PlanWorkflows `json:"workflows,omitempty"`
	// Environments
	Environments *PlanEnvironment `json:"environments,omitempty"`
	// DataRetention
	DataRetention *DataRetention `json:"dataRetention,omitempty"`
	// Collaborators
	Collaborators *PlanCollaborators `json:"collaborators,omitempty"`
	// PastDue
	PastDue *PastDue `json:"pastDue,omitempty"`
	// NewPricingModel
	NewPricingModel *bool `json:"newPricingModel,omitempty"`
	// Azure
	Azure *bool `json:"azure,omitempty"`
	// Currency
	Currency *string `json:"currency,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Dedicated
	Dedicated *bool `json:"dedicated,omitempty"`
	// PrivateRepo
	PrivateRepo *bool `json:"privateRepo,omitempty"`
	// PaymentInterval
	PaymentInterval PaymentInterval `json:"paymentInterval"`
	// IsWiredTransfer
	IsWiredTransfer *bool `json:"isWiredTransfer,omitempty"`
	// Packs
	Packs []*Pack `json:"packs,omitempty"`
	// TotalPrice
	TotalPrice *int `json:"totalPrice,omitempty"`
	// DisplayName
	DisplayName *string `json:"displayName,omitempty"`
	// Id
	ID *string `json:"id,omitempty"`
	// DefaultPack
	DefaultPack *string `json:"defaultPack,omitempty"`
	// Segment
	Segment *string `json:"segment,omitempty"`
	// MRR
	Mrr *int `json:"mrr,omitempty"`
	// ARR
	Arr *int `json:"arr,omitempty"`
	// GitOpsLimits
	GitOpsLimits *GitOpsLimits `json:"gitOpsLimits,omitempty"`
	// PlanType
	PlanType *PlanTypes `json:"planType,omitempty"`
}

// PlanCollaborators
type PlanCollaborators struct {
	// Limit
	Limit *int `json:"limit,omitempty"`
}

// PlanEnvironment
type PlanEnvironment struct {
	// Concurrency
	Concurrency *EnvironmentConcurrency `json:"concurrency,omitempty"`
}

// PlanWorkflows
type PlanWorkflows struct {
	// Concurrency
	Concurrency *WorkflowConcurrency `json:"concurrency,omitempty"`
}

// Pod Spec
type PodSpec struct {
	// Containers
	Containers []*DeploymentContainer `json:"containers,omitempty"`
}

// PodTemplate Spec
type PodTemplateSpec struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	// Spec
	Spec *PodSpec `json:"spec,omitempty"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilter struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilterArgs struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
}

// Product Entity
type Product struct {
	// Entity db id
	ID string `json:"id"`
	// Deprecated: Use metadata.name instead
	Name string `json:"name"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Is group marked as favorite (user scope)
	Favorite *bool `json:"favorite,omitempty"`
	// Annotaion pairs array strings(key=value)
	AnnotationPairs []*string `json:"annotationPairs"`
	// List of environments that has at least 1 product component associated with this product
	Environments []*Environment `json:"environments"`
	// Tags list
	Tags []*string `json:"tags"`
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Promotion flows and their selectors
	PromotionFlows []*ProductPromotionFlowSelectors `json:"promotionFlows,omitempty"`
	// Product concurrency
	Concurrency *ProductConcurrency `json:"concurrency,omitempty"`
	// Latest product release
	LatestRelease *ProductReleaseEntity `json:"latestRelease,omitempty"`
	// Latest product promotion
	LatestPromotion *PromotionEntity `json:"latestPromotion,omitempty"`
}

func (Product) IsFavorableNotK8sEntity() {}

func (Product) IsGitopsEntity() {}

func (Product) IsBaseEntity() {}

func (Product) IsProjectBasedEntity() {}

func (Product) IsFavorable() {}

func (Product) IsEntity() {}

// Product App application
type ProductApplication struct {
	// Entity id object
	Self *ProductApplicationEntityID `json:"self"`
	// Resolved application based on self object
	AppEntity *Application `json:"appEntity,omitempty"`
	// Runtime name
	Runtime string `json:"runtime"`
	// Deployed to object
	DeployedTo *ProductApplicationDeployedTo `json:"deployedTo"`
	// Product App Application Status object
	Status *ProductApplicationStatus `json:"status"`
	// Annotaion pairs array strings(key=value)
	AnnotationPairs []*string `json:"annotationPairs"`
	// Label pairs array strings(key=value)
	LabelPairs []string `json:"labelPairs"`
	// Latest application release
	Release *ProductApplicationRelease `json:"release,omitempty"`
}

// Product Application deployed to
type ProductApplicationDeployedTo struct {
	// Destination cluster name
	Name *string `json:"name,omitempty"`
	// Destination server url
	Server *string `json:"server,omitempty"`
	// Destination namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Product application entity id
type ProductApplicationEntityID struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Cluster
	Cluster string `json:"cluster"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Product Application Release
type ProductApplicationRelease struct {
	// History id
	HistoryID int `json:"historyId"`
	// Related argocd history id
	ArgoHistoryID *int `json:"argoHistoryId,omitempty"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState,omitempty"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
	// Version of application and dependencies
	AppVersions *ProductComponentVersions `json:"appVersions,omitempty"`
}

// Product App application
type ProductApplicationStatic struct {
	// Entity id object
	Self *ProductApplicationEntityID `json:"self"`
	// Runtime name
	Runtime string `json:"runtime"`
	// Deployed to object
	DeployedTo *ProductApplicationDeployedTo `json:"deployedTo"`
	// Product App Application Status object
	Status *ProductApplicationStatus `json:"status"`
	// Annotaion pairs array strings(key=value)
	AnnotationPairs []*string `json:"annotationPairs"`
	// Label pairs array strings(key=value)
	LabelPairs []string `json:"labelPairs"`
	// Latest application release
	Release *ProductApplicationRelease `json:"release,omitempty"`
}

// Product App deployed to
type ProductApplicationStatus struct {
	// Application sync status
	Sync *SyncStatus `json:"sync,omitempty"`
	// Application health status
	Health *HealthStatus `json:"health,omitempty"`
}

// Product Component Entity
type ProductComponent struct {
	// Entity db id
	ID string `json:"id"`
	// Component name
	Name string `json:"name"`
	// Product app type
	Type ProductComponentType `json:"type"`
	// Pending Pull Requests
	PendingPullRequests []*PullRequest `json:"pendingPullRequests,omitempty"`
	// Application
	Application *ProductApplication `json:"application,omitempty"`
	// Promotion workflow
	PromotedBy *ProductComponentPromotedByWorkflow `json:"promotedBy,omitempty"`
	// ID of product to which component is manually attached
	ManuallyAttachedToProductID *string `json:"manuallyAttachedToProductId,omitempty"`
	// Resolved when product app attached to specific product or null if unassigned. Normally should be 1 or 0. If more this means that collision in relation present and component belongs to different products
	Products []*Product `json:"products,omitempty"`
	// Resolved when product app attached to specific environment or null if unassigned
	Environments []*Environment `json:"environments,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Is group marked as favorite (user scope)
	Favorite *bool `json:"favorite,omitempty"`
}

func (ProductComponent) IsFavorableNotK8s() {}

func (ProductComponent) IsEntity() {}

// Product component Edge
type ProductComponentEdge struct {
	// Node contains the actual Product data
	Node *ProductComponent `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProductComponentEdge) IsEdge() {}

// Args to filter Product Components
type ProductComponentFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Application version
	AppVersion *string `json:"appVersion,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Issue key array
	IssueKeys []string `json:"issueKeys,omitempty"`
	// PR key array
	PrKeys []string `json:"prKeys,omitempty"`
	// Committers array
	Committers []string `json:"committers,omitempty"`
	// Images array
	Images []string `json:"images,omitempty"`
	// Product names array
	Products []string `json:"products,omitempty"`
	// If 'true' returns unassigned components, 'false' ignored
	NotInProduct *bool `json:"notInProduct,omitempty"`
	// Environments names array
	Environments []string `json:"environments,omitempty"`
	// If 'true' returns components that belong to any environment, 'false' ignored
	InEnvironment *bool `json:"inEnvironment,omitempty"`
	// By application health status
	HealthStatuses []HealthStatus `json:"healthStatuses,omitempty"`
	// If 'true' returns components that have at least 1 pending PR
	HasPendingPullRequests *bool `json:"hasPendingPullRequests,omitempty"`
	// Assignment type
	ProductAssignment *AssignmentType `json:"productAssignment,omitempty"`
}

// Info about the workflow that promoted component
type ProductComponentPromotedByWorkflow struct {
	// Workflow name
	WorkflowName string `json:"workflowName"`
	// Workflow status
	Status WorkflowPhases `json:"status"`
	// Git commit SHA that triggered the workflow
	Revision string `json:"revision"`
	// Workflow start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Workflow finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
}

// Product Component sorting arguments
type ProductComponentSortArg struct {
	// Field for sorting
	Field ProductComponentSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Product Component Static
type ProductComponentStatic struct {
	// Entity db id
	ID string `json:"id"`
	// Component name
	Name string `json:"name"`
	// Product app type
	Type ProductComponentType `json:"type"`
	// Application
	Application *ProductApplicationStatic `json:"application,omitempty"`
}

// Args to filter Product Components Static
type ProductComponentStaticFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Application version
	AppVersion *string `json:"appVersion,omitempty"`
	// Issue key array
	IssueKeys []string `json:"issueKeys,omitempty"`
	// PR key array
	PrKeys []string `json:"prKeys,omitempty"`
	// Committers array
	Committers []string `json:"committers,omitempty"`
	// Images array
	Images []string `json:"images,omitempty"`
	// Product names array
	Products []string `json:"products,omitempty"`
	// If 'true' returns unassigned components, 'false' ignored
	NotInProduct *bool `json:"notInProduct,omitempty"`
	// Environments names array
	Environments []string `json:"environments,omitempty"`
	// If 'true' returns components that belong to any environment, 'false' ignored
	InEnvironment *bool `json:"inEnvironment,omitempty"`
}

// Version of product and dependencies
type ProductComponentVersions struct {
	// AppVersion
	AppVersion *string `json:"appVersion,omitempty"`
	// VersionSources as yaml resources
	VersionSources []*ComponentDependenciesContent `json:"versionSources,omitempty"`
	// Versions
	VersionSummary []*SingleComponentDependency `json:"versionSummary,omitempty"`
}

// Product Components Counts
type ProductComponentsCounts struct {
	// Assigned Product Components Health Status Statistic
	Assigned []*ProductComponentsHealthStatusStatisticRecord `json:"assigned,omitempty"`
	// Unassigned Product Components Health Status Statistic
	Unassigned []*ProductComponentsHealthStatusStatisticRecord `json:"unassigned,omitempty"`
}

// Product Components Health Status Statistic
type ProductComponentsHealthStatusStatisticRecord struct {
	// Health Status
	Type HealthStatus `json:"type"`
	// Count
	Count int `json:"count"`
}

// Product components Slice
type ProductComponentsSlice struct {
	// Product app edges
	Edges []*ProductComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProductComponentsSlice) IsSlice() {}

// Product Edge
type ProductEdge struct {
	// Node contains the actual Product data
	Node *Product `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProductEdge) IsEdge() {}

// Product Environment Statistic item
type ProductEnvironmentStatistic struct {
	// Entity db id
	EnvID string `json:"envId"`
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// Kind of environment
	ComponentsAmount int `json:"componentsAmount"`
	// Position of environment
	Position int `json:"position"`
}

// Args to filter Product
type ProductFilterArgs struct {
	// Product name
	Name *string `json:"name,omitempty"`
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Environments names
	Environments []*string `json:"environments,omitempty"`
	// Promotion flow names
	PromotionFlowNames []*string `json:"promotionFlowNames,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
}

// Product Git Trigger Selector
type ProductGitTriggerSelector struct {
	// Key
	Key ProductGitTrigger `json:"key"`
	// Operator
	Operator MatchExpressionOperator `json:"operator"`
	// Values
	Values []string `json:"values"`
}

// Products group for environments page in grouped mode
type ProductGroupForEnvs struct {
	// Product id
	ID string `json:"id"`
	// Product name
	Name string `json:"name"`
	// Application Version
	AppVersion string `json:"appVersion"`
	// Applications in Group
	AppsCounter int `json:"appsCounter"`
	// Has Errors
	HasErrors bool `json:"hasErrors"`
	// Product Components
	ProductComponents []*ProductComponent `json:"productComponents"`
}

// Args to filter Product names
type ProductNamesFilterArgs struct {
	// Product name
	Name *string `json:"name,omitempty"`
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Promotion flow names
	PromotionFlowNames []*string `json:"promotionFlowNames,omitempty"`
}

// Product Promotion Flow Selectors
type ProductPromotionFlowSelectors struct {
	// Entity db id
	Name string `json:"name"`
	// Group name
	GitTriggerSelectors []*ProductGitTriggerSelector `json:"gitTriggerSelectors"`
	// Indicates whether the specified promotion flow still exists
	Exists bool `json:"exists"`
}

// Product Release
type ProductRelease struct {
	// Release id
	ReleaseID string `json:"releaseId"`
	// WIP - Release name - will be promotion flow name or generated?
	ReleaseName string `json:"releaseName"`
	// Promotion flow name
	PromotionFlowName *string `json:"promotionFlowName,omitempty"`
	// Environment that triggered the product release
	TriggerEnvironment *string `json:"triggerEnvironment,omitempty"`
	// Product release steps
	Steps []*ProductReleaseStep `json:"steps"`
	// Product release environments
	EnvironmentsStatuses []*ProductReleaseEnvironment `json:"environmentsStatuses"`
	// First commit that triggered the product release
	TriggerCommit *CommitInfo `json:"triggerCommit"`
	// Product release status
	Status ProductReleasePublicStatus `json:"status"`
	// Last update date of the product release
	UpdatedAt string `json:"updatedAt"`
	// Creation date of the product release
	CreatedAt string `json:"createdAt"`
	// Product Release error
	Error *ProductReleaseError `json:"error,omitempty"`
	// Product release details
	Details *ProductReleaseDetails `json:"details"`
	// Product name
	ProductName string `json:"productName"`
	// Runtime Older Version
	RuntimeMinVersion *ProductReleaseRuntimeVersionInfo `json:"runtimeMinVersion,omitempty"`
	// Initiator
	Initiator *ProductReleaseInitiator `json:"initiator,omitempty"`
	// The Release version
	Version *string `json:"version,omitempty"`
	// Product Release Hooks
	Hooks *ProductReleaseHooks `json:"hooks,omitempty"`
}

func (ProductRelease) IsPromotionOrReleaseNode() {}

// Product Release App Step Status Entry
type ProductReleaseAppStepStatusEntry struct {
	// Application step status
	Status ExtendedWorkflowPhases `json:"status"`
	// Date of the status
	Date string `json:"date"`
	// Application step issues
	Issues []*AppInfoIssue `json:"issues,omitempty"`
}

// Product Release commit status
type ProductReleaseCommitStatus struct {
	// Commit sha
	Sha string `json:"sha"`
	// Repository URL
	RepoURL string `json:"repoURL"`
	// Commit status
	Status CommitStatus `json:"status"`
	// Description
	Description string `json:"description"`
	// Context
	Context string `json:"context"`
	// Target URL
	TargetURL string `json:"targetUrl"`
}

// Product Release Details
type ProductReleaseDetails struct {
	// Issues
	Issues []*Annotation `json:"issues"`
	// PullRequest
	Prs []*Annotation `json:"prs"`
	// Images
	Images []*Images `json:"images"`
	// Build
	Builds []*Build `json:"builds"`
}

// Product Release Edge
type ProductReleaseEdge struct {
	// Node contains the actual product Release data
	Node *ProductRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Product Release Entity
type ProductReleaseEntity struct {
	// Release id
	ReleaseID string `json:"releaseId"`
	// Promotion flow name
	PromotionFlowName *string `json:"promotionFlowName,omitempty"`
	// Environment that triggered the product release
	TriggerEnvironment *string `json:"triggerEnvironment,omitempty"`
	// Product release status
	Status ProductReleasePublicStatus `json:"status"`
	// Last update date of the product release
	UpdatedAt string `json:"updatedAt"`
	// Creation date of the product release
	CreatedAt string `json:"createdAt"`
	// Product name
	ProductName string `json:"productName"`
	// Initiator
	Initiator *ProductReleaseInitiator `json:"initiator,omitempty"`
	// The Release version
	Version *string `json:"version,omitempty"`
}

// Product Release Environment
type ProductReleaseEnvironment struct {
	// Environment name
	EnvironmentName string `json:"environmentName"`
	// Environment status
	Status ProductReleaseStepStatus `json:"status"`
}

// Product release error
type ProductReleaseError struct {
	// Product release error code
	Code ProductReleaseErrorCode `json:"code"`
	// Product release error message
	Message string `json:"message"`
}

// Product release filters args
type ProductReleaseFiltersArgs struct {
	// Product name
	ProductNames []string `json:"productNames,omitempty"`
	// Promotion Flow ids
	PromotionFlows []string `json:"promotionFlows,omitempty"`
	// Product release status
	Statuses []ProductReleaseStatus `json:"statuses,omitempty"`
	// Start date
	StartDate *string `json:"startDate,omitempty"`
	// End date
	EndDate *string `json:"endDate,omitempty"`
}

// Product Release Hooks
type ProductReleaseHooks struct {
	// Workflow run when release begins execution
	OnStart *ReleaseHookWorkflowInfo `json:"onStart,omitempty"`
	// Workflow run when release fails to complete execution
	OnFail *ReleaseHookWorkflowInfo `json:"onFail,omitempty"`
	// Workflow run when release completes execution
	OnSuccess *ReleaseHookWorkflowInfo `json:"onSuccess,omitempty"`
}

// Product Release Initiator
type ProductReleaseInitiator struct {
	// Initiator name
	Name string `json:"name"`
	// Initiator avatar url
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// Product Release runtime version info - used for the oldest runtime version related to the product release apps
type ProductReleaseRuntimeVersionInfo struct {
	// Name
	Name string `json:"name"`
	// Version
	Version string `json:"version"`
}

// Product Release Slice
type ProductReleaseSlice struct {
	// Product Release edges
	Edges []*ProductReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Product release step
type ProductReleaseStep struct {
	// Environment name supplied by promotion flow, immutable
	EnvironmentName string `json:"environmentName"`
	// Environment Kind
	EnvironmentKind EnvironmentKind `json:"environmentKind"`
	// Environments names depends on the current environment supplied by promotion flow, immutable
	DependsOn []string `json:"dependsOn"`
	// Product release environment step pre workflows steps view
	PreWorkflowsStepsView []*WorkflowsStepView `json:"preWorkflowsStepsView"`
	// Product release environment step post workflows steps view
	PostWorkflowsStepsView []*WorkflowsStepView `json:"postWorkflowsStepsView"`
	// Promotion commits created by this promotion step
	Applications []*ApplicationInfo `json:"applications"`
	// Product release step status
	Status ProductReleaseStepStatus `json:"status"`
	// Product release step live status
	LiveStatus string `json:"liveStatus"`
	// Last update at date
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Started at date
	StartedAt *string `json:"startedAt,omitempty"`
	// Issues
	Issues []Issue `json:"issues"`
	// Active release, latest release of that environment
	Active *bool `json:"active,omitempty"`
	// Product Release Step pending pr
	Pr *Annotation `json:"pr,omitempty"`
	// Promotion policy action
	PolicyAction *string `json:"policyAction,omitempty"`
}

// Product Release step action
type ProductReleaseStepAction struct {
	// Post action workflowTemplate name
	PostAction *string `json:"postAction,omitempty"`
	// Labels to be set on the workflow
	Labels model.StringMap `json:"labels"`
}

// product release task
type ProductReleaseTask struct {
	// Product release task type
	Type ProductReleaseTaskType `json:"type"`
	// Labels (will end up as pre/post workflow labels)
	Labels model.StringMap `json:"labels"`
	// App namespace
	AppNamespace *string `json:"appNamespace,omitempty"`
	// App name
	AppName *string `json:"appName,omitempty"`
	// Repo URL
	RepoURL *string `json:"repoUrl,omitempty"`
	// Branch
	Branch *string `json:"branch,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Post action only - indicate if to run only post action
	PostActionOnly *bool `json:"postActionOnly,omitempty"`
	// CommitInfo, in case its postActionOnly (drag-n-drop or manual trigger) (optional)
	CommitInfo *CommitInfo `json:"commitInfo,omitempty"`
	// Pre Action (optional)
	PreAction *string `json:"preAction,omitempty"`
	// Action URL (optional)
	ActionURL *string `json:"actionUrl,omitempty"`
	// Action Body (optional)
	ActionBody *string `json:"actionBody,omitempty"`
	// Post Action (optional)
	PostAction *string `json:"postAction,omitempty"`
	// Initiator (optional)
	Initiator *string `json:"initiator,omitempty"`
	// Initiator Avatar URL (optional)
	InitiatorAvatarURL *string `json:"initiatorAvatarUrl,omitempty"`
	// Workflow Namespace
	WorkflowNamespace *string `json:"workflowNamespace,omitempty"`
	// Workflow wrapper name of the application in case the workflow was already run and restarted
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow template name of the hook
	WorkflowTemplateName *string `json:"workflowTemplateName,omitempty"`
	// Termination strategy
	TerminateStrategy *TerminationStrategy `json:"terminateStrategy,omitempty"`
	// Hook task Parameters
	Parameters model.StringMap `json:"parameters,omitempty"`
}

// Product Slice
type ProductSlice struct {
	// Product edges
	Edges []*ProductEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProductSlice) IsSlice() {}

// Product sorting arguments
type ProductSortArg struct {
	// Field for sorting
	Field ProductSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Product Statistic item
type ProductStatistic struct {
	// Entity db id
	ID string `json:"id"`
	// Group name
	Name string `json:"name"`
	// Entironments
	Environments []*ProductEnvironmentStatistic `json:"environments"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description,omitempty"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// Promotion entity
type Promotion struct {
	// Promotion ID
	ID string `json:"id"`
	// Account ID
	AccountID string `json:"accountId"`
	// Product name
	ProductName string `json:"productName"`
	// Promotion flow name
	PromotionFlowName *string `json:"promotionFlowName,omitempty"`
	// Trigger environment
	TriggerEnvironment string `json:"triggerEnvironment"`
	// Environments array
	Environments []*PromotionEnvironment `json:"environments"`
	// Trigger commit information
	TriggerCommitInfo *PromotionCommitInfo `json:"triggerCommitInfo"`
	// Promotion status
	Status ProductReleasePublicStatus `json:"status"`
	// Created at timestamp
	CreatedAt string `json:"createdAt"`
	// Updated at timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Promotion app version
	PromotionAppVersion *string `json:"promotionAppVersion,omitempty"`
	// Promotion error
	Failure *PromotionError `json:"failure,omitempty"`
}

func (Promotion) IsPromotionOrReleaseNode() {}

// Promotion Code
type PromotionCode struct {
	// Id
	ID string `json:"id"`
	// Object
	Object string `json:"object"`
	// Active
	Active bool `json:"active"`
	// Code
	Code string `json:"code"`
	// Coupon
	Coupon *Coupon `json:"coupon"`
	// Created
	Created int `json:"created"`
	// Customer
	Customer *string `json:"customer,omitempty"`
	// Expires_at
	ExpiresAt *int `json:"expiresAt,omitempty"`
	// Live Mode
	Livemode *bool `json:"livemode,omitempty"`
	// Max Redemptions
	MaxRedemptions *int `json:"maxRedemptions,omitempty"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
	// Restrictions
	Restrictions *Restrictions `json:"restrictions"`
	// Times Redeemed
	TimesRedeemed int `json:"timesRedeemed"`
}

// Commit information
type PromotionCommitInfo struct {
	// Commit SHA
	CommitSha string `json:"commitSha"`
	// Commit message
	CommitMessage string `json:"commitMessage"`
	// Commit author
	CommitAuthor string `json:"commitAuthor"`
	// Commit date
	CommitDate *string `json:"commitDate,omitempty"`
	// Commit repository url
	RepoURL *string `json:"repoURL,omitempty"`
	// Commit revision (branch)
	Revision *string `json:"revision,omitempty"`
	// Committer avatar url
	AvatarURL *string `json:"avatarURL,omitempty"`
}

// Promotion Entity
type PromotionEntity struct {
	// Promotion id
	PromotionID string `json:"promotionId"`
	// Promotion status
	Status ProductReleasePublicStatus `json:"status"`
	// Promotion app version
	PromotionAppVersion *string `json:"promotionAppVersion,omitempty"`
	// Trigger commit information
	TriggerCommitInfo *PromotionCommitInfo `json:"triggerCommitInfo"`
	// Updated at timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Created at timestamp
	CreatedAt string `json:"createdAt"`
}

// Environment information
type PromotionEnvironment struct {
	// Environment name
	Name string `json:"name"`
	// Dependencies array
	DependsOn []string `json:"dependsOn"`
	// Environment status
	Status EnvironmentStatus `json:"status"`
	// Started at timestamp
	StartedAt *string `json:"startedAt,omitempty"`
	// Updated at timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Environment workflows steps view
type PromotionEnvironmentStatus struct {
	// Environment name
	Environment string `json:"environment"`
	// Promotion environment step pre workflows steps view
	PreWorkflowsStepsView []*WorkflowsStepView `json:"preWorkflowsStepsView"`
	// Promotion environment step post workflows steps view
	PostWorkflowsStepsView []*WorkflowsStepView `json:"postWorkflowsStepsView"`
	// Applications promoted during the release
	VerifyAppStatus []*PromotionTaskVerifyAppStatus `json:"verifyAppStatus"`
	// Promotion pull request status
	PullRequestStatus []*PromotionTaskPullRequestStatus `json:"pullRequestStatus"`
	// Promotion commit status
	CommitStatus []*PromotionTaskCommitStatus `json:"commitStatus"`
	// Promotion issues
	Issues []Issue `json:"issues"`
	// Promotion applications status
	Applications []*PromotionTaskApplicationStatus `json:"applications"`
}

type PromotionError struct {
	// Promotion error message
	Message string `json:"message"`
	// Promotion error code
	Code PromotionErrorCode `json:"code"`
	// Promotion error timestamp
	Timestamp string `json:"timestamp"`
}

// PromotionFlow entity
type PromotionFlow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations,omitempty"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission,omitempty"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Db entity id
	ID *string `json:"id,omitempty"`
	// Updated At
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Trigger Environment
	TriggerEnvironment string `json:"triggerEnvironment"`
	// Post Trigger
	PostTrigger *string `json:"postTrigger,omitempty"`
	// Promotion flow steps
	Steps []*FlowStep `json:"steps"`
}

func (PromotionFlow) IsGitopsEntity() {}

func (PromotionFlow) IsBaseEntity() {}

func (PromotionFlow) IsProjectBasedEntity() {}

// Promotion flow Edge
type PromotionFlowEdge struct {
	// Node contains the actual promotion flow data
	Node *PromotionFlow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Promotion flow hooks
type PromotionFlowHooks struct {
	// Hook ran on failure
	OnFail *string `json:"onFail,omitempty"`
	// Hook ran on start
	OnStart *string `json:"onStart,omitempty"`
	// Hook ran on success
	OnSuccess *string `json:"onSuccess,omitempty"`
}

// Promotion flow Slice
type PromotionFlowSlice struct {
	// Promotion flow edges
	Edges []*PromotionFlowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// promotion hooks definition
type PromotionHooksDefinitionInput struct {
	// On start workflow template name
	OnStart *string `json:"onStart,omitempty"`
	// On success workflow template name
	OnSuccess *string `json:"onSuccess,omitempty"`
	// On fail workflow template name
	OnFail *string `json:"onFail,omitempty"`
}

type PromotionOrReleaseEdge struct {
	// Node contains the actual promotion or release data
	Node PromotionOrReleaseNode `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Promotion Slice
type PromotionOrReleaseSlice struct {
	// Promotion edges
	Edges []*PromotionOrReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// PromotionPolicy entity
type PromotionPolicy struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest bool `json:"latest"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Product and Environment selector
	Selector *PromotionPolicySelector `json:"selector,omitempty"`
	// Policy
	Policy *PromotionPolicyDefinition `json:"policy"`
	// Number that represents the priority of the promotion policy when multiple policies can be applied. The higher the number, the higher the priority. The default value is 0.
	Priority float64 `json:"priority"`
}

func (PromotionPolicy) IsGitopsEntity() {}

func (PromotionPolicy) IsBaseEntity() {}

func (PromotionPolicy) IsEntity() {}

// Promotion policy definition
type PromotionPolicyDefinition struct {
	// Pre action workflowTemplate name
	PreAction *string `json:"preAction,omitempty"`
	// Post action workflowTemplate name
	PostAction *string `json:"postAction,omitempty"`
	// Action Type
	Action *PromotionPolicyAction `json:"action,omitempty"`
}

// Promotion policy definition
type PromotionPolicyDefinitionInput struct {
	// Pre action workflowTemplate name
	PreAction *string `json:"preAction,omitempty"`
	// Post action workflowTemplate name
	PostAction *string `json:"postAction,omitempty"`
	// Action Type
	Action PromotionPolicyAction `json:"action"`
}

// PromotionPolicy Edge
type PromotionPolicyEdge struct {
	// Node
	Node *PromotionPolicy `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PromotionPolicyEdge) IsEdge() {}

// Args to resolve policy
type PromotionPolicyEnvProductPairArg struct {
	// Promoted product name
	ProductName string `json:"productName"`
	// Promotion target environment name
	TargetEnvironmentName string `json:"targetEnvironmentName"`
}

// Promotion policy environment selector
type PromotionPolicyEnvironmentSelector struct {
	// Environment names
	Names []string `json:"names,omitempty"`
	// Environment types
	Types []EnvironmentKind `json:"types,omitempty"`
	// Environment tags
	Tags []string `json:"tags,omitempty"`
}

// Args to filter Promotion Policy
type PromotionPolicyFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Pre-action (case insensitive)
	PreActionNames []string `json:"preActionNames,omitempty"`
	// Post-action (case insensitive)
	PostActionNames []string `json:"postActionNames,omitempty"`
	// Action
	Action *PromotionPolicyAction `json:"action,omitempty"`
}

// Promotion Policy filter values
type PromotionPolicyFilterValues struct {
	// Pre-action
	PreActions []string `json:"preActions"`
	// Post-action
	PostActions []string `json:"postActions"`
}

// Promotion policy product selector
type PromotionPolicyProductSelector struct {
	// Product names
	Names []string `json:"names,omitempty"`
	// Products tags
	Tags []string `json:"tags,omitempty"`
}

// Promotion policy selector
type PromotionPolicySelector struct {
	// Product selector
	Product *PromotionPolicyProductSelector `json:"product,omitempty"`
	// Environment selector
	TargetEnvironment *PromotionPolicyEnvironmentSelector `json:"targetEnvironment,omitempty"`
}

// PromotionPolicy Slice
type PromotionPolicySlice struct {
	// PromotionPolicy edges
	Edges []*PromotionPolicyEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PromotionPolicySlice) IsSlice() {}

// Promotion Policy sorting arguments
type PromotionPolicySortArg struct {
	// Field for sorting
	Field PromotionPolicySortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// PromotionSource entity
type PromotionSource struct {
	// File path
	Glob string `json:"glob"`
	// JSON paths to the values in the file
	JSONPaths []string `json:"jsonPaths"`
}

type PromotionTaskApplicationStatus struct {
	// Promotion task application id
	AppID *ApplicationID `json:"appId"`
	// Promotion task application health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Promotion task application sync status
	SyncStatus SyncStatus `json:"syncStatus"`
}

// Promote app with commit status
type PromotionTaskCommitStatus struct {
	// Promote app with commit phase
	Phase PromoteAppWithCommitPhase `json:"phase"`
	// Promote app with commit app id
	AppID *ApplicationID `json:"appId"`
	// Promote app with commit commit sha
	CommitSha *string `json:"commitSha,omitempty"`
	// Promote app with commit commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Promote app with commit commit description
	CommitDescription *string `json:"commitDescription,omitempty"`
}

// Promote app with pr status
type PromotionTaskPullRequestStatus struct {
	// Promote app with pr app id
	AppID *ApplicationID `json:"appId"`
	// Pull request repo name
	Repo string `json:"repo"`
	// Pull request id
	ID int `json:"id"`
	// Pull request url
	URL string `json:"url"`
	// Pull request title
	Title string `json:"title"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Pull request author
	Author string `json:"author"`
	// Pull request author avatar url
	AvatarURL string `json:"avatarUrl"`
	// Pull request base branch
	BaseBranch string `json:"baseBranch"`
	// Pull request head branch
	HeadBranch string `json:"headBranch"`
	// Pull request created at
	CreatedAt string `json:"createdAt"`
	// Pull request state
	State PullRequestState `json:"state"`
	// Pull request is merged
	IsMerged bool `json:"isMerged"`
	// Commit sha from the pull request merge
	MergeCommitSha *string `json:"mergeCommitSHA,omitempty"`
}

// Verify app status
type PromotionTaskVerifyAppStatus struct {
	// Verify app status phase
	Phase VerifyAppStatusPhase `json:"phase"`
	// Verify app status app id
	AppID *ApplicationID `json:"appId"`
	// Verify app status commit sha
	CommitSha *string `json:"commitSha,omitempty"`
}

// PromotionTemplate entity
type PromotionTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this entity
	References []BaseEntity `json:"references,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Version Source
	VersionSource *FileSource `json:"versionSource,omitempty"`
	// Promotion array of PromotionSource
	Promotion []*PromotionSource `json:"promotion,omitempty"`
}

func (PromotionTemplate) IsBaseEntity() {}

func (PromotionTemplate) IsPromotionTemplateFields() {}

func (PromotionTemplate) IsEntity() {}

// Application Set Edge
type PromotionTemplateEdge struct {
	// Node contains the actual application configuration data
	Node *PromotionTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PromotionTemplateEdge) IsEdge() {}

// PromotionTemplate Short entity
type PromotionTemplateShort struct {
	// Version Source
	VersionSource *FileSource `json:"versionSource,omitempty"`
	// Promotion array of PromotionSource
	Promotion []*PromotionSource `json:"promotion,omitempty"`
}

func (PromotionTemplateShort) IsPromotionTemplateFields() {}

// PromotionTemplate Slice
type PromotionTemplateSlice struct {
	// Application edges
	Edges []*PromotionTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PromotionTemplateSlice) IsSlice() {}

// Pull request
type PullRequest struct {
	// Pull request repo name
	Repo string `json:"repo"`
	// Pull request id
	ID int `json:"id"`
	// Pull request url
	URL string `json:"url"`
	// Pull request title
	Title string `json:"title"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Pull request author
	Author string `json:"author"`
	// Pull request author avatar url
	AvatarURL string `json:"avatarUrl"`
	// Pull request base branch (the branch you want to merge changes into)
	BaseBranch string `json:"baseBranch"`
	// Pull request head branch (the branch where your changes are implemented)
	HeadBranch string `json:"headBranch"`
	// Pull request created at
	CreatedAt time.Time `json:"createdAt"`
	// Pull request state
	State PullRequestState `json:"state"`
	// Pull request is merged
	IsMerged bool `json:"isMerged"`
	// Commit sha from the pull request merge
	MergeCommitSha *string `json:"mergeCommitSHA,omitempty"`
}

// Pull request args
type PullRequestArgs struct {
	// Pull request repo name
	Repo string `json:"repo"`
	// Pull request id
	ID int `json:"id"`
	// Pull request url
	URL string `json:"url"`
	// Pull request title
	Title string `json:"title"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Pull request author
	Author string `json:"author"`
	// Pull request author avatar url
	AvatarURL string `json:"avatarUrl"`
	// Pull request created at
	CreatedAt string `json:"createdAt"`
	// Pull request state
	State *PullRequestState `json:"state,omitempty"`
	// Pull request is merged
	IsMerged *bool `json:"isMerged,omitempty"`
}

// PullRequestCommitter
type PullRequestCommitter struct {
	// userName
	UserName string `json:"userName"`
	// avatar
	Avatar *string `json:"avatar,omitempty"`
}

// PullRequest value
type PullRequestValue struct {
	// url
	URL string `json:"url"`
	// title
	Title string `json:"title"`
	// committers
	Committers []*PullRequestCommitter `json:"committers"`
	// commits
	Commits []*Commits `json:"commits,omitempty"`
	// id
	ID *string `json:"id,omitempty"`
}

// Query root
type Query struct {
}

// Registry
type Registry struct {
	// Domain
	Domain string `json:"domain"`
	// Registry type
	Type ImageRegistryType `json:"type"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix,omitempty"`
	// Original Repository Prefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix,omitempty"`
}

// RegistryOutput
type RegistryOutput struct {
	// Id
	ID *string `json:"id,omitempty"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix,omitempty"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix,omitempty"`
}

// Release Entity - represents a Codefresh runtime release
type Release struct {
	// Runtime version (backward compatability, not used anywhere)
	Version string `json:"version"`
	// Runtime version
	RuntimeVersion string `json:"runtimeVersion"`
	// Chart version (only exists in helm runtime)
	ChartVersion *string `json:"chartVersion,omitempty"`
	// Has security vulnerabilities
	HasSecurityVulnerabilities *bool `json:"hasSecurityVulnerabilities,omitempty"`
	// Release channel (stable or latest)
	Channel *ReleaseChannel `json:"channel,omitempty"`
	// Whether an upgrade is available for this release
	UpgradeAvailable *bool `json:"upgradeAvailable,omitempty"`
}

// Product Release Step Workflow Info
type ReleaseHookWorkflowInfo struct {
	// Workflow template name
	TemplateName string `json:"templateName"`
	// Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Relevant workflow's node status
	Status WorkflowPhases `json:"status"`
	// Hook error
	Error *HookError `json:"error,omitempty"`
}

// Rollout Rollout State
type ReleaseRolloutState struct {
	// Name
	Name string `json:"name"`
	// UID
	UID *string `json:"uid,omitempty"`
	// Revision
	CurrentRevision int `json:"currentRevision"`
	// Disable rollout access on ui
	Disabled *ReleaseRolloutDisabledReasons `json:"disabled,omitempty"`
	// Status of the process
	Phase RolloutPhases `json:"phase"`
	// Health message
	Message *string `json:"message,omitempty"`
	// Name of current strategy
	CurrentStrategyName RolloutStrategyNames `json:"currentStrategyName"`
	// Number of steps
	Steps *int `json:"steps,omitempty"`
	// Current step index
	CurrentStepIndex *int `json:"currentStepIndex,omitempty"`
	// Current step spec
	CurrentStepSpec *string `json:"currentStepSpec,omitempty"`
	// Services
	Services []*string `json:"services"`
	// Status of PrePromotion analysis
	PrePromotionAnalysisRunStatus *RolloutAnalysisStatus `json:"prePromotionAnalysisRunStatus,omitempty"`
	// Status of postPromotion analysis
	PostPromotionAnalysisRunStatus *RolloutAnalysisStatus `json:"postPromotionAnalysisRunStatus,omitempty"`
	// Status of inline analyses
	StepsAnalysisRunStatuses []*RolloutAnalysisStatus `json:"stepsAnalysisRunStatuses,omitempty"`
	// Status of background status
	BackgroundAnalysisRunStatus *RolloutAnalysisStatus `json:"backgroundAnalysisRunStatus,omitempty"`
	// Revision info
	RevisionInfo *RevisionInfo `json:"revisionInfo"`
	// Is rollout complete
	IsComplete bool `json:"isComplete"`
	// Is rollout paused (taken from status.paused)
	Paused *bool `json:"paused,omitempty"`
	// Set to true only when analysis run status become inconclusive
	PausedInconclusive *bool `json:"pausedInconclusive,omitempty"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images,omitempty"`
	// SyncStatus
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
}

// Release step application status
type ReleaseStepApplicationStatus struct {
	// Application id
	ApplicationID *ApplicationID `json:"applicationId"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
}

// Product Release Step Workflow Info
type ReleaseStepWorkflowInfo struct {
	// Application Name
	ApplicationName string `json:"applicationName"`
	// Application workflow name
	WorkflowName string `json:"workflowName"`
	// Relevant workflow's node status
	Status WorkflowNodePhases `json:"status"`
}

// Releases grouped by channel
type ReleasesByChannel struct {
	// Stable channel releases
	Stable *ChannelReleases `json:"stable"`
	// Latest channel releases
	Latest *ChannelReleases `json:"latest"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken,omitempty"`
}

// ReplicaSet entity
type ReplicaSet struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Image
	Image string `json:"image"`
	// Replicas
	Replicas int `json:"replicas"`
	// Ready Replicas
	ReadyReplicas int `json:"readyReplicas"`
	// Current Replicas
	CurrentReplicas int `json:"currentReplicas"`
	// Available Replicas
	AvailableReplicas int `json:"availableReplicas"`
	// Updated Replicas
	UpdatedReplicas int `json:"updatedReplicas"`
	// Actual manifest
	ActualManifest string `json:"actualManifest"`
}

func (ReplicaSet) IsBaseEntity() {}

func (ReplicaSet) IsEntity() {}

// ReplicaSet Edge
type ReplicaSetEdge struct {
	// Node contains the actual ReplicaSet data
	Node *ReplicaSet `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ReplicaSetEdge) IsEdge() {}

// ReplicaSet Slice
type ReplicaSetSlice struct {
	// ReplicaSet edges
	Edges []*ReplicaSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ReplicaSetSlice) IsSlice() {}

// RepoBitbucketCloudFilterArgs
type RepoBitbucketCloudFilterArgs struct {
	// Repo owner
	Owner string `json:"owner"`
	// Repo projectKey
	ProjectKey string `json:"projectKey"`
	// Repo name
	RepositorySlug string `json:"repositorySlug"`
}

// RepoBitbucketCloudFilterArgs
type RepoBitbucketCloudFilterArgsInput struct {
	// Repo owner
	Owner string `json:"owner"`
	// Repo projectKey
	ProjectKey string `json:"projectKey"`
	// Repo name
	RepositorySlug string `json:"repositorySlug"`
}

// Repo Resource Source data input
type RepoResourceSourceInput struct {
	// Repository URL
	RepoURL string `json:"repoURL"`
	// Repository revision
	Revision string `json:"revision"`
	// Repository path
	Path string `json:"path"`
}

// Runtime Errors Report Arguments
type ReportRuntimeErrorsArgs struct {
	// Name of the Runtime
	Runtime string `json:"runtime"`
	// Errors
	Errors []*HealthErrorInput `json:"errors"`
}

// Result of the promotion policy resolution
type ResolvedPromotionPolicy struct {
	// Resolved preAction
	PreAction *ResolvedPromotionPolicyItem `json:"preAction,omitempty"`
	// Resolved postAction
	PostAction *ResolvedPromotionPolicyItem `json:"postAction,omitempty"`
	// Resolved action
	Action *ResolvedPromotionPolicyActionItem `json:"action,omitempty"`
}

// Value and origin of the resolved PP field
type ResolvedPromotionPolicyActionItem struct {
	// Value
	Value PromotionPolicyAction `json:"value"`
	// Origin of the value
	Origin *PromotionPolicy `json:"origin"`
}

// Value and origin of the resolved PP field
type ResolvedPromotionPolicyItem struct {
	// Value
	Value string `json:"value"`
	// Origin of the value
	Origin *PromotionPolicy `json:"origin"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Resource manifest
type ResourceManifest struct {
	// Full filename with path
	Filename *string `json:"filename,omitempty"`
	// Status: created, updated, deleted
	Status *string `json:"status,omitempty"`
	// K8s kind
	Kind string `json:"kind"`
	// File contents
	Content string `json:"content"`
	// Old file contents
	OldContent *string `json:"oldContent,omitempty"`
	// Git commit sha
	Revision *string `json:"revision,omitempty"`
	// Entities referenced by this resource
	ReferencedBy []*BaseReference `json:"referencedBy,omitempty"`
}

// Resource Metadata
type ResourceMetadata struct {
	// Cluster name
	Cluster string `json:"cluster"`
	// Resource name
	Name string `json:"name"`
	// Resource kind
	Kind string `json:"kind"`
	// Resource version
	Version string `json:"version"`
	// Resource namespace
	Namespace *string `json:"namespace,omitempty"`
	// Resource group
	Group *string `json:"group,omitempty"`
}

// ResourcesRequests
type ResourcesRequests struct {
	// CPU
	CPU *string `json:"cpu,omitempty"`
	// Memory
	Memory *string `json:"memory,omitempty"`
}

// RestrictedGitSource entity
type RestrictedGitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// The generated AppProject's sourceNamespace
	SourceNamespace string `json:"sourceNamespace"`
	// The generated AppProject's destinations array
	Destinations []*AppProjectDestination `json:"destinations"`
	// The generated AppProject's sourceRepos array
	SourceRepos []string `json:"sourceRepos,omitempty"`
}

func (RestrictedGitSource) IsBaseEntity() {}

func (RestrictedGitSource) IsEntity() {}

// Restricted Git Source details
type RestrictedGitSourceDetails struct {
	// The generated AppProject's sourceNamespace
	SourceNamespace string `json:"sourceNamespace"`
	// The generated AppProject's destinations array
	Destinations []*AppProjectDestination `json:"destinations"`
	// The generated AppProject's sourceRepos array
	SourceRepos []string `json:"sourceRepos,omitempty"`
}

// RestrictedGitSource Edge
type RestrictedGitSourceEdge struct {
	// Node contains the actual restricted gitsource data
	Node *RestrictedGitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RestrictedGitSourceEdge) IsEdge() {}

// RestrictedGitSource Slice
type RestrictedGitSourceSlice struct {
	// Restricted git source edges
	Edges []*RestrictedGitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RestrictedGitSourceSlice) IsSlice() {}

// Promotion Code Restrictions
type Restrictions struct {
	// First Time Transaction
	FirstTimeTransaction bool `json:"firstTimeTransaction"`
	// Minimum Amount
	MinimumAmount *int `json:"minimumAmount,omitempty"`
	// Minimum Amount Currency
	MinimumAmountCurrency *string `json:"minimumAmountCurrency,omitempty"`
}

// Revision Info Entity
type RevisionInfo struct {
	// Image Name
	Image string `json:"image"`
	// Image details
	ImageDetails *RolloutImageDetails `json:"imageDetails,omitempty"`
	// Current traffic weight directed to this revision
	Weight int `json:"weight"`
	// Current replicas
	Replicas *int `json:"replicas,omitempty"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas,omitempty"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas,omitempty"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
	// Current unavailable replicas
	UnavailableReplicas *int `json:"unavailableReplicas,omitempty"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas,omitempty"`
}

// Rollback Availability Info
type RollbackAvailabilityInfo struct {
	// Is rollback allowed for this rollout
	Allowed bool `json:"allowed"`
	// Is this rollout is latest one or not
	IsLatestRollout bool `json:"isLatestRollout"`
	// Is this rollout replicaset resource still exists in cluster as per history settings
	InRevisionsHistory bool `json:"inRevisionsHistory"`
	// Current revision history limit which is set in latest rollout of the application
	RevisionHistoryLimitSettings int `json:"revisionHistoryLimitSettings"`
	// Revision of latest rollout
	LatestRevision int `json:"latestRevision"`
}

// "Rollout Entity
type Rollout struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Spec
	Spec *RolloutSpec `json:"spec"`
	// Status
	Status *RolloutStatus `json:"status"`
	// Performed Actions (from codefresh)
	PerformedActions *RolloutPerformedActions `json:"performedActions,omitempty"`
	// Rollback info
	RollbackAvailability *RollbackAvailabilityInfo `json:"rollbackAvailability,omitempty"`
}

func (Rollout) IsProjectBasedEntity() {}

func (Rollout) IsGitopsEntity() {}

func (Rollout) IsBaseEntity() {}

func (Rollout) IsEntity() {}

// Rollout Analysis Run Status
type RolloutAnalysisRunStatus struct {
	// Number of erroneous measurments
	Name string `json:"name"`
	// Status
	Status AnalysisPhases `json:"status"`
	// Message
	Message *string `json:"message,omitempty"`
}

// Rollout Analysis Status
type RolloutAnalysisStatus struct {
	// Number of erroneous measurments
	Error int `json:"error"`
	// Number of failed measurments
	Failed int `json:"failed"`
	// Number of inconclusive measurments
	Inconclusive int `json:"inconclusive"`
	// Name of the analysis
	Name string `json:"name"`
	// The summary state of the analysis, taking into account defined limits
	Phase string `json:"phase"`
	// Number of successful measurments
	Successful int `json:"successful"`
}

// Rollout Set Canary Scale Step
type RolloutCanaryInlineAnalysisStep struct {
	// Replicas
	Templates []*RolloutInlineAnalysisTemplate `json:"templates"`
	// Name value args list
	Args []*NameValueOutput `json:"args,omitempty"`
}

// Rollout Canary Pause Step
type RolloutCanaryPauseStep struct {
	// Duration settings
	Duration *string `json:"duration,omitempty"`
}

// Rollout Canary Set Header Route Step
type RolloutCanarySetHeaderRouteStep struct {
	// Match
	Match []*RolloutCanarySetHeaderRouteStepMatch `json:"match,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
}

// Rollout Canary Set Header Route Step Match
type RolloutCanarySetHeaderRouteStepMatch struct {
	// Header Name
	HeaderName *string `json:"headerName,omitempty"`
	// Header Value
	HeaderValue *RolloutCanaryStepMatchExpressions `json:"headerValue"`
}

// Rollout Canary Set Mirror Route Step
type RolloutCanarySetMirrorRouteStep struct {
	// Match
	Match []*RolloutCanarySetMirrorRouteStepMatch `json:"match,omitempty"`
	// Name
	Name string `json:"name"`
	// Percentage
	Percentage *int `json:"percentage,omitempty"`
}

// Rollout Canary Set Mirror Route Step Match
type RolloutCanarySetMirrorRouteStepMatch struct {
	// Headers
	Headers *string `json:"headers,omitempty"`
	// Method
	Method *RolloutCanaryStepMatchExpressions `json:"method,omitempty"`
	// Path
	Path *RolloutCanaryStepMatchExpressions `json:"path,omitempty"`
}

// Rollout Set Canary Scale Step
type RolloutCanarySetScaleStep struct {
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
	// Weight
	Weight *int `json:"weight,omitempty"`
	// Match Traffic Weight
	MatchTrafficWeight *bool `json:"matchTrafficWeight,omitempty"`
}

// Rollout Canary Status
type RolloutCanaryStatus struct {
	// Status of current step analysis
	CurrentStepAnalysisRunStatus *RolloutAnalysisRunStatus `json:"currentStepAnalysisRunStatus,omitempty"`
	// Status of background status
	BackgroundAnalysisRunStatus *RolloutAnalysisRunStatus `json:"backgroundAnalysisRunStatus,omitempty"`
}

// Rollout Canary Step
type RolloutCanaryStep struct {
	// Set weight
	SetWeight *int `json:"setWeight,omitempty"`
	// Pause settings
	Pause *RolloutCanaryPauseStep `json:"pause,omitempty"`
	// Set canary scal
	SetCanaryScale *RolloutCanarySetScaleStep `json:"setCanaryScale,omitempty"`
	// Set Canary Scale Step
	SetHeaderRoute *RolloutCanarySetHeaderRouteStep `json:"setHeaderRoute,omitempty"`
	// Set Mirror Route Step
	SetMirrorRoute *RolloutCanarySetMirrorRouteStep `json:"setMirrorRoute,omitempty"`
	// Inline analysis
	Analysis *RolloutCanaryInlineAnalysisStep `json:"analysis,omitempty"`
	// Inline experiment
	Experiment *RolloutInlineExperimentTemplate `json:"experiment,omitempty"`
	// Related Analysis Runs array
	AnalysisRuns []*AnalysisRun `json:"analysisRuns,omitempty"`
}

// Rollout Canary Step Match Expressions
type RolloutCanaryStepMatchExpressions struct {
	// Exact
	Exact *string `json:"exact,omitempty"`
	// Prefix
	Prefix *string `json:"prefix,omitempty"`
	// Regex
	Regex *string `json:"regex,omitempty"`
}

// Rollout Edge
type RolloutEdge struct {
	// Node contains the actual rollout data
	Node *Rollout `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RolloutEdge) IsEdge() {}

// Rollout Image Details
type RolloutImageDetails struct {
	// Image name
	Image string `json:"image"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Image tag
	Tag *string `json:"tag,omitempty"`
	// Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CI provider
	CiProvider *string `json:"ciProvider,omitempty"`
}

// Rollout Set Canary Scale Step
type RolloutInlineAnalysisTemplate struct {
	// Template name
	TemplateName string `json:"templateName"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentAnalyses struct {
	// Name
	Name string `json:"name"`
	// Template name
	TemplateName string `json:"templateName"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentTemplate struct {
	// Duration
	Duration *string `json:"duration,omitempty"`
	// Templates
	Templates []*RolloutInlineExperimentTemplates `json:"templates"`
	// Analyses
	Analyses []*RolloutInlineExperimentAnalyses `json:"analyses,omitempty"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentTemplates struct {
	// Name
	Name string `json:"name"`
	// Spec ref
	SpecRef string `json:"specRef"`
}

// Rollout Performed Actions
type RolloutPerformedActions struct {
	// Skipped Steps
	SkippedSteps []*RolloutSkippedStep `json:"skippedSteps,omitempty"`
	// Promote full details
	PromoteFull *RolloutPromoteFullDetails `json:"promoteFull,omitempty"`
}

// Rollout Promote Full Details
type RolloutPromoteFullDetails struct {
	// Date when action was performed
	PerformedAt string `json:"performedAt"`
	// Canary step index (0+)
	FromStep *int `json:"fromStep,omitempty"`
}

// Rollout Rollback Revisions Comparence Response
type RolloutRollbackRevisionsComparenceResponse struct {
	// Rollout
	Rollout *Rollout `json:"rollout"`
	// Actual/current rollout manifest
	ActualManifest string `json:"actualManifest"`
	// State in case of rollback
	RollbackManifest *string `json:"rollbackManifest,omitempty"`
}

// Rollout Skipped Step
type RolloutSkippedStep struct {
	// Step index (0+)
	Index int `json:"index"`
	// Date when action was performed
	PerformedAt string `json:"performedAt"`
}

// Rollout Slice
type RolloutSlice struct {
	// Rollout edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RolloutSlice) IsSlice() {}

// Rollout Spec
type RolloutSpec struct {
	// Strategy
	Strategy *RolloutStrategy `json:"strategy"`
	// Desired replicas
	DesiredReplicas int `json:"desiredReplicas"`
	// Revision History Limit
	RevisionHistoryLimit int `json:"revisionHistoryLimit"`
}

// Rollout Status
type RolloutStatus struct {
	// Index of the current step that is being executed
	CurrentStepIndex *int `json:"currentStepIndex,omitempty"`
	// Status of the process
	Phase string `json:"phase"`
	// Health message
	Message *string `json:"message,omitempty"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas,omitempty"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas,omitempty"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas,omitempty"`
	// Current traffic weight of the new version
	WeightOfNew int `json:"weightOfNew"`
	// Is the rollout aborted
	Abort *bool `json:"abort,omitempty"`
	// Is the rollout paused
	Paused *bool `json:"paused,omitempty"`
	// Is the rollout fully promoted
	PromoteFull *bool `json:"promoteFull,omitempty"`
	// Canary status
	Canary *RolloutCanaryStatus `json:"canary,omitempty"`
}

// Rollout Step Details
type RolloutStepDetails struct {
	// Step status
	Status *RolloutStepStatus `json:"status,omitempty"`
}

// Rollout Strategy
type RolloutStrategy struct {
	// Name
	Name string `json:"name"`
	// Rollout new image
	NewImage string `json:"newImage"`
	// Rollout new image details
	NewImageRegistry *ImageRegistry `json:"newImageRegistry,omitempty"`
	// Steps
	Steps []*RolloutCanaryStep `json:"steps,omitempty"`
	// The name of the service pointing to the old version
	CurrentService *string `json:"currentService,omitempty"`
	// The name of the service pointing to the new version
	NewService *string `json:"newService,omitempty"`
	// Canary background analysis run details
	BackgroundAnalysisRun *AnalysisRun `json:"backgroundAnalysisRun,omitempty"`
	// Canary background analysis starting step
	BackgoundAnalysisSpec *string `json:"backgoundAnalysisSpec,omitempty"`
	// Blue-green pre promotion analysis run details
	PrePromotionAnalysisRun *AnalysisRun `json:"prePromotionAnalysisRun,omitempty"`
	// Blue-green post promotion analysis run details
	PostPromotionAnalysisRun *AnalysisRun `json:"postPromotionAnalysisRun,omitempty"`
}

// RolloutTransition Entity
type RolloutTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseRolloutState `json:"from,omitempty"`
	// To
	To *ReleaseRolloutState `json:"to,omitempty"`
	// Rollbacks
	Rollbacks []*RolloutTransition `json:"rollbacks"`
}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self,omitempty"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster,omitempty"`
	// Type of installation CLI|HELM|HOSTED
	InstallationType InstallationType `json:"installationType"`
	// Runtime is managed
	Managed bool `json:"managed"`
	// Ignore security and git token updates users
	IgnoreSecurityAndGitTokenUpdatesUsers []string `json:"ignoreSecurityAndGitTokenUpdatesUsers,omitempty"`
	// At least one remote cluster is connected (for managed runtimes)
	IsRemoteClusterConnected bool `json:"isRemoteClusterConnected"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost,omitempty"`
	// Internal Ingress host of the runtime - for app proxy usage only
	InternalIngressHost *string `json:"internalIngressHost,omitempty"`
	// Ingress class of the runtime
	IngressClass *string `json:"ingressClass,omitempty"`
	// Ingress controller of the runtime
	IngressController *string `json:"ingressController,omitempty"`
	// Gateway name
	GatewayName *string `json:"gatewayName,omitempty"`
	// Gateway namespace
	GatewayNamespace *string `json:"gatewayNamespace,omitempty"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// Chart version
	ChartVersion *string `json:"chartVersion,omitempty"`
	// Runtime release information
	RuntimeRelease *Release `json:"runtimeRelease"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo,omitempty"`
	// Clusters managed by this runtime
	ManagedClusters []*Cluster `json:"managedClusters"`
	// Total number of clusters managed by this runtime
	ManagedClustersNum int `json:"managedClustersNum"`
	// Runtime features
	Features []*RuntimeFeature `json:"features"`
	// The git provider of the installation repo
	GitProvider *GitProviders `json:"gitProvider,omitempty"`
	// The access mode to the runtime - INGRESS|TUNNEL
	AccessMode AccessMode `json:"accessMode"`
	// Flag for managed runtime to indicate if ISC was initialized
	IscInitialized *bool `json:"iscInitialized,omitempty"`
	// True if lastHeartbeat was recent than some cutoff (if no lastHeartbeat available, checks updatedAt instead)
	Available bool `json:"available"`
	// Status
	Status *RuntimeStatus `json:"status"`
	// True if the runtime is a configuration runtime
	IsConfigurationRuntime bool `json:"isConfigurationRuntime"`
	// True if the runtime is marked as skipped configuring as Argo App
	IsSkippedConfiguringAsArgoApp bool `json:"isSkippedConfiguringAsArgoApp"`
	// The internal shared configuration application name for this runtime
	InternalSharedConfigAppName *string `json:"internalSharedConfigAppName,omitempty"`
	// The in-cluster application name for this runtime
	InClusterApplicationName *string `json:"inClusterApplicationName,omitempty"`
	// The runtime application name for this runtime
	RuntimeApplicationName *string `json:"runtimeApplicationName,omitempty"`
	// Is using an external ArgoCD instance instead of the bundled one
	IsExternalArgoCd *bool `json:"isExternalArgoCd,omitempty"`
	// True if the runtime is installed in single namespace mode
	IsNamespacedRuntime *bool `json:"isNamespacedRuntime,omitempty"`
}

func (Runtime) IsBaseEntity() {}

func (Runtime) IsProjectBasedEntity() {}

func (Runtime) IsK8sLogicEntity() {}

func (Runtime) IsEntity() {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Feature
type RuntimeFeature struct {
	// Runtime feature name
	Name string `json:"name"`
	// Is feature supported
	Supported bool `json:"supported"`
	// Minimal runtime version supporting the feature
	RequiredVersion *string `json:"requiredVersion,omitempty"`
}

// RuntimeInfo
type RuntimeInfo struct {
	// Name
	Name *string `json:"name,omitempty"`
}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Namespace of the Runtime
	RuntimeNamespace *string `json:"runtimeNamespace,omitempty"`
	// Cluster
	Cluster string `json:"cluster"`
	// Type of installation CLI|HELM|HOSTED
	InstallationType *InstallationType `json:"installationType,omitempty"`
	// Managed runtime (default false)
	Managed *bool `json:"managed,omitempty"`
	// The git provider of the installation repo
	GitProvider *GitProviders `json:"gitProvider,omitempty"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// Chart Version
	ChartVersion *string `json:"chartVersion,omitempty"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost,omitempty"`
	// Internal Ingress Host
	InternalIngressHost *string `json:"internalIngressHost,omitempty"`
	// Ingress class name
	IngressClass *string `json:"ingressClass,omitempty"`
	// Ingress controller name
	IngressController *string `json:"ingressController,omitempty"`
	// Gateway name
	GatewayName *string `json:"gatewayName,omitempty"`
	// Gateway namespace
	GatewayNamespace *string `json:"gatewayNamespace,omitempty"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo,omitempty"`
	// Does runtime installed from an existing repo
	Recover *bool `json:"recover,omitempty"`
	// The access mode to the runtime - INGRESS|TUNNEL
	AccessMode *AccessMode `json:"accessMode,omitempty"`
	// Is using an external ArgoCD instance instead of the bundled one
	IsExternalArgoCd *bool `json:"isExternalArgoCd,omitempty"`
}

// Runtime Integarion Response
type RuntimeIntegration struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
	// Config Name
	Config *NamedResource `json:"config,omitempty"`
	// Secret Name
	Secret *NamedResource `json:"secret,omitempty"`
}

// Runtume Notification
type RuntimeNotification struct {
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (RuntimeNotification) IsNotification() {}

func (RuntimeNotification) IsArgoCDNotification() {}

// IntegrationGenerationInput
type RuntimeOperation struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Runtime
	Name string `json:"name"`
	// Runtime
	Action RuntimeOperationAction `json:"action"`
}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// RuntimeStatus
type RuntimeStatus struct {
	// App-Proxy Started
	AppProxyStarted *AppProxyInfo `json:"appProxyStarted"`
	// Git Source Configured
	GitSourceConfigured *AppProxyInfo `json:"gitSourceConfigured"`
	// Default Git Integration
	DefaultGitIntegration *AppProxyInfo `json:"defaultGitIntegration"`
	// Encryption Key
	EncryptionKey *AppProxyInfo `json:"encryptionKey"`
	// Encryption IV
	EncryptionIv *AppProxyInfo `json:"encryptionIv"`
	// Event-Reporter Argo-CD Token
	EventReporterArgoCDToken *AppProxyInfo `json:"eventReporterArgoCDToken"`
	// ISC
	Isc *AppProxyInfo `json:"isc"`
	// Runtime Git Token
	RuntimeGitToken *AppProxyInfo `json:"runtimeGitToken"`
	// Runtime Sync Mode
	SyncMode RuntimeSyncMode `json:"syncMode"`
	// ArgoCD State
	ArgoCdState ArgoCdState `json:"argoCdState"`
}

// Runtime Version Info
type RuntimeVersionInfo struct {
	// Name of the Runtime
	Name string `json:"name"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// Chart version
	ChartVersion *string `json:"chartVersion,omitempty"`
}

// Runtimes statistics
type RuntimesStatistics struct {
	// Total runtimes number
	Total int `json:"total"`
	// Number of unhealthy runtimes
	Unhealthy int `json:"unhealthy"`
}

// SSOArgs
type SSOArgs struct {
	// Id
	ID *string `json:"id,omitempty"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName *string `json:"clientName,omitempty"`
	// Display name
	DisplayName string `json:"displayName"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Entry point
	EntryPoint *string `json:"entryPoint,omitempty"`
	// Callback url
	CallbackURL *string `json:"callbackUrl,omitempty"`
	// Cert
	Cert *string `json:"cert,omitempty"`
	// Provider
	Provider *string `json:"provider,omitempty"`
	// Keyfile
	Keyfile *string `json:"keyfile,omitempty"`
	// Subject
	Subject *string `json:"subject,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// SyncField
	SyncField *string `json:"syncField,omitempty"`
	// App Id
	AppID *string `json:"appId,omitempty"`
	// Tenant
	Tenant *string `json:"tenant,omitempty"`
	// Password
	Password *string `json:"password,omitempty"`
	// URL
	URL *string `json:"url,omitempty"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// Search base
	SearchBase *string `json:"searchBase,omitempty"`
	// Search filter
	SearchFilter *string `json:"searchFilter,omitempty"`
	// Certificate
	Certificate *string `json:"certificate,omitempty"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync,omitempty"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// API client id
	APIClientID *string `json:"apiClientId,omitempty"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Host
	Host *string `json:"host,omitempty"`
	// Realm
	Realm *string `json:"realm,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
	// Sync mirror accounts
	SyncMirrorAccounts []*string `json:"syncMirrorAccounts,omitempty"`
	// Remove deactivated users after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
	// Admin teams
	AdminTeams *string `json:"adminTeams,omitempty"`
	// Remove other admins after sync
	RemoveOtherAdminsAfterSync *bool `json:"removeOtherAdminsAfterSync,omitempty"`
}

// SamlSSO
type SamlSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Entry point
	EntryPoint *string `json:"entryPoint,omitempty"`
	// Callback url
	CallbackURL *string `json:"callbackUrl,omitempty"`
	// Cert
	Cert *string `json:"cert,omitempty"`
	// Provider
	Provider *string `json:"provider,omitempty"`
	// Keyfile
	Keyfile *string `json:"keyfile,omitempty"`
	// Subject
	Subject *string `json:"subject,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// SyncField
	SyncField *string `json:"syncField,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// Application ID
	AppID *string `json:"appId,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
	// Remove deactivated user after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
}

func (SamlSso) IsIDP() {}

// SecretData
type SecretData struct {
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace string `json:"namespace"`
	// Path
	Path *SecretPath `json:"path"`
}

// SecretKeySelector selects a key of a Secret.
type SecretKeySelector struct {
	// Name of the referent.
	Name string `json:"name"`
	// The key of the secret to select from. Must be a valid secret key.
	Key string `json:"key"`
}

// SecretPath
type SecretPath struct {
	// AppId
	AppID string `json:"appId"`
	// ClientId
	ClientID string `json:"clientId"`
	// ClientSecret
	ClientSecret string `json:"clientSecret"`
	// Url
	URL string `json:"url"`
}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold,omitempty"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold,omitempty"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
}

func (Sensor) IsGitopsEntity() {}

func (Sensor) IsBaseEntity() {}

func (Sensor) IsProjectBasedEntity() {}

func (Sensor) IsEntity() {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Service entity
type ServiceEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// ServiceSpec
	Spec *ServiceSpec `json:"spec"`
	// ServiceStatus
	Status *ServiceStatus `json:"status"`
	// Deployment Spec Part
	Deployments []*DeploymentSpecPart `json:"deployments,omitempty"`
}

func (ServiceEntity) IsGitopsEntity() {}

func (ServiceEntity) IsBaseEntity() {}

func (ServiceEntity) IsProjectBasedEntity() {}

func (ServiceEntity) IsEntity() {}

// Service Entity Edge
type ServiceEntityEdge struct {
	// Node contains the actual Service data
	Node *ServiceEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ServiceEntityEdge) IsEdge() {}

// Service Slice
type ServiceEntitySlice struct {
	// Service edges
	Edges []*ServiceEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ServiceEntitySlice) IsSlice() {}

// Service Item Entity
type ServiceItem struct {
	// Name
	Name *string `json:"name,omitempty"`
}

// ServicePort
type ServicePort struct {
	// AppProtocol
	AppProtocol *string `json:"appProtocol,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// NodePort
	NodePort *int `json:"nodePort,omitempty"`
	// Port
	Port *int `json:"port,omitempty"`
	// Protocol
	Protocol *string `json:"protocol,omitempty"`
	// TargetPort
	TargetPort *string `json:"targetPort,omitempty"`
}

// ServiceSpec
type ServiceSpec struct {
	// AllocateLoadBalancerNodePorts
	AllocateLoadBalancerNodePorts *bool `json:"allocateLoadBalancerNodePorts,omitempty"`
	// ClusterIP
	ClusterIP *string `json:"clusterIP,omitempty"`
	// ClusterIPs
	ClusterIPs []*string `json:"clusterIPs,omitempty"`
	// ExternalIPs
	ExternalIPs []*string `json:"externalIPs,omitempty"`
	// ExternalName
	ExternalName *string `json:"externalName,omitempty"`
	// ExternalTrafficPolicy
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy,omitempty"`
	// HealthCheckNodePort
	HealthCheckNodePort *int `json:"healthCheckNodePort,omitempty"`
	// InternalTrafficPolicy
	InternalTrafficPolicy *string `json:"internalTrafficPolicy,omitempty"`
	// IpFamilies
	IPFamilies []*string `json:"ipFamilies,omitempty"`
	// IpFamilyPolicy
	IPFamilyPolicy *string `json:"ipFamilyPolicy,omitempty"`
	// LoadBalancerClass
	LoadBalancerClass *string `json:"loadBalancerClass,omitempty"`
	// LoadBalancerIP
	LoadBalancerIP *string `json:"loadBalancerIP,omitempty"`
	// LoadBalancerSourceRanges
	LoadBalancerSourceRanges []*string `json:"loadBalancerSourceRanges,omitempty"`
	// Ports
	Ports []*ServicePort `json:"ports,omitempty"`
	// PublishNotReadyAddresses
	PublishNotReadyAddresses *bool `json:"publishNotReadyAddresses,omitempty"`
	// Selector
	Selector []*StringPair `json:"selector,omitempty"`
	// SessionAffinity
	SessionAffinity *string `json:"sessionAffinity,omitempty"`
	// SessionAffinityConfig
	SessionAffinityConfig *SessionAffinityConfig `json:"sessionAffinityConfig,omitempty"`
	// Type
	Type *ServiceType `json:"type,omitempty"`
}

// ServiceStatus
type ServiceStatus struct {
	// LoadBalancer
	LoadBalancer *LoadBalancer `json:"loadBalancer,omitempty"`
}

// ServiceTransition Entity
type ServiceTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseServiceState `json:"from,omitempty"`
	// To
	To *ReleaseServiceState `json:"to,omitempty"`
}

// ServiceUser
type ServiceUser struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin,omitempty"`
	// The accounts the this user have access to
	Accounts []*Account `json:"accounts,omitempty"`
	// Register date
	RegisterDate *string `json:"registerDate,omitempty"`
	// Is service
	IsService *bool `json:"isService,omitempty"`
	// Is disabled
	IsDisabled *bool `json:"isDisabled,omitempty"`
	// Service user teams
	Teams []*ServiceUserTeam `json:"teams"`
	// Service user api keys
	APIKeys []*APIKey `json:"apiKeys"`
}

// ServiceUserArgs
type ServiceUserArgs struct {
	// The user name
	UserName string `json:"userName"`
	// Team ids
	TeamIds []string `json:"teamIds,omitempty"`
	// Assign admin role
	AssignAdminRole *bool `json:"assignAdminRole,omitempty"`
}

// ServiceUserFilter
type ServiceUserFilter struct {
	// The partial service user name
	PartialName *string `json:"partialName,omitempty"`
	// The team IDs
	TeamIds []string `json:"teamIds,omitempty"`
}

// ServiceUserTeam
type ServiceUserTeam struct {
	// The team id
	ID string `json:"id"`
	// The team name
	Name string `json:"name"`
	// The team account ID
	Account string `json:"account"`
	// The team userIds
	Users []*string `json:"users"`
	// The team tags
	Tags []*string `json:"tags"`
	// The team type
	Type *string `json:"type,omitempty"`
	// The team create time
	CreatedAt *string `json:"createdAt,omitempty"`
	// The team update time
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// SessionAffinityConfig
type SessionAffinityConfig struct {
	// ClientIP
	ClientIP *ClientIP `json:"clientIP,omitempty"`
}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains,omitempty"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains,omitempty"`
}

// Args to set the permissions of a specific user to a git-source
type SetGitSourcePermissionArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace,omitempty"`
	// The new permission to set
	Permission *PermissionInput `json:"permission"`
}

// Single dependency item
type SingleComponentDependency struct {
	// Name of dependency
	Name string `json:"name"`
	// Version
	Version string `json:"version"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor,omitempty"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after,omitempty"`
	// Returns entities before the provided cursor
	Before *string `json:"before,omitempty"`
	// Returns the first X entities
	First *int `json:"first,omitempty"`
	// Returns the last X entities
	Last *int `json:"last,omitempty"`
}

// Argo CD Application status
type SourceRevisionInfo struct {
	// CommitAuthor
	Author *string `json:"author,omitempty"`
	// CommitMessage
	Message *string `json:"message,omitempty"`
	// CommitDate
	Date *string `json:"date,omitempty"`
	// CommitAvatar
	Avatar *string `json:"avatar,omitempty"`
	// CommitUrl
	URL *string `json:"url,omitempty"`
	// Revision
	Revision string `json:"revision"`
}

// Object of specific trigger conditions
type SpecificTriggerConditions struct {
	// Github trigger conditions
	Github []*GithubTriggerConditions `json:"github,omitempty"`
	// Gitlab trigger conditions
	Gitlab []*GitlabTriggerConditions `json:"gitlab,omitempty"`
	// BitbucketServer trigger conditions
	Bitbucketserver []*BitbucketServerTriggerConditions `json:"bitbucketserver,omitempty"`
	// BitbucketCloud trigger conditions
	Bitbucket []*BitbucketCloudTriggerConditions `json:"bitbucket,omitempty"`
	// Calendar trigger conditions
	Calendar []*CalendarTriggerConditions `json:"calendar,omitempty"`
}

// Object of specific trigger conditions
type SpecificTriggerConditionsArgs struct {
	// Github trigger conditions
	Github []*GithubTriggerConditionsArgs `json:"github,omitempty"`
	// Gitlab trigger conditions
	Gitlab []*GitlabTriggerConditionsArgs `json:"gitlab,omitempty"`
	// BitbucketServer trigger conditions
	Bitbucketserver []*BitbucketServerTriggerConditionsArgs `json:"bitbucketserver,omitempty"`
	// BitbucketCloud trigger conditions
	Bitbucket []*BitbucketCloudTriggerConditionsArgs `json:"bitbucket,omitempty"`
	// Calendar trigger conditions
	Calendar []*CalendarTriggerConditionsArgs `json:"calendar,omitempty"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType,omitempty"`
	// Display name
	DisplayName *string `json:"displayName,omitempty"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity,omitempty"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange,omitempty"`
	// Prev data range
	PrevDateRange []*string `json:"prevDateRange,omitempty"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message,omitempty"`
}

// Label
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// Stripe
type Stripe struct {
	// Name
	HardCodedPlan *bool `json:"hardCodedPlan,omitempty"`
	// Plan id
	PlanID *string `json:"planId,omitempty"`
	// Subscription id
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// Customer id
	CustomerID *string `json:"customerId,omitempty"`
}

// Event filter
type SupportedEventMapping struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// Mappings between the var name and the path to the value in event payload
	Mappings []*Mapping `json:"mappings"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken,omitempty"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion,omitempty"`
	// The entity related to this error
	Object BaseEntity `json:"object,omitempty"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context,omitempty"`
}

func (SyncError) IsError() {}

// Aplication SyncResultResource
type SyncResultResource struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Message
	Message *string `json:"message,omitempty"`
	// Sync Action On Resource
	SyncActionOnResource *SyncActionOnResource `json:"syncActionOnResource,omitempty"`
	// Status
	Status *SyncResultCode `json:"status,omitempty"`
	// Sync Phase
	SyncPhase *SyncPhase `json:"syncPhase,omitempty"`
	// Hook Phase
	HookPhase *SyncOperationPhase `json:"hookPhase,omitempty"`
	// Hook Type
	HookType *SyncHookType `json:"hookType,omitempty"`
}

// Synced revision metadata input
type SyncedRevisionMetadataInput struct {
	// Resource git manifest
	Revision string `json:"revision"`
	// Commit author
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// Commit date
	CommitDate *string `json:"commitDate,omitempty"`
	// Commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Git commit web url
	CommitURL *string `json:"commitURL,omitempty"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL,omitempty"`
	// Author web profile url
	ProfileURL *string `json:"profileURL,omitempty"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL,omitempty"`
}

// SystemTypeOutput
type SystemTypeOutput struct {
	// SystemType
	SystemType SystemType `json:"systemType"`
}

// Team
type Team struct {
	// Team name
	Name string `json:"name"`
	// Team ID
	ID string `json:"id"`
	// Account ID
	Account *string `json:"account,omitempty"`
	// List of users in team
	Users []*User `json:"users,omitempty"`
	// Team tags
	Tags []*string `json:"tags,omitempty"`
	// Team type
	Type *TeamType `json:"type,omitempty"`
	// Team ref id
	RefID *string `json:"refId,omitempty"`
	// Team source
	Source *TeamSource `json:"source,omitempty"`
	// Service accounts
	ServiceAccounts []*User `json:"serviceAccounts,omitempty"`
}

// Args to edit team details
type TeamDetailsArgs struct {
	// The team id
	ID string `json:"id"`
	// The team name
	Name string `json:"name"`
}

// Time Series Data Record
type TimeSeriesDataRecord struct {
	// Time
	Time string `json:"time"`
	// Value
	Value int `json:"value"`
}

// To State Entity
type ToState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Transition Entity
type Transition struct {
	// Services
	Services []*ServiceTransition `json:"services"`
	// Rollouts
	Rollouts []*RolloutTransition `json:"rollouts"`
}

// Trial
type Trial struct {
	// Trialing
	Trialing *bool `json:"trialing,omitempty"`
	// IsRuntimePaying
	IsRuntimePaying *bool `json:"isRuntimePaying,omitempty"`
	// TrialWillEndNotified
	TrialWillEndNotified *bool `json:"trialWillEndNotified,omitempty"`
	// TrialEndedNotified
	TrialEndedNotified *bool `json:"trialEndedNotified,omitempty"`
	// Type
	Type *string `json:"type,omitempty"`
	// PreviousSegment
	PreviousSegment *string `json:"previousSegment,omitempty"`
	// TrialStart
	TrialStart *string `json:"trialStart,omitempty"`
	// TrialEnd
	TrialEnd *string `json:"trialEnd,omitempty"`
}

// Differentiated DataFilters
type TriggerConditionDataFilters struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilter `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilter `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilter `json:"predefined"`
}

// Differentiated DataFilters
type TriggerConditionDataFiltersArgs struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilterArgs `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilterArgs `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilterArgs `json:"predefined"`
}

// TriggerConditions filters object
type TriggerConditionFilters struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFilters `json:"data"`
}

// TriggerConditions filters object
type TriggerConditionFiltersArgs struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFiltersArgs `json:"data"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameter struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation,omitempty"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameterArgs struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation,omitempty"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditions struct {
	// Conditions
	Conditions *SpecificTriggerConditions `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflow `json:"workflow"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditionsArgs struct {
	// Sensor name
	SensorName string `json:"sensorName"`
	// Trigger name
	TriggerName string `json:"triggerName"`
	// Ingress host (SET ON BACKEND)
	IngressHost *string `json:"ingressHost,omitempty"`
	// Conditions
	Conditions *SpecificTriggerConditionsArgs `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflowArgs `json:"workflow"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflow struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint,omitempty"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameter `json:"parameters"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflowArgs struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint,omitempty"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameterArgs `json:"parameters"`
}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// Update Environment Input
type UpdateEnvironmentArgs struct {
	// Id of the environment
	ID string `json:"id"`
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// List of clusters that belong to this environment
	Clusters []*EnvironmentClusterInput `json:"clusters"`
	// Label pairs array strings(key=value)
	LabelPairs []string `json:"labelPairs"`
}

// Args to update the permissions of a git-source
type UpdateGitSourcePermissionsArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace,omitempty"`
	// The set of permissions
	Permissions []*PermissionInput `json:"permissions"`
}

// Update Product Input
type UpdateProductArgs struct {
	// Id of the Product
	ID string `json:"id"`
	// Product name
	Name string `json:"name"`
	// Tags list
	Tags []*string `json:"tags"`
}

// Usage State for each resource
type UsageState struct {
	// Used
	Used *int `json:"used,omitempty"`
	// Limit
	Limit *int `json:"limit,omitempty"`
	// Whether the usage has reached the limit
	IsReached bool `json:"isReached"`
	// Whether the usage has exceeded the limit
	IsExceeded bool `json:"isExceeded"`
	// Whether the usage has exceeded the limit to the point where we enforce harder
	IsHardExceeded bool `json:"isHardExceeded"`
}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin,omitempty"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts,omitempty"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount,omitempty"`
	// The customers that this user is in
	Customers []Customer `json:"customers,omitempty"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate,omitempty"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate,omitempty"`
	// User chosen sso of active account
	Sso *string `json:"sso,omitempty"`
	// User settings
	Settings *UserSettings `json:"settings,omitempty"`
	// GitOps settings
	GitOpsSettings []*GitOpsSettings `json:"gitOpsSettings,omitempty"`
	// Runtime name
	RuntimeName *string `json:"runtimeName,omitempty"`
	// Service account flag
	IsDisabled *bool `json:"isDisabled,omitempty"`
}

// Args to edit user details
type UserDetailsArgs struct {
	// User settings
	Settings *UserSettingsArgs `json:"settings,omitempty"`
}

// User settings
type UserSettings struct {
	// Allow admin to login
	AllowAdminToLogin *bool `json:"allowAdminToLogin,omitempty"`
	// Show product unmapped apps
	ShowProductUnmappedApps *bool `json:"showProductUnmappedApps,omitempty"`
	// Display welcome screen
	DisplayWelcomeScreen *bool `json:"displayWelcomeScreen,omitempty"`
}

// Args to edit settings user details
type UserSettingsArgs struct {
	// Allow admin to login
	AllowAdminToLogin *bool `json:"allowAdminToLogin,omitempty"`
	// Display welcome screen
	DisplayWelcomeScreen *bool `json:"displayWelcomeScreen,omitempty"`
	// Show product unmapped apps
	ShowProductUnmappedApps *bool `json:"showProductUnmappedApps,omitempty"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Initiator of the workflow
	Initiator *WorkflowInitiator `json:"initiator,omitempty"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []string `json:"eventsPayload"`
	// Pipeline reference
	Pipeline *Pipeline `json:"pipeline,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Workflow URL. Maybe empty if the runtime was deleted.
	URL *string `json:"url,omitempty"`
	// Workflow's runtime ingress host. Maybe empty if the runtime was deleted.
	IngressHost *string `json:"ingressHost,omitempty"`
	// Workflow's runtime version. Maybe empty if the runtime was deleted.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// Indicates that workflow was created by platform/app-proxy and the value shows the flow that caused the creation
	OriginatedFrom *string `json:"originatedFrom,omitempty"`
	// Workflows which executed by this workflow
	ChildWorkflows []*ChildWorkflowRef `json:"childWorkflows,omitempty"`
	// Parent workflow that executed this workflow
	ParentWorkflow *ParentWorkflowRef `json:"parentWorkflow,omitempty"`
	// Image details that was created from report image workflow execution.
	ImageDetails *ImageDetails `json:"imageDetails,omitempty"`
}

func (Workflow) IsProjectBasedEntity() {}

func (Workflow) IsBaseEntity() {}

func (Workflow) IsK8sStandardEntity() {}

func (Workflow) IsEntity() {}

// WorkflowArguments
type WorkflowArguments struct {
	// Workflow parameters
	Parameters []*WorkflowParameter `json:"parameters,omitempty"`
}

// WorkflowConcurrency
type WorkflowConcurrency struct {
	// Concurrency
	Concurrency *WorkflowConcurrencyInfo `json:"concurrency,omitempty"`
}

// WorkflowConcurrency
type WorkflowConcurrencyInfo struct {
	// Price
	Price *BasePrice `json:"price,omitempty"`
	// Amount
	Amount *int `json:"amount,omitempty"`
	// Absorb
	Absorb *int `json:"absorb,omitempty"`
	// Min
	Min *int `json:"min,omitempty"`
	// Max
	Max *int `json:"max,omitempty"`
	// AllowUnlimited
	AllowUnlimited *bool `json:"allowUnlimited,omitempty"`
}

// Workflow conditions
type WorkflowConditions struct {
	// Type
	Type *string `json:"type,omitempty"`
	// Status
	Status *string `json:"status,omitempty"`
}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Image
	Image *string `json:"image,omitempty"`
	// Command array
	Command []*string `json:"command,omitempty"`
	// Args
	Args []*string `json:"args,omitempty"`
	// Env map
	Env []*StringPair `json:"env,omitempty"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon,omitempty"`
	// Container
	Container *WorkflowContainerSpec `json:"container,omitempty"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName,omitempty"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef,omitempty"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast,omitempty"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// If the workflow created through the wt playground it will contain username and avatar URL of codefresh user.
// If the workflow was triggered by some GIT event it will contain username and avatar URL of git user.
// Otherwise this field will be empty.
type WorkflowInitiator struct {
	// Initiator name
	Name string `json:"name"`
	// Initiator avatar URL
	AvatarURL *string `json:"avatarURL,omitempty"`
}

// Product Release step workflow issue
type WorkflowIssue struct {
	// Application Name
	ApplicationName string `json:"applicationName"`
	// Issue date
	Date string `json:"date"`
	// Error message
	Message string `json:"message"`
	// Workflow name
	WorkflowName string `json:"workflowName"`
	// Issue type
	Type IssueType `json:"type"`
	// Error level
	Level ErrorLevels `json:"level"`
}

func (WorkflowIssue) IsIssueKind() {}

func (WorkflowIssue) IsIssue() {}

// Workflow last execution object
type WorkflowLastExecution struct {
	// Arguments
	Arguments *WorkflowArguments `json:"arguments,omitempty"`
}

// Workflow Parameter object
type WorkflowParameter struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value,omitempty"`
	// Default value
	Default *string `json:"default,omitempty"`
}

// Workflow Parameter object
type WorkflowParameterArgs struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value,omitempty"`
	// Default value
	Default *string `json:"default,omitempty"`
}

// "Repository data for workflows
type WorkflowRepository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow resources duration
type WorkflowResourcesDuration struct {
	// Cpu
	CPU *int `json:"cpu,omitempty"`
	// Memory
	Memory *int `json:"memory,omitempty"`
}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint,omitempty"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates,omitempty"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef,omitempty"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *string `json:"progress,omitempty"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes,omitempty"`
	// Message
	Message *string `json:"message,omitempty"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses,omitempty"`
	// Stored Templates
	StoredTemplates *string `json:"storedTemplates,omitempty"`
	// Stored workflow template spec
	StoredWorkflowTemplateSpec *string `json:"storedWorkflowTemplateSpec,omitempty"`
	// Conditions
	Conditions []*WorkflowConditions `json:"conditions,omitempty"`
	// Resources duration
	ResourcesDuration *WorkflowResourcesDuration `json:"resourcesDuration,omitempty"`
	// Amount of running pods
	RunningPodsCount int `json:"runningPodsCount"`
	// Name of the first running pod
	ActivePodName *string `json:"activePodName,omitempty"`
	// Current workflow failed nodes status
	FailedNodes []*NodeStatus `json:"failedNodes,omitempty"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName,omitempty"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef,omitempty"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity() {}

func (WorkflowTemplate) IsBaseEntity() {}

func (WorkflowTemplate) IsProjectBasedEntity() {}

func (WorkflowTemplate) IsEntity() {}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow template filter arguments
type WorkflowTemplatesFilterArgs struct {
	// Filter WorkflowTemplates from a specific project
	Project *string `json:"project,omitempty"`
	// Filter WorkflowTemplates from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter WorkflowTemplates from a specific cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Filter WorkflowTemplates by name
	Name *string `json:"name,omitempty"`
	// Filter WorkflowTemplates by namespace
	Namespace *string `json:"namespace,omitempty"`
	// Filter WorkflowTemplates by group
	Groups []*string `json:"groups,omitempty"`
	// Filter WorkflowTemplates by version
	Versions []*string `json:"versions,omitempty"`
	// Filter WorkflowTemplates by git source
	GitSource *string `json:"gitSource,omitempty"`
	// Filter WorkflowTemplates that are related to promotions
	PromotionRelated *bool `json:"promotionRelated,omitempty"`
}

// Applications Workflows Step view
type WorkflowsStepView struct {
	// Applications workflow step name, only for running/succeed/failed workflows
	Name *string `json:"name,omitempty"`
	// Applications workflow template step name
	TemplateName string `json:"templateName"`
	// Workflow start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Workflow finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Application status
	Status WorkflowNodePhases `json:"status"`
	// Application workflows info
	Workflows []*ReleaseStepWorkflowInfo `json:"workflows,omitempty"`
}

// AbacActionNames
type AbacActionNames string

const (
	AbacActionNamesAccessArtifacts        AbacActionNames = "ACCESS_ARTIFACTS"
	AbacActionNamesAccessLogs             AbacActionNames = "ACCESS_LOGS"
	AbacActionNamesAppRollback            AbacActionNames = "APP_ROLLBACK"
	AbacActionNamesCreate                 AbacActionNames = "CREATE"
	AbacActionNamesDeleteResource         AbacActionNames = "DELETE_RESOURCE"
	AbacActionNamesExecToPod              AbacActionNames = "EXEC_TO_POD"
	AbacActionNamesPromoteTo              AbacActionNames = "PROMOTE_TO"
	AbacActionNamesRefresh                AbacActionNames = "REFRESH"
	AbacActionNamesRestart                AbacActionNames = "RESTART"
	AbacActionNamesResubmit               AbacActionNames = "RESUBMIT"
	AbacActionNamesRetryRelease           AbacActionNames = "RETRY_RELEASE"
	AbacActionNamesRolloutAbort           AbacActionNames = "ROLLOUT_ABORT"
	AbacActionNamesRolloutPause           AbacActionNames = "ROLLOUT_PAUSE"
	AbacActionNamesRolloutPromoteFull     AbacActionNames = "ROLLOUT_PROMOTE_FULL"
	AbacActionNamesRolloutRestart         AbacActionNames = "ROLLOUT_RESTART"
	AbacActionNamesRolloutResume          AbacActionNames = "ROLLOUT_RESUME"
	AbacActionNamesRolloutRetry           AbacActionNames = "ROLLOUT_RETRY"
	AbacActionNamesRolloutSkipCurrentStep AbacActionNames = "ROLLOUT_SKIP_CURRENT_STEP"
	AbacActionNamesStop                   AbacActionNames = "STOP"
	AbacActionNamesSync                   AbacActionNames = "SYNC"
	AbacActionNamesTerminate              AbacActionNames = "TERMINATE"
	AbacActionNamesTerminateSync          AbacActionNames = "TERMINATE_SYNC"
	AbacActionNamesTriggerPromotion       AbacActionNames = "TRIGGER_PROMOTION"
	AbacActionNamesView                   AbacActionNames = "VIEW"
	AbacActionNamesViewPodLogs            AbacActionNames = "VIEW_POD_LOGS"
)

var AllAbacActionNames = []AbacActionNames{
	AbacActionNamesAccessArtifacts,
	AbacActionNamesAccessLogs,
	AbacActionNamesAppRollback,
	AbacActionNamesCreate,
	AbacActionNamesDeleteResource,
	AbacActionNamesExecToPod,
	AbacActionNamesPromoteTo,
	AbacActionNamesRefresh,
	AbacActionNamesRestart,
	AbacActionNamesResubmit,
	AbacActionNamesRetryRelease,
	AbacActionNamesRolloutAbort,
	AbacActionNamesRolloutPause,
	AbacActionNamesRolloutPromoteFull,
	AbacActionNamesRolloutRestart,
	AbacActionNamesRolloutResume,
	AbacActionNamesRolloutRetry,
	AbacActionNamesRolloutSkipCurrentStep,
	AbacActionNamesStop,
	AbacActionNamesSync,
	AbacActionNamesTerminate,
	AbacActionNamesTerminateSync,
	AbacActionNamesTriggerPromotion,
	AbacActionNamesView,
	AbacActionNamesViewPodLogs,
}

func (e AbacActionNames) IsValid() bool {
	switch e {
	case AbacActionNamesAccessArtifacts, AbacActionNamesAccessLogs, AbacActionNamesAppRollback, AbacActionNamesCreate, AbacActionNamesDeleteResource, AbacActionNamesExecToPod, AbacActionNamesPromoteTo, AbacActionNamesRefresh, AbacActionNamesRestart, AbacActionNamesResubmit, AbacActionNamesRetryRelease, AbacActionNamesRolloutAbort, AbacActionNamesRolloutPause, AbacActionNamesRolloutPromoteFull, AbacActionNamesRolloutRestart, AbacActionNamesRolloutResume, AbacActionNamesRolloutRetry, AbacActionNamesRolloutSkipCurrentStep, AbacActionNamesStop, AbacActionNamesSync, AbacActionNamesTerminate, AbacActionNamesTerminateSync, AbacActionNamesTriggerPromotion, AbacActionNamesView, AbacActionNamesViewPodLogs:
		return true
	}
	return false
}

func (e AbacActionNames) String() string {
	return string(e)
}

func (e *AbacActionNames) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AbacActionNames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AbacActionNames", str)
	}
	return nil
}

func (e AbacActionNames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AbacActionNames) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AbacActionNames) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// AbacAttributeNames
type AbacAttributeNames string

const (
	AbacAttributeNamesCluster         AbacAttributeNames = "CLUSTER"
	AbacAttributeNamesEnvironmentKind AbacAttributeNames = "ENVIRONMENT_KIND"
	AbacAttributeNamesEnvironmentName AbacAttributeNames = "ENVIRONMENT_NAME"
	AbacAttributeNamesGitSource       AbacAttributeNames = "GIT_SOURCE"
	AbacAttributeNamesLabel           AbacAttributeNames = "LABEL"
	AbacAttributeNamesNamespace       AbacAttributeNames = "NAMESPACE"
	AbacAttributeNamesProductName     AbacAttributeNames = "PRODUCT_NAME"
	AbacAttributeNamesRuntime         AbacAttributeNames = "RUNTIME"
)

var AllAbacAttributeNames = []AbacAttributeNames{
	AbacAttributeNamesCluster,
	AbacAttributeNamesEnvironmentKind,
	AbacAttributeNamesEnvironmentName,
	AbacAttributeNamesGitSource,
	AbacAttributeNamesLabel,
	AbacAttributeNamesNamespace,
	AbacAttributeNamesProductName,
	AbacAttributeNamesRuntime,
}

func (e AbacAttributeNames) IsValid() bool {
	switch e {
	case AbacAttributeNamesCluster, AbacAttributeNamesEnvironmentKind, AbacAttributeNamesEnvironmentName, AbacAttributeNamesGitSource, AbacAttributeNamesLabel, AbacAttributeNamesNamespace, AbacAttributeNamesProductName, AbacAttributeNamesRuntime:
		return true
	}
	return false
}

func (e AbacAttributeNames) String() string {
	return string(e)
}

func (e *AbacAttributeNames) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AbacAttributeNames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AbacAttributeNames", str)
	}
	return nil
}

func (e AbacAttributeNames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AbacAttributeNames) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AbacAttributeNames) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Values from AbacEntityValues enum
type AbacEntityValues string

const (
	AbacEntityValuesClusters            AbacEntityValues = "clusters"
	AbacEntityValuesEnvironments        AbacEntityValues = "environments"
	AbacEntityValuesExecutionContext    AbacEntityValues = "executionContext"
	AbacEntityValuesGitContexts         AbacEntityValues = "gitContexts"
	AbacEntityValuesGitopsApplications  AbacEntityValues = "gitopsApplications"
	AbacEntityValuesHelmCharts          AbacEntityValues = "helmCharts"
	AbacEntityValuesPipelines           AbacEntityValues = "pipelines"
	AbacEntityValuesProducts            AbacEntityValues = "products"
	AbacEntityValuesProjects            AbacEntityValues = "projects"
	AbacEntityValuesPromotionFlows      AbacEntityValues = "promotionFlows"
	AbacEntityValuesSharedConfiguration AbacEntityValues = "sharedConfiguration"
	AbacEntityValuesWorkflows           AbacEntityValues = "workflows"
	AbacEntityValuesWorkflowTemplates   AbacEntityValues = "workflowTemplates"
)

var AllAbacEntityValues = []AbacEntityValues{
	AbacEntityValuesClusters,
	AbacEntityValuesEnvironments,
	AbacEntityValuesExecutionContext,
	AbacEntityValuesGitContexts,
	AbacEntityValuesGitopsApplications,
	AbacEntityValuesHelmCharts,
	AbacEntityValuesPipelines,
	AbacEntityValuesProducts,
	AbacEntityValuesProjects,
	AbacEntityValuesPromotionFlows,
	AbacEntityValuesSharedConfiguration,
	AbacEntityValuesWorkflows,
	AbacEntityValuesWorkflowTemplates,
}

func (e AbacEntityValues) IsValid() bool {
	switch e {
	case AbacEntityValuesClusters, AbacEntityValuesEnvironments, AbacEntityValuesExecutionContext, AbacEntityValuesGitContexts, AbacEntityValuesGitopsApplications, AbacEntityValuesHelmCharts, AbacEntityValuesPipelines, AbacEntityValuesProducts, AbacEntityValuesProjects, AbacEntityValuesPromotionFlows, AbacEntityValuesSharedConfiguration, AbacEntityValuesWorkflows, AbacEntityValuesWorkflowTemplates:
		return true
	}
	return false
}

func (e AbacEntityValues) String() string {
	return string(e)
}

func (e *AbacEntityValues) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AbacEntityValues(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AbacEntityValues", str)
	}
	return nil
}

func (e AbacEntityValues) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AbacEntityValues) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AbacEntityValues) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Access Mode
type AccessMode string

const (
	// standard installation using an ingress resource
	AccessModeIngress AccessMode = "INGRESS"
	// ingressless installation, using an FRP tunnel
	AccessModeTunnel AccessMode = "TUNNEL"
)

var AllAccessMode = []AccessMode{
	AccessModeIngress,
	AccessModeTunnel,
}

func (e AccessMode) IsValid() bool {
	switch e {
	case AccessModeIngress, AccessModeTunnel:
		return true
	}
	return false
}

func (e AccessMode) String() string {
	return string(e)
}

func (e *AccessMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessMode", str)
	}
	return nil
}

func (e AccessMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccessMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccessMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Analysis Metric Provider Types
type AnalysisMetricProviderTypes string

const (
	// CLOUD_WATCH
	AnalysisMetricProviderTypesCloudWatch AnalysisMetricProviderTypes = "CLOUD_WATCH"
	// DATADOG
	AnalysisMetricProviderTypesDatadog AnalysisMetricProviderTypes = "DATADOG"
	// JOB
	AnalysisMetricProviderTypesJob AnalysisMetricProviderTypes = "JOB"
	// KAYENTA
	AnalysisMetricProviderTypesKayenta AnalysisMetricProviderTypes = "KAYENTA"
	// NEW_RELIC
	AnalysisMetricProviderTypesNewRelic AnalysisMetricProviderTypes = "NEW_RELIC"
	// PROMETHEUS
	AnalysisMetricProviderTypesPrometheus AnalysisMetricProviderTypes = "PROMETHEUS"
	// UNKNOWN
	AnalysisMetricProviderTypesUnknown AnalysisMetricProviderTypes = "UNKNOWN"
	// WAVEFRONT
	AnalysisMetricProviderTypesWavefront AnalysisMetricProviderTypes = "WAVEFRONT"
	// WEB
	AnalysisMetricProviderTypesWeb AnalysisMetricProviderTypes = "WEB"
)

var AllAnalysisMetricProviderTypes = []AnalysisMetricProviderTypes{
	AnalysisMetricProviderTypesCloudWatch,
	AnalysisMetricProviderTypesDatadog,
	AnalysisMetricProviderTypesJob,
	AnalysisMetricProviderTypesKayenta,
	AnalysisMetricProviderTypesNewRelic,
	AnalysisMetricProviderTypesPrometheus,
	AnalysisMetricProviderTypesUnknown,
	AnalysisMetricProviderTypesWavefront,
	AnalysisMetricProviderTypesWeb,
}

func (e AnalysisMetricProviderTypes) IsValid() bool {
	switch e {
	case AnalysisMetricProviderTypesCloudWatch, AnalysisMetricProviderTypesDatadog, AnalysisMetricProviderTypesJob, AnalysisMetricProviderTypesKayenta, AnalysisMetricProviderTypesNewRelic, AnalysisMetricProviderTypesPrometheus, AnalysisMetricProviderTypesUnknown, AnalysisMetricProviderTypesWavefront, AnalysisMetricProviderTypesWeb:
		return true
	}
	return false
}

func (e AnalysisMetricProviderTypes) String() string {
	return string(e)
}

func (e *AnalysisMetricProviderTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnalysisMetricProviderTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnalysisMetricProviderTypes", str)
	}
	return nil
}

func (e AnalysisMetricProviderTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnalysisMetricProviderTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnalysisMetricProviderTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// AnalysisPhases
type AnalysisPhases string

const (
	// Error
	AnalysisPhasesError AnalysisPhases = "Error"
	// Failed
	AnalysisPhasesFailed AnalysisPhases = "Failed"
	// Inconclusive
	AnalysisPhasesInconclusive AnalysisPhases = "Inconclusive"
	// Pending
	AnalysisPhasesPending AnalysisPhases = "Pending"
	// Running
	AnalysisPhasesRunning AnalysisPhases = "Running"
	// Successful
	AnalysisPhasesSuccessful AnalysisPhases = "Successful"
)

var AllAnalysisPhases = []AnalysisPhases{
	AnalysisPhasesError,
	AnalysisPhasesFailed,
	AnalysisPhasesInconclusive,
	AnalysisPhasesPending,
	AnalysisPhasesRunning,
	AnalysisPhasesSuccessful,
}

func (e AnalysisPhases) IsValid() bool {
	switch e {
	case AnalysisPhasesError, AnalysisPhasesFailed, AnalysisPhasesInconclusive, AnalysisPhasesPending, AnalysisPhasesRunning, AnalysisPhasesSuccessful:
		return true
	}
	return false
}

func (e AnalysisPhases) String() string {
	return string(e)
}

func (e *AnalysisPhases) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnalysisPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnalysisPhases", str)
	}
	return nil
}

func (e AnalysisPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnalysisPhases) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnalysisPhases) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SyncOperationPhase
type AppOperationType string

const (
	// Delete
	AppOperationTypeDelete AppOperationType = "Delete"
	// Sync
	AppOperationTypeSync AppOperationType = "Sync"
	// Unknown
	AppOperationTypeUnknown AppOperationType = "Unknown"
)

var AllAppOperationType = []AppOperationType{
	AppOperationTypeDelete,
	AppOperationTypeSync,
	AppOperationTypeUnknown,
}

func (e AppOperationType) IsValid() bool {
	switch e {
	case AppOperationTypeDelete, AppOperationTypeSync, AppOperationTypeUnknown:
		return true
	}
	return false
}

func (e AppOperationType) String() string {
	return string(e)
}

func (e *AppOperationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppOperationType", str)
	}
	return nil
}

func (e AppOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppOperationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppOperationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// App-Proxy Status
type AppProxyStatus string

const (
	// FAILED
	AppProxyStatusFailed AppProxyStatus = "FAILED"
	// SUCCESSFUL
	AppProxyStatusSuccessful AppProxyStatus = "SUCCESSFUL"
	// UNKNOWN
	AppProxyStatusUnknown AppProxyStatus = "UNKNOWN"
)

var AllAppProxyStatus = []AppProxyStatus{
	AppProxyStatusFailed,
	AppProxyStatusSuccessful,
	AppProxyStatusUnknown,
}

func (e AppProxyStatus) IsValid() bool {
	switch e {
	case AppProxyStatusFailed, AppProxyStatusSuccessful, AppProxyStatusUnknown:
		return true
	}
	return false
}

func (e AppProxyStatus) String() string {
	return string(e)
}

func (e *AppProxyStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppProxyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppProxyStatus", str)
	}
	return nil
}

func (e AppProxyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppProxyStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppProxyStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// App Sync Policies
type AppSyncPolicies string

const (
	// Automated
	AppSyncPoliciesAutomated AppSyncPolicies = "Automated"
	// Manual
	AppSyncPoliciesManual AppSyncPolicies = "Manual"
	// Unknown
	AppSyncPoliciesUnknown AppSyncPolicies = "Unknown"
)

var AllAppSyncPolicies = []AppSyncPolicies{
	AppSyncPoliciesAutomated,
	AppSyncPoliciesManual,
	AppSyncPoliciesUnknown,
}

func (e AppSyncPolicies) IsValid() bool {
	switch e {
	case AppSyncPoliciesAutomated, AppSyncPoliciesManual, AppSyncPoliciesUnknown:
		return true
	}
	return false
}

func (e AppSyncPolicies) String() string {
	return string(e)
}

func (e *AppSyncPolicies) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppSyncPolicies(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppSyncPolicies", str)
	}
	return nil
}

func (e AppSyncPolicies) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppSyncPolicies) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppSyncPolicies) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Groups Sorting field
type ApplicationGroupsSortingField string

const (
	// By name
	ApplicationGroupsSortingFieldName ApplicationGroupsSortingField = "name"
	// By updated at
	ApplicationGroupsSortingFieldUpdatedAt ApplicationGroupsSortingField = "updatedAt"
)

var AllApplicationGroupsSortingField = []ApplicationGroupsSortingField{
	ApplicationGroupsSortingFieldName,
	ApplicationGroupsSortingFieldUpdatedAt,
}

func (e ApplicationGroupsSortingField) IsValid() bool {
	switch e {
	case ApplicationGroupsSortingFieldName, ApplicationGroupsSortingFieldUpdatedAt:
		return true
	}
	return false
}

func (e ApplicationGroupsSortingField) String() string {
	return string(e)
}

func (e *ApplicationGroupsSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationGroupsSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationGroupsSortingField", str)
	}
	return nil
}

func (e ApplicationGroupsSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationGroupsSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationGroupsSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Tree Sorting field
type ApplicationTreeSortingField string

const (
	// healthStatus
	ApplicationTreeSortingFieldHealthStatus ApplicationTreeSortingField = "healthStatus"
	// kind
	ApplicationTreeSortingFieldKind ApplicationTreeSortingField = "kind"
	// last deployment date
	ApplicationTreeSortingFieldLastUpdated ApplicationTreeSortingField = "lastUpdated"
	// name
	ApplicationTreeSortingFieldName ApplicationTreeSortingField = "name"
	// runtime
	ApplicationTreeSortingFieldRuntime ApplicationTreeSortingField = "runtime"
	// syncStatus
	ApplicationTreeSortingFieldSyncStatus ApplicationTreeSortingField = "syncStatus"
)

var AllApplicationTreeSortingField = []ApplicationTreeSortingField{
	ApplicationTreeSortingFieldHealthStatus,
	ApplicationTreeSortingFieldKind,
	ApplicationTreeSortingFieldLastUpdated,
	ApplicationTreeSortingFieldName,
	ApplicationTreeSortingFieldRuntime,
	ApplicationTreeSortingFieldSyncStatus,
}

func (e ApplicationTreeSortingField) IsValid() bool {
	switch e {
	case ApplicationTreeSortingFieldHealthStatus, ApplicationTreeSortingFieldKind, ApplicationTreeSortingFieldLastUpdated, ApplicationTreeSortingFieldName, ApplicationTreeSortingFieldRuntime, ApplicationTreeSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e ApplicationTreeSortingField) String() string {
	return string(e)
}

func (e *ApplicationTreeSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationTreeSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationTreeSortingField", str)
	}
	return nil
}

func (e ApplicationTreeSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationTreeSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationTreeSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ArgoCD State
type ArgoCdState string

const (
	// ArgoCD is connected
	ArgoCdStateConnected ArgoCdState = "CONNECTED"
	// ArgoCD is found but not authorized
	ArgoCdStateNotAuthorized ArgoCdState = "NOT_AUTHORIZED"
	// ArgoCD is not found
	ArgoCdStateNotFound ArgoCdState = "NOT_FOUND"
	// UNKNOWN
	ArgoCdStateUnknown ArgoCdState = "UNKNOWN"
)

var AllArgoCdState = []ArgoCdState{
	ArgoCdStateConnected,
	ArgoCdStateNotAuthorized,
	ArgoCdStateNotFound,
	ArgoCdStateUnknown,
}

func (e ArgoCdState) IsValid() bool {
	switch e {
	case ArgoCdStateConnected, ArgoCdStateNotAuthorized, ArgoCdStateNotFound, ArgoCdStateUnknown:
		return true
	}
	return false
}

func (e ArgoCdState) String() string {
	return string(e)
}

func (e *ArgoCdState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArgoCdState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArgoCdState", str)
	}
	return nil
}

func (e ArgoCdState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ArgoCdState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ArgoCdState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Assignment type
type AssignmentType string

const (
	// Linked applications
	AssignmentTypeAnnotation AssignmentType = "ANNOTATION"
	// Manually attached
	AssignmentTypeManually AssignmentType = "MANUALLY"
)

var AllAssignmentType = []AssignmentType{
	AssignmentTypeAnnotation,
	AssignmentTypeManually,
}

func (e AssignmentType) IsValid() bool {
	switch e {
	case AssignmentTypeAnnotation, AssignmentTypeManually:
		return true
	}
	return false
}

func (e AssignmentType) String() string {
	return string(e)
}

func (e *AssignmentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssignmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssignmentType", str)
	}
	return nil
}

func (e AssignmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssignmentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssignmentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ConnectionState contains information about remote resource connection state, currently used for clusters and repositories
type ClusterConnectionStatus string

const (
	// ConnectionStatusFailed indicates that a connection attempt has failed
	ClusterConnectionStatusFailed ClusterConnectionStatus = "Failed"
	// ConnectionStatusSuccessful indicates that a connection has been successfully established
	ClusterConnectionStatusSuccessful ClusterConnectionStatus = "Successful"
	// ConnectionStatusUnknown indicates that the connection status could not be reliably determined
	ClusterConnectionStatusUnknown ClusterConnectionStatus = "Unknown"
)

var AllClusterConnectionStatus = []ClusterConnectionStatus{
	ClusterConnectionStatusFailed,
	ClusterConnectionStatusSuccessful,
	ClusterConnectionStatusUnknown,
}

func (e ClusterConnectionStatus) IsValid() bool {
	switch e {
	case ClusterConnectionStatusFailed, ClusterConnectionStatusSuccessful, ClusterConnectionStatusUnknown:
		return true
	}
	return false
}

func (e ClusterConnectionStatus) String() string {
	return string(e)
}

func (e *ClusterConnectionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterConnectionStatus", str)
	}
	return nil
}

func (e ClusterConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ClusterConnectionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ClusterConnectionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Commit Status
type CommitStatus string

const (
	CommitStatusError   CommitStatus = "error"
	CommitStatusFailure CommitStatus = "failure"
	CommitStatusPending CommitStatus = "pending"
	CommitStatusRunning CommitStatus = "running"
	CommitStatusSuccess CommitStatus = "success"
)

var AllCommitStatus = []CommitStatus{
	CommitStatusError,
	CommitStatusFailure,
	CommitStatusPending,
	CommitStatusRunning,
	CommitStatusSuccess,
}

func (e CommitStatus) IsValid() bool {
	switch e {
	case CommitStatusError, CommitStatusFailure, CommitStatusPending, CommitStatusRunning, CommitStatusSuccess:
		return true
	}
	return false
}

func (e CommitStatus) String() string {
	return string(e)
}

func (e *CommitStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommitStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommitStatus", str)
	}
	return nil
}

func (e CommitStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CommitStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CommitStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Coupon Duration
type CouponDuration string

const (
	CouponDurationForever   CouponDuration = "forever"
	CouponDurationOnce      CouponDuration = "once"
	CouponDurationRepeating CouponDuration = "repeating"
)

var AllCouponDuration = []CouponDuration{
	CouponDurationForever,
	CouponDurationOnce,
	CouponDurationRepeating,
}

func (e CouponDuration) IsValid() bool {
	switch e {
	case CouponDurationForever, CouponDurationOnce, CouponDurationRepeating:
		return true
	}
	return false
}

func (e CouponDuration) String() string {
	return string(e)
}

func (e *CouponDuration) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CouponDuration(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CouponDuration", str)
	}
	return nil
}

func (e CouponDuration) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CouponDuration) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CouponDuration) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Deployment Statistics Status
type DeploymentStatisticsStatus string

const (
	DeploymentStatisticsStatusAll                 DeploymentStatisticsStatus = "ALL"
	DeploymentStatisticsStatusDegraded            DeploymentStatisticsStatus = "DEGRADED"
	DeploymentStatisticsStatusDegradedAndRollback DeploymentStatisticsStatus = "DEGRADED_AND_ROLLBACK"
	DeploymentStatisticsStatusHealthy             DeploymentStatisticsStatus = "HEALTHY"
	DeploymentStatisticsStatusRollback            DeploymentStatisticsStatus = "ROLLBACK"
)

var AllDeploymentStatisticsStatus = []DeploymentStatisticsStatus{
	DeploymentStatisticsStatusAll,
	DeploymentStatisticsStatusDegraded,
	DeploymentStatisticsStatusDegradedAndRollback,
	DeploymentStatisticsStatusHealthy,
	DeploymentStatisticsStatusRollback,
}

func (e DeploymentStatisticsStatus) IsValid() bool {
	switch e {
	case DeploymentStatisticsStatusAll, DeploymentStatisticsStatusDegraded, DeploymentStatisticsStatusDegradedAndRollback, DeploymentStatisticsStatusHealthy, DeploymentStatisticsStatusRollback:
		return true
	}
	return false
}

func (e DeploymentStatisticsStatus) String() string {
	return string(e)
}

func (e *DeploymentStatisticsStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentStatisticsStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentStatisticsStatus", str)
	}
	return nil
}

func (e DeploymentStatisticsStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeploymentStatisticsStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeploymentStatisticsStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Duration Name
type DurationName string

const (
	DurationNameDelayDuration              DurationName = "DELAY_DURATION"
	DurationNameInitializingDuration       DurationName = "INITIALIZING_DURATION"
	DurationNamePendingApprovalDuration    DurationName = "PENDING_APPROVAL_DURATION"
	DurationNamePendingConcurrencyDuration DurationName = "PENDING_CONCURRENCY_DURATION"
	DurationNameRunningDuration            DurationName = "RUNNING_DURATION"
	DurationNameTotalDuration              DurationName = "TOTAL_DURATION"
)

var AllDurationName = []DurationName{
	DurationNameDelayDuration,
	DurationNameInitializingDuration,
	DurationNamePendingApprovalDuration,
	DurationNamePendingConcurrencyDuration,
	DurationNameRunningDuration,
	DurationNameTotalDuration,
}

func (e DurationName) IsValid() bool {
	switch e {
	case DurationNameDelayDuration, DurationNameInitializingDuration, DurationNamePendingApprovalDuration, DurationNamePendingConcurrencyDuration, DurationNameRunningDuration, DurationNameTotalDuration:
		return true
	}
	return false
}

func (e DurationName) String() string {
	return string(e)
}

func (e *DurationName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DurationName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DurationName", str)
	}
	return nil
}

func (e DurationName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DurationName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DurationName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Kind of environment
type EnvironmentKind string

const (
	EnvironmentKindNonProd EnvironmentKind = "NON_PROD"
	EnvironmentKindProd    EnvironmentKind = "PROD"
)

var AllEnvironmentKind = []EnvironmentKind{
	EnvironmentKindNonProd,
	EnvironmentKindProd,
}

func (e EnvironmentKind) IsValid() bool {
	switch e {
	case EnvironmentKindNonProd, EnvironmentKindProd:
		return true
	}
	return false
}

func (e EnvironmentKind) String() string {
	return string(e)
}

func (e *EnvironmentKind) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentKind", str)
	}
	return nil
}

func (e EnvironmentKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EnvironmentKind) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EnvironmentKind) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// "Relative position of the moved environment in relation to the target environment"
type EnvironmentRelativePos string

const (
	EnvironmentRelativePosAfter  EnvironmentRelativePos = "AFTER"
	EnvironmentRelativePosBefore EnvironmentRelativePos = "BEFORE"
)

var AllEnvironmentRelativePos = []EnvironmentRelativePos{
	EnvironmentRelativePosAfter,
	EnvironmentRelativePosBefore,
}

func (e EnvironmentRelativePos) IsValid() bool {
	switch e {
	case EnvironmentRelativePosAfter, EnvironmentRelativePosBefore:
		return true
	}
	return false
}

func (e EnvironmentRelativePos) String() string {
	return string(e)
}

func (e *EnvironmentRelativePos) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentRelativePos(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentRelativePos", str)
	}
	return nil
}

func (e EnvironmentRelativePos) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EnvironmentRelativePos) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EnvironmentRelativePos) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Environment status enum
type EnvironmentStatus string

const (
	EnvironmentStatusFailed      EnvironmentStatus = "FAILED"
	EnvironmentStatusPending     EnvironmentStatus = "PENDING"
	EnvironmentStatusQueued      EnvironmentStatus = "QUEUED"
	EnvironmentStatusRunning     EnvironmentStatus = "RUNNING"
	EnvironmentStatusSkipped     EnvironmentStatus = "SKIPPED"
	EnvironmentStatusSucceeded   EnvironmentStatus = "SUCCEEDED"
	EnvironmentStatusSuspended   EnvironmentStatus = "SUSPENDED"
	EnvironmentStatusTerminated  EnvironmentStatus = "TERMINATED"
	EnvironmentStatusTerminating EnvironmentStatus = "TERMINATING"
)

var AllEnvironmentStatus = []EnvironmentStatus{
	EnvironmentStatusFailed,
	EnvironmentStatusPending,
	EnvironmentStatusQueued,
	EnvironmentStatusRunning,
	EnvironmentStatusSkipped,
	EnvironmentStatusSucceeded,
	EnvironmentStatusSuspended,
	EnvironmentStatusTerminated,
	EnvironmentStatusTerminating,
}

func (e EnvironmentStatus) IsValid() bool {
	switch e {
	case EnvironmentStatusFailed, EnvironmentStatusPending, EnvironmentStatusQueued, EnvironmentStatusRunning, EnvironmentStatusSkipped, EnvironmentStatusSucceeded, EnvironmentStatusSuspended, EnvironmentStatusTerminated, EnvironmentStatusTerminating:
		return true
	}
	return false
}

func (e EnvironmentStatus) String() string {
	return string(e)
}

func (e *EnvironmentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentStatus", str)
	}
	return nil
}

func (e EnvironmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EnvironmentStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EnvironmentStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ErrorLevels) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ErrorLevels) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Extended Workflow Phases
type ExtendedWorkflowPhases string

const (
	ExtendedWorkflowPhasesElected      ExtendedWorkflowPhases = "ELECTED"
	ExtendedWorkflowPhasesError        ExtendedWorkflowPhases = "ERROR"
	ExtendedWorkflowPhasesFailed       ExtendedWorkflowPhases = "FAILED"
	ExtendedWorkflowPhasesInitializing ExtendedWorkflowPhases = "INITIALIZING"
	ExtendedWorkflowPhasesPending      ExtendedWorkflowPhases = "PENDING"
	ExtendedWorkflowPhasesRunning      ExtendedWorkflowPhases = "RUNNING"
	ExtendedWorkflowPhasesSkipped      ExtendedWorkflowPhases = "SKIPPED"
	ExtendedWorkflowPhasesSucceeded    ExtendedWorkflowPhases = "SUCCEEDED"
	ExtendedWorkflowPhasesSuspended    ExtendedWorkflowPhases = "SUSPENDED"
	ExtendedWorkflowPhasesTerminated   ExtendedWorkflowPhases = "TERMINATED"
	ExtendedWorkflowPhasesTerminating  ExtendedWorkflowPhases = "TERMINATING"
)

var AllExtendedWorkflowPhases = []ExtendedWorkflowPhases{
	ExtendedWorkflowPhasesElected,
	ExtendedWorkflowPhasesError,
	ExtendedWorkflowPhasesFailed,
	ExtendedWorkflowPhasesInitializing,
	ExtendedWorkflowPhasesPending,
	ExtendedWorkflowPhasesRunning,
	ExtendedWorkflowPhasesSkipped,
	ExtendedWorkflowPhasesSucceeded,
	ExtendedWorkflowPhasesSuspended,
	ExtendedWorkflowPhasesTerminated,
	ExtendedWorkflowPhasesTerminating,
}

func (e ExtendedWorkflowPhases) IsValid() bool {
	switch e {
	case ExtendedWorkflowPhasesElected, ExtendedWorkflowPhasesError, ExtendedWorkflowPhasesFailed, ExtendedWorkflowPhasesInitializing, ExtendedWorkflowPhasesPending, ExtendedWorkflowPhasesRunning, ExtendedWorkflowPhasesSkipped, ExtendedWorkflowPhasesSucceeded, ExtendedWorkflowPhasesSuspended, ExtendedWorkflowPhasesTerminated, ExtendedWorkflowPhasesTerminating:
		return true
	}
	return false
}

func (e ExtendedWorkflowPhases) String() string {
	return string(e)
}

func (e *ExtendedWorkflowPhases) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtendedWorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtendedWorkflowPhases", str)
	}
	return nil
}

func (e ExtendedWorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExtendedWorkflowPhases) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExtendedWorkflowPhases) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// GitAuthMode
type GitAuthMode string

const (
	// CODEFRESH mode
	GitAuthModeCodefresh GitAuthMode = "CODEFRESH"
	// CUSTOM mode
	GitAuthModeCustom GitAuthMode = "CUSTOM"
	// PAT mode
	GitAuthModePat GitAuthMode = "PAT"
)

var AllGitAuthMode = []GitAuthMode{
	GitAuthModeCodefresh,
	GitAuthModeCustom,
	GitAuthModePat,
}

func (e GitAuthMode) IsValid() bool {
	switch e {
	case GitAuthModeCodefresh, GitAuthModeCustom, GitAuthModePat:
		return true
	}
	return false
}

func (e GitAuthMode) String() string {
	return string(e)
}

func (e *GitAuthMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitAuthMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitAuthMode", str)
	}
	return nil
}

func (e GitAuthMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GitAuthMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GitAuthMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Git providers
type GitProviders string

const (
	// Bitbucket cloud
	GitProvidersBitbucket GitProviders = "BITBUCKET"
	// Bitbucket server
	GitProvidersBitbucketServer GitProviders = "BITBUCKET_SERVER"
	// Gerrit
	GitProvidersGerrit GitProviders = "GERRIT"
	// Github
	GitProvidersGithub GitProviders = "GITHUB"
	// Gitlab
	GitProvidersGitlab GitProviders = "GITLAB"
)

var AllGitProviders = []GitProviders{
	GitProvidersBitbucket,
	GitProvidersBitbucketServer,
	GitProvidersGerrit,
	GitProvidersGithub,
	GitProvidersGitlab,
}

func (e GitProviders) IsValid() bool {
	switch e {
	case GitProvidersBitbucket, GitProvidersBitbucketServer, GitProvidersGerrit, GitProvidersGithub, GitProvidersGitlab:
		return true
	}
	return false
}

func (e GitProviders) String() string {
	return string(e)
}

func (e *GitProviders) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitProviders(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitProviders", str)
	}
	return nil
}

func (e GitProviders) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GitProviders) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GitProviders) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GitPushPayloadDataTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GitPushPayloadDataTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Gitops Releases Sorting field
type GitopsReleasesSortingField string

const (
	// By date
	GitopsReleasesSortingFieldCreatedAt GitopsReleasesSortingField = "createdAt"
	// By health status
	GitopsReleasesSortingFieldHealthStatus GitopsReleasesSortingField = "healthStatus"
	// By history id (for chronological sorting)
	GitopsReleasesSortingFieldHistoryID GitopsReleasesSortingField = "historyId"
	// By sync status
	GitopsReleasesSortingFieldSyncStatus GitopsReleasesSortingField = "syncStatus"
)

var AllGitopsReleasesSortingField = []GitopsReleasesSortingField{
	GitopsReleasesSortingFieldCreatedAt,
	GitopsReleasesSortingFieldHealthStatus,
	GitopsReleasesSortingFieldHistoryID,
	GitopsReleasesSortingFieldSyncStatus,
}

func (e GitopsReleasesSortingField) IsValid() bool {
	switch e {
	case GitopsReleasesSortingFieldCreatedAt, GitopsReleasesSortingFieldHealthStatus, GitopsReleasesSortingFieldHistoryID, GitopsReleasesSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e GitopsReleasesSortingField) String() string {
	return string(e)
}

func (e *GitopsReleasesSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitopsReleasesSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitopsReleasesSortingField", str)
	}
	return nil
}

func (e GitopsReleasesSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GitopsReleasesSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GitopsReleasesSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Runtime Installation error
	HealthErrorCodesRuntimeInstallationError HealthErrorCodes = "RUNTIME_INSTALLATION_ERROR"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesRuntimeInstallationError,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesRuntimeInstallationError, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HealthErrorCodes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HealthErrorCodes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// CUSTOM status, used in case when resource update process was interrupted by new changes
	HealthStatusTerminated HealthStatus = "TERMINATED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusTerminated,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusTerminated, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HealthStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HealthStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImagePullPolicy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImagePullPolicy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Image registry domain types
type ImageRegistryType string

const (
	// Docker hub
	ImageRegistryTypeDockerHub ImageRegistryType = "DOCKER_HUB"
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Ghcr
	ImageRegistryTypeGhcr ImageRegistryType = "GHCR"
	// Jfrog
	ImageRegistryTypeJfrog ImageRegistryType = "JFROG"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
	// Quay
	ImageRegistryTypeQuay ImageRegistryType = "QUAY"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeDockerHub,
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeGhcr,
	ImageRegistryTypeJfrog,
	ImageRegistryTypeOther,
	ImageRegistryTypeQuay,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeDockerHub, ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeGhcr, ImageRegistryTypeJfrog, ImageRegistryTypeOther, ImageRegistryTypeQuay:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageRegistryType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageRegistryType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageRepoTagSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageRepoTagSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageRepositorySortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageRepositorySortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InstallationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InstallationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Installation type
type InstallationType string

const (
	// Helm
	InstallationTypeHelm InstallationType = "HELM"
	// Helm-Hosted
	InstallationTypeHelmHosted InstallationType = "HELM_HOSTED"
)

var AllInstallationType = []InstallationType{
	InstallationTypeHelm,
	InstallationTypeHelmHosted,
}

func (e InstallationType) IsValid() bool {
	switch e {
	case InstallationTypeHelm, InstallationTypeHelmHosted:
		return true
	}
	return false
}

func (e InstallationType) String() string {
	return string(e)
}

func (e *InstallationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationType", str)
	}
	return nil
}

func (e InstallationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InstallationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InstallationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Integration Consumer
type IntegrationConsumer string

const (
	// Jira Write Back
	IntegrationConsumerJiraWriteBack IntegrationConsumer = "JIRA_WRITE_BACK"
)

var AllIntegrationConsumer = []IntegrationConsumer{
	IntegrationConsumerJiraWriteBack,
}

func (e IntegrationConsumer) IsValid() bool {
	switch e {
	case IntegrationConsumerJiraWriteBack:
		return true
	}
	return false
}

func (e IntegrationConsumer) String() string {
	return string(e)
}

func (e *IntegrationConsumer) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationConsumer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationConsumer", str)
	}
	return nil
}

func (e IntegrationConsumer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IntegrationConsumer) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IntegrationConsumer) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// InvoiceStatus
type InvoiceStatus string

const (
	InvoiceStatusDraft         InvoiceStatus = "DRAFT"
	InvoiceStatusOpen          InvoiceStatus = "OPEN"
	InvoiceStatusPaid          InvoiceStatus = "PAID"
	InvoiceStatusUncollectible InvoiceStatus = "UNCOLLECTIBLE"
	InvoiceStatusVoid          InvoiceStatus = "VOID"
)

var AllInvoiceStatus = []InvoiceStatus{
	InvoiceStatusDraft,
	InvoiceStatusOpen,
	InvoiceStatusPaid,
	InvoiceStatusUncollectible,
	InvoiceStatusVoid,
}

func (e InvoiceStatus) IsValid() bool {
	switch e {
	case InvoiceStatusDraft, InvoiceStatusOpen, InvoiceStatusPaid, InvoiceStatusUncollectible, InvoiceStatusVoid:
		return true
	}
	return false
}

func (e InvoiceStatus) String() string {
	return string(e)
}

func (e *InvoiceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InvoiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InvoiceStatus", str)
	}
	return nil
}

func (e InvoiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InvoiceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InvoiceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Issue Type
type IssueType string

const (
	// Issue type is a application
	IssueTypeApplication IssueType = "APPLICATION"
	// Issue type is git
	IssueTypeGit IssueType = "GIT"
	// Issue type is a workflow
	IssueTypeWorkflow IssueType = "WORKFLOW"
)

var AllIssueType = []IssueType{
	IssueTypeApplication,
	IssueTypeGit,
	IssueTypeWorkflow,
}

func (e IssueType) IsValid() bool {
	switch e {
	case IssueTypeApplication, IssueTypeGit, IssueTypeWorkflow:
		return true
	}
	return false
}

func (e IssueType) String() string {
	return string(e)
}

func (e *IssueType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueType", str)
	}
	return nil
}

func (e IssueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IssueType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IssueType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// MatchExpressionOperator
type MatchExpressionOperator string

const (
	// DoesNotExist
	MatchExpressionOperatorDoesNotExist MatchExpressionOperator = "DoesNotExist"
	// Exists
	MatchExpressionOperatorExists MatchExpressionOperator = "Exists"
	// In
	MatchExpressionOperatorIn MatchExpressionOperator = "In"
	// NotIn
	MatchExpressionOperatorNotIn MatchExpressionOperator = "NotIn"
)

var AllMatchExpressionOperator = []MatchExpressionOperator{
	MatchExpressionOperatorDoesNotExist,
	MatchExpressionOperatorExists,
	MatchExpressionOperatorIn,
	MatchExpressionOperatorNotIn,
}

func (e MatchExpressionOperator) IsValid() bool {
	switch e {
	case MatchExpressionOperatorDoesNotExist, MatchExpressionOperatorExists, MatchExpressionOperatorIn, MatchExpressionOperatorNotIn:
		return true
	}
	return false
}

func (e MatchExpressionOperator) String() string {
	return string(e)
}

func (e *MatchExpressionOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchExpressionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchExpressionOperator", str)
	}
	return nil
}

func (e MatchExpressionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MatchExpressionOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MatchExpressionOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Notification action type
type NotificationActionType string

const (
	// Add action
	NotificationActionTypeAdded NotificationActionType = "ADDED"
	// Remove action
	NotificationActionTypeRemoved NotificationActionType = "REMOVED"
	// Update action
	NotificationActionTypeUpdate NotificationActionType = "UPDATE"
)

var AllNotificationActionType = []NotificationActionType{
	NotificationActionTypeAdded,
	NotificationActionTypeRemoved,
	NotificationActionTypeUpdate,
}

func (e NotificationActionType) IsValid() bool {
	switch e {
	case NotificationActionTypeAdded, NotificationActionTypeRemoved, NotificationActionTypeUpdate:
		return true
	}
	return false
}

func (e NotificationActionType) String() string {
	return string(e)
}

func (e *NotificationActionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationActionType", str)
	}
	return nil
}

func (e NotificationActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationActionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationActionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Notification State
type NotificationState string

const (
	// Failed state
	NotificationStateFailed NotificationState = "FAILED"
	// In progress state
	NotificationStateInProgress NotificationState = "IN_PROGRESS"
	// Success state
	NotificationStateSuccess NotificationState = "SUCCESS"
)

var AllNotificationState = []NotificationState{
	NotificationStateFailed,
	NotificationStateInProgress,
	NotificationStateSuccess,
}

func (e NotificationState) IsValid() bool {
	switch e {
	case NotificationStateFailed, NotificationStateInProgress, NotificationStateSuccess:
		return true
	}
	return false
}

func (e NotificationState) String() string {
	return string(e)
}

func (e *NotificationState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationState", str)
	}
	return nil
}

func (e NotificationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Notification Type
type NotificationType string

const (
	// Event that are coming from argo cd
	NotificationTypeArgoCdEvent NotificationType = "ARGO_CD_EVENT"
	// Event that are coming from argo events
	NotificationTypeArgoEventsEvent NotificationType = "ARGO_EVENTS_EVENT"
	// Generic Event
	NotificationTypeGenericEvent NotificationType = "GENERIC_EVENT"
)

var AllNotificationType = []NotificationType{
	NotificationTypeArgoCdEvent,
	NotificationTypeArgoEventsEvent,
	NotificationTypeGenericEvent,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeArgoCdEvent, NotificationTypeArgoEventsEvent, NotificationTypeGenericEvent:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PayloadDataTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PayloadDataTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Payment Intervals
type PaymentInterval string

const (
	PaymentIntervalMonth PaymentInterval = "month"
	PaymentIntervalYear  PaymentInterval = "year"
)

var AllPaymentInterval = []PaymentInterval{
	PaymentIntervalMonth,
	PaymentIntervalYear,
}

func (e PaymentInterval) IsValid() bool {
	switch e {
	case PaymentIntervalMonth, PaymentIntervalYear:
		return true
	}
	return false
}

func (e PaymentInterval) String() string {
	return string(e)
}

func (e *PaymentInterval) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentInterval", str)
	}
	return nil
}

func (e PaymentInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentInterval) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentInterval) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Payment Type
type PaymentType string

const (
	PaymentTypeAchCreditTransfer PaymentType = "ACH_CREDIT_TRANSFER"
	PaymentTypeBankTransfer      PaymentType = "BANK_TRANSFER"
	PaymentTypeCard              PaymentType = "CARD"
	PaymentTypeOther             PaymentType = "OTHER"
	PaymentTypeUnknown           PaymentType = "UNKNOWN"
)

var AllPaymentType = []PaymentType{
	PaymentTypeAchCreditTransfer,
	PaymentTypeBankTransfer,
	PaymentTypeCard,
	PaymentTypeOther,
	PaymentTypeUnknown,
}

func (e PaymentType) IsValid() bool {
	switch e {
	case PaymentTypeAchCreditTransfer, PaymentTypeBankTransfer, PaymentTypeCard, PaymentTypeOther, PaymentTypeUnknown:
		return true
	}
	return false
}

func (e PaymentType) String() string {
	return string(e)
}

func (e *PaymentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentType", str)
	}
	return nil
}

func (e PaymentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Pipeline statistics sort by duration type
type PipelineClassicStatisticDurationMetricType string

const (
	PipelineClassicStatisticDurationMetricTypeAverageDuration PipelineClassicStatisticDurationMetricType = "AVERAGE_DURATION"
	PipelineClassicStatisticDurationMetricTypeP50Duration     PipelineClassicStatisticDurationMetricType = "P50_DURATION"
	PipelineClassicStatisticDurationMetricTypeP90Duration     PipelineClassicStatisticDurationMetricType = "P90_DURATION"
)

var AllPipelineClassicStatisticDurationMetricType = []PipelineClassicStatisticDurationMetricType{
	PipelineClassicStatisticDurationMetricTypeAverageDuration,
	PipelineClassicStatisticDurationMetricTypeP50Duration,
	PipelineClassicStatisticDurationMetricTypeP90Duration,
}

func (e PipelineClassicStatisticDurationMetricType) IsValid() bool {
	switch e {
	case PipelineClassicStatisticDurationMetricTypeAverageDuration, PipelineClassicStatisticDurationMetricTypeP50Duration, PipelineClassicStatisticDurationMetricTypeP90Duration:
		return true
	}
	return false
}

func (e PipelineClassicStatisticDurationMetricType) String() string {
	return string(e)
}

func (e *PipelineClassicStatisticDurationMetricType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineClassicStatisticDurationMetricType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineClassicStatisticDurationMetricType", str)
	}
	return nil
}

func (e PipelineClassicStatisticDurationMetricType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PipelineClassicStatisticDurationMetricType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PipelineClassicStatisticDurationMetricType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// PlanTypes
type PlanTypes string

const (
	PlanTypesClassicPlan PlanTypes = "CLASSIC_PLAN"
	PlanTypesGitopsPlan  PlanTypes = "GITOPS_PLAN"
)

var AllPlanTypes = []PlanTypes{
	PlanTypesClassicPlan,
	PlanTypesGitopsPlan,
}

func (e PlanTypes) IsValid() bool {
	switch e {
	case PlanTypesClassicPlan, PlanTypesGitopsPlan:
		return true
	}
	return false
}

func (e PlanTypes) String() string {
	return string(e)
}

func (e *PlanTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanTypes", str)
	}
	return nil
}

func (e PlanTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PlanTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PlanTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Components Sorting field
type ProductComponentSortingField string

const (
	// By name
	ProductComponentSortingFieldName ProductComponentSortingField = "name"
	// By updated at
	ProductComponentSortingFieldUpdatedAt ProductComponentSortingField = "updatedAt"
)

var AllProductComponentSortingField = []ProductComponentSortingField{
	ProductComponentSortingFieldName,
	ProductComponentSortingFieldUpdatedAt,
}

func (e ProductComponentSortingField) IsValid() bool {
	switch e {
	case ProductComponentSortingFieldName, ProductComponentSortingFieldUpdatedAt:
		return true
	}
	return false
}

func (e ProductComponentSortingField) String() string {
	return string(e)
}

func (e *ProductComponentSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductComponentSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductComponentSortingField", str)
	}
	return nil
}

func (e ProductComponentSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductComponentSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductComponentSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Component types
type ProductComponentType string

const (
	// Argo application
	ProductComponentTypeArgoApplication ProductComponentType = "ARGO_APPLICATION"
	// Helm - not implemented yet
	ProductComponentTypeHelm ProductComponentType = "HELM"
)

var AllProductComponentType = []ProductComponentType{
	ProductComponentTypeArgoApplication,
	ProductComponentTypeHelm,
}

func (e ProductComponentType) IsValid() bool {
	switch e {
	case ProductComponentTypeArgoApplication, ProductComponentTypeHelm:
		return true
	}
	return false
}

func (e ProductComponentType) String() string {
	return string(e)
}

func (e *ProductComponentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductComponentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductComponentType", str)
	}
	return nil
}

func (e ProductComponentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductComponentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductComponentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ProductConcurrency
type ProductConcurrency string

const (
	// Queue
	ProductConcurrencyQueue ProductConcurrency = "queue"
	// Terminate
	ProductConcurrencyTerminate ProductConcurrency = "terminate"
)

var AllProductConcurrency = []ProductConcurrency{
	ProductConcurrencyQueue,
	ProductConcurrencyTerminate,
}

func (e ProductConcurrency) IsValid() bool {
	switch e {
	case ProductConcurrencyQueue, ProductConcurrencyTerminate:
		return true
	}
	return false
}

func (e ProductConcurrency) String() string {
	return string(e)
}

func (e *ProductConcurrency) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductConcurrency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductConcurrency", str)
	}
	return nil
}

func (e ProductConcurrency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductConcurrency) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductConcurrency) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ProductGitTrigger
type ProductGitTrigger string

const (
	// commitMessage
	ProductGitTriggerCommitMessage ProductGitTrigger = "commitMessage"
	// Git revision (branch | tag)
	ProductGitTriggerGitRevision ProductGitTrigger = "gitRevision"
)

var AllProductGitTrigger = []ProductGitTrigger{
	ProductGitTriggerCommitMessage,
	ProductGitTriggerGitRevision,
}

func (e ProductGitTrigger) IsValid() bool {
	switch e {
	case ProductGitTriggerCommitMessage, ProductGitTriggerGitRevision:
		return true
	}
	return false
}

func (e ProductGitTrigger) String() string {
	return string(e)
}

func (e *ProductGitTrigger) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductGitTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductGitTrigger", str)
	}
	return nil
}

func (e ProductGitTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductGitTrigger) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductGitTrigger) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product release error code
type ProductReleaseErrorCode string

const (
	// Creation Failed
	ProductReleaseErrorCodeCreationFailed ProductReleaseErrorCode = "CREATION_FAILED"
	// Promotion flow error
	ProductReleaseErrorCodePromotionFlowError ProductReleaseErrorCode = "PROMOTION_FLOW_ERROR"
	// Release error
	ProductReleaseErrorCodeReleaseError ProductReleaseErrorCode = "RELEASE_ERROR"
	// Release terminated
	ProductReleaseErrorCodeReleaseTerminated ProductReleaseErrorCode = "RELEASE_TERMINATED"
	// Step error
	ProductReleaseErrorCodeStepError ProductReleaseErrorCode = "STEP_ERROR"
	// Step failed
	ProductReleaseErrorCodeStepFailed ProductReleaseErrorCode = "STEP_FAILED"
	// Step terminated
	ProductReleaseErrorCodeStepTerminated ProductReleaseErrorCode = "STEP_TERMINATED"
)

var AllProductReleaseErrorCode = []ProductReleaseErrorCode{
	ProductReleaseErrorCodeCreationFailed,
	ProductReleaseErrorCodePromotionFlowError,
	ProductReleaseErrorCodeReleaseError,
	ProductReleaseErrorCodeReleaseTerminated,
	ProductReleaseErrorCodeStepError,
	ProductReleaseErrorCodeStepFailed,
	ProductReleaseErrorCodeStepTerminated,
}

func (e ProductReleaseErrorCode) IsValid() bool {
	switch e {
	case ProductReleaseErrorCodeCreationFailed, ProductReleaseErrorCodePromotionFlowError, ProductReleaseErrorCodeReleaseError, ProductReleaseErrorCodeReleaseTerminated, ProductReleaseErrorCodeStepError, ProductReleaseErrorCodeStepFailed, ProductReleaseErrorCodeStepTerminated:
		return true
	}
	return false
}

func (e ProductReleaseErrorCode) String() string {
	return string(e)
}

func (e *ProductReleaseErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductReleaseErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductReleaseErrorCode", str)
	}
	return nil
}

func (e ProductReleaseErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductReleaseErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductReleaseErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Release Public Status
type ProductReleasePublicStatus string

const (
	// Release status on release step failed
	ProductReleasePublicStatusFailed ProductReleasePublicStatus = "FAILED"
	// Release is in queue to be started or pending execution
	ProductReleasePublicStatusQueued ProductReleasePublicStatus = "QUEUED"
	// Release status on release step is running
	ProductReleasePublicStatusRunning ProductReleasePublicStatus = "RUNNING"
	// Release status on release step is succeeded
	ProductReleasePublicStatusSucceeded ProductReleasePublicStatus = "SUCCEEDED"
	// Release waiting for PR approval
	ProductReleasePublicStatusSuspended ProductReleasePublicStatus = "SUSPENDED"
	// Release was terminated by user
	ProductReleasePublicStatusTerminated ProductReleasePublicStatus = "TERMINATED"
	// Release was requested to be terminated by user
	ProductReleasePublicStatusTerminating ProductReleasePublicStatus = "TERMINATING"
)

var AllProductReleasePublicStatus = []ProductReleasePublicStatus{
	ProductReleasePublicStatusFailed,
	ProductReleasePublicStatusQueued,
	ProductReleasePublicStatusRunning,
	ProductReleasePublicStatusSucceeded,
	ProductReleasePublicStatusSuspended,
	ProductReleasePublicStatusTerminated,
	ProductReleasePublicStatusTerminating,
}

func (e ProductReleasePublicStatus) IsValid() bool {
	switch e {
	case ProductReleasePublicStatusFailed, ProductReleasePublicStatusQueued, ProductReleasePublicStatusRunning, ProductReleasePublicStatusSucceeded, ProductReleasePublicStatusSuspended, ProductReleasePublicStatusTerminated, ProductReleasePublicStatusTerminating:
		return true
	}
	return false
}

func (e ProductReleasePublicStatus) String() string {
	return string(e)
}

func (e *ProductReleasePublicStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductReleasePublicStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductReleasePublicStatus", str)
	}
	return nil
}

func (e ProductReleasePublicStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductReleasePublicStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductReleasePublicStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Release Status, including internal statuses
type ProductReleaseStatus string

const (
	// Release status on release step failed
	ProductReleaseStatusFailed ProductReleaseStatus = "FAILED"
	// Release had post hook
	ProductReleaseStatusFinalizing ProductReleaseStatus = "FINALIZING"
	// Release was terminated and running final hook
	ProductReleaseStatusFinalizingTermination ProductReleaseStatus = "FINALIZING_TERMINATION"
	// Product release running pre hook
	ProductReleaseStatusInitializing ProductReleaseStatus = "INITIALIZING"
	// Product release waiting to run pre hook
	ProductReleaseStatusPending ProductReleaseStatus = "PENDING"
	// Release is in queue to be started
	ProductReleaseStatusQueued ProductReleaseStatus = "QUEUED"
	// Release status on release step is running
	ProductReleaseStatusRunning ProductReleaseStatus = "RUNNING"
	// Release status on release step is succeeded
	ProductReleaseStatusSucceeded ProductReleaseStatus = "SUCCEEDED"
	// Release waiting for PR approval
	ProductReleaseStatusSuspended ProductReleaseStatus = "SUSPENDED"
	// Release was terminated by user
	ProductReleaseStatusTerminated ProductReleaseStatus = "TERMINATED"
	// Release was requested to be terminated by user
	ProductReleaseStatusTerminating ProductReleaseStatus = "TERMINATING"
)

var AllProductReleaseStatus = []ProductReleaseStatus{
	ProductReleaseStatusFailed,
	ProductReleaseStatusFinalizing,
	ProductReleaseStatusFinalizingTermination,
	ProductReleaseStatusInitializing,
	ProductReleaseStatusPending,
	ProductReleaseStatusQueued,
	ProductReleaseStatusRunning,
	ProductReleaseStatusSucceeded,
	ProductReleaseStatusSuspended,
	ProductReleaseStatusTerminated,
	ProductReleaseStatusTerminating,
}

func (e ProductReleaseStatus) IsValid() bool {
	switch e {
	case ProductReleaseStatusFailed, ProductReleaseStatusFinalizing, ProductReleaseStatusFinalizingTermination, ProductReleaseStatusInitializing, ProductReleaseStatusPending, ProductReleaseStatusQueued, ProductReleaseStatusRunning, ProductReleaseStatusSucceeded, ProductReleaseStatusSuspended, ProductReleaseStatusTerminated, ProductReleaseStatusTerminating:
		return true
	}
	return false
}

func (e ProductReleaseStatus) String() string {
	return string(e)
}

func (e *ProductReleaseStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductReleaseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductReleaseStatus", str)
	}
	return nil
}

func (e ProductReleaseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductReleaseStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductReleaseStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Release step status
type ProductReleaseStepStatus string

const (
	// Product Release step status on release step is failed
	ProductReleaseStepStatusFailed ProductReleaseStepStatus = "FAILED"
	// Product release step running post hook
	ProductReleaseStepStatusFinalizing ProductReleaseStepStatus = "FINALIZING"
	// Product release step terminated and running post hook
	ProductReleaseStepStatusFinalizingTermination ProductReleaseStepStatus = "FINALIZING_TERMINATION"
	// Product release step running pre hook
	ProductReleaseStepStatusInitializing ProductReleaseStepStatus = "INITIALIZING"
	// Product Release step status on release step is pending for previous step to complete
	ProductReleaseStepStatusPending ProductReleaseStepStatus = "PENDING"
	// Product Release step status on release step is running
	ProductReleaseStepStatusRunning ProductReleaseStepStatus = "RUNNING"
	// Product Release step was skipped by termination policy request
	ProductReleaseStepStatusSkipped ProductReleaseStepStatus = "SKIPPED"
	// Product Release step status on release step is succeeded
	ProductReleaseStepStatusSucceeded ProductReleaseStepStatus = "SUCCEEDED"
	// Product Release step status on release step is Suspended
	ProductReleaseStepStatusSuspended ProductReleaseStepStatus = "SUSPENDED"
	// Product Release step was terminated by user
	ProductReleaseStepStatusTerminated ProductReleaseStepStatus = "TERMINATED"
	// Product Release step was requested to be terminated by user
	ProductReleaseStepStatusTerminating ProductReleaseStepStatus = "TERMINATING"
)

var AllProductReleaseStepStatus = []ProductReleaseStepStatus{
	ProductReleaseStepStatusFailed,
	ProductReleaseStepStatusFinalizing,
	ProductReleaseStepStatusFinalizingTermination,
	ProductReleaseStepStatusInitializing,
	ProductReleaseStepStatusPending,
	ProductReleaseStepStatusRunning,
	ProductReleaseStepStatusSkipped,
	ProductReleaseStepStatusSucceeded,
	ProductReleaseStepStatusSuspended,
	ProductReleaseStepStatusTerminated,
	ProductReleaseStepStatusTerminating,
}

func (e ProductReleaseStepStatus) IsValid() bool {
	switch e {
	case ProductReleaseStepStatusFailed, ProductReleaseStepStatusFinalizing, ProductReleaseStepStatusFinalizingTermination, ProductReleaseStepStatusInitializing, ProductReleaseStepStatusPending, ProductReleaseStepStatusRunning, ProductReleaseStepStatusSkipped, ProductReleaseStepStatusSucceeded, ProductReleaseStepStatusSuspended, ProductReleaseStepStatusTerminated, ProductReleaseStepStatusTerminating:
		return true
	}
	return false
}

func (e ProductReleaseStepStatus) String() string {
	return string(e)
}

func (e *ProductReleaseStepStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductReleaseStepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductReleaseStepStatus", str)
	}
	return nil
}

func (e ProductReleaseStepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductReleaseStepStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductReleaseStepStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Release task type
type ProductReleaseTaskType string

const (
	// Create product release task
	ProductReleaseTaskTypeCreateProductReleaseTask ProductReleaseTaskType = "CreateProductReleaseTask"
	// Retry product release task
	ProductReleaseTaskTypeRetryProductReleaseTask ProductReleaseTaskType = "RetryProductReleaseTask"
	// Run hook product release task
	ProductReleaseTaskTypeRunHookProductReleaseTask ProductReleaseTaskType = "RunHookProductReleaseTask"
	// Terminate product release task
	ProductReleaseTaskTypeTerminateProductReleaseTask ProductReleaseTaskType = "TerminateProductReleaseTask"
	// Terminate an argo workflow
	ProductReleaseTaskTypeTerminateWorkflowTask ProductReleaseTaskType = "TerminateWorkflowTask"
)

var AllProductReleaseTaskType = []ProductReleaseTaskType{
	ProductReleaseTaskTypeCreateProductReleaseTask,
	ProductReleaseTaskTypeRetryProductReleaseTask,
	ProductReleaseTaskTypeRunHookProductReleaseTask,
	ProductReleaseTaskTypeTerminateProductReleaseTask,
	ProductReleaseTaskTypeTerminateWorkflowTask,
}

func (e ProductReleaseTaskType) IsValid() bool {
	switch e {
	case ProductReleaseTaskTypeCreateProductReleaseTask, ProductReleaseTaskTypeRetryProductReleaseTask, ProductReleaseTaskTypeRunHookProductReleaseTask, ProductReleaseTaskTypeTerminateProductReleaseTask, ProductReleaseTaskTypeTerminateWorkflowTask:
		return true
	}
	return false
}

func (e ProductReleaseTaskType) String() string {
	return string(e)
}

func (e *ProductReleaseTaskType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductReleaseTaskType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductReleaseTaskType", str)
	}
	return nil
}

func (e ProductReleaseTaskType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductReleaseTaskType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductReleaseTaskType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Sorting field
type ProductSortingField string

const (
	// By id
	ProductSortingFieldID ProductSortingField = "id"
	// By name
	ProductSortingFieldName ProductSortingField = "name"
	// By updated at
	ProductSortingFieldUpdatedAt ProductSortingField = "updatedAt"
)

var AllProductSortingField = []ProductSortingField{
	ProductSortingFieldID,
	ProductSortingFieldName,
	ProductSortingFieldUpdatedAt,
}

func (e ProductSortingField) IsValid() bool {
	switch e {
	case ProductSortingFieldID, ProductSortingFieldName, ProductSortingFieldUpdatedAt:
		return true
	}
	return false
}

func (e ProductSortingField) String() string {
	return string(e)
}

func (e *ProductSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortingField", str)
	}
	return nil
}

func (e ProductSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promote app with commit phase
type PromoteAppWithCommitPhase string

const (
	PromoteAppWithCommitPhasePending    PromoteAppWithCommitPhase = "PENDING"
	PromoteAppWithCommitPhaseCommitDone PromoteAppWithCommitPhase = "COMMIT_DONE"
	PromoteAppWithCommitPhaseSyncing    PromoteAppWithCommitPhase = "SYNCING"
	PromoteAppWithCommitPhaseComplete   PromoteAppWithCommitPhase = "COMPLETE"
)

var AllPromoteAppWithCommitPhase = []PromoteAppWithCommitPhase{
	PromoteAppWithCommitPhasePending,
	PromoteAppWithCommitPhaseCommitDone,
	PromoteAppWithCommitPhaseSyncing,
	PromoteAppWithCommitPhaseComplete,
}

func (e PromoteAppWithCommitPhase) IsValid() bool {
	switch e {
	case PromoteAppWithCommitPhasePending, PromoteAppWithCommitPhaseCommitDone, PromoteAppWithCommitPhaseSyncing, PromoteAppWithCommitPhaseComplete:
		return true
	}
	return false
}

func (e PromoteAppWithCommitPhase) String() string {
	return string(e)
}

func (e *PromoteAppWithCommitPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromoteAppWithCommitPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromoteAppWithCommitPhase", str)
	}
	return nil
}

func (e PromoteAppWithCommitPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromoteAppWithCommitPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromoteAppWithCommitPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promote app with pr phase
type PromoteAppWithPRPhase string

const (
	PromoteAppWithPRPhasePending   PromoteAppWithPRPhase = "PENDING"
	PromoteAppWithPRPhaseSuspended PromoteAppWithPRPhase = "SUSPENDED"
	PromoteAppWithPRPhaseSyncing   PromoteAppWithPRPhase = "SYNCING"
	PromoteAppWithPRPhaseComplete  PromoteAppWithPRPhase = "COMPLETE"
)

var AllPromoteAppWithPRPhase = []PromoteAppWithPRPhase{
	PromoteAppWithPRPhasePending,
	PromoteAppWithPRPhaseSuspended,
	PromoteAppWithPRPhaseSyncing,
	PromoteAppWithPRPhaseComplete,
}

func (e PromoteAppWithPRPhase) IsValid() bool {
	switch e {
	case PromoteAppWithPRPhasePending, PromoteAppWithPRPhaseSuspended, PromoteAppWithPRPhaseSyncing, PromoteAppWithPRPhaseComplete:
		return true
	}
	return false
}

func (e PromoteAppWithPRPhase) String() string {
	return string(e)
}

func (e *PromoteAppWithPRPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromoteAppWithPRPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromoteAppWithPRPhase", str)
	}
	return nil
}

func (e PromoteAppWithPRPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromoteAppWithPRPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromoteAppWithPRPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promotion error code enum
type PromotionErrorCode string

const (
	PromotionErrorCodeUnknown                        PromotionErrorCode = "UNKNOWN"
	PromotionErrorCodeEnvironmentMissingApplications PromotionErrorCode = "ENVIRONMENT_MISSING_APPLICATIONS"
	PromotionErrorCodePromotionTermination           PromotionErrorCode = "PROMOTION_TERMINATION"
)

var AllPromotionErrorCode = []PromotionErrorCode{
	PromotionErrorCodeUnknown,
	PromotionErrorCodeEnvironmentMissingApplications,
	PromotionErrorCodePromotionTermination,
}

func (e PromotionErrorCode) IsValid() bool {
	switch e {
	case PromotionErrorCodeUnknown, PromotionErrorCodeEnvironmentMissingApplications, PromotionErrorCodePromotionTermination:
		return true
	}
	return false
}

func (e PromotionErrorCode) String() string {
	return string(e)
}

func (e *PromotionErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionErrorCode", str)
	}
	return nil
}

func (e PromotionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromotionErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromotionErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promotion policy possible actions
type PromotionPolicyAction string

const (
	// Action type is a commit
	PromotionPolicyActionCommit PromotionPolicyAction = "commit"
	// Action type is none
	PromotionPolicyActionNone PromotionPolicyAction = "none"
	// Action type is a PR
	PromotionPolicyActionPr PromotionPolicyAction = "pr"
)

var AllPromotionPolicyAction = []PromotionPolicyAction{
	PromotionPolicyActionCommit,
	PromotionPolicyActionNone,
	PromotionPolicyActionPr,
}

func (e PromotionPolicyAction) IsValid() bool {
	switch e {
	case PromotionPolicyActionCommit, PromotionPolicyActionNone, PromotionPolicyActionPr:
		return true
	}
	return false
}

func (e PromotionPolicyAction) String() string {
	return string(e)
}

func (e *PromotionPolicyAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionPolicyAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionPolicyAction", str)
	}
	return nil
}

func (e PromotionPolicyAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromotionPolicyAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromotionPolicyAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Policy sorting field
type PromotionPolicySortingField string

const (
	// By creation date
	PromotionPolicySortingFieldCreatedAt PromotionPolicySortingField = "createdAt"
	// By name
	PromotionPolicySortingFieldName PromotionPolicySortingField = "name"
	// By priority
	PromotionPolicySortingFieldPriority PromotionPolicySortingField = "priority"
)

var AllPromotionPolicySortingField = []PromotionPolicySortingField{
	PromotionPolicySortingFieldCreatedAt,
	PromotionPolicySortingFieldName,
	PromotionPolicySortingFieldPriority,
}

func (e PromotionPolicySortingField) IsValid() bool {
	switch e {
	case PromotionPolicySortingFieldCreatedAt, PromotionPolicySortingFieldName, PromotionPolicySortingFieldPriority:
		return true
	}
	return false
}

func (e PromotionPolicySortingField) String() string {
	return string(e)
}

func (e *PromotionPolicySortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionPolicySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionPolicySortingField", str)
	}
	return nil
}

func (e PromotionPolicySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromotionPolicySortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromotionPolicySortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promotion triggers enum
type PromotionTriggers string

const (
	PromotionTriggersRestart     PromotionTriggers = "RESTART"
	PromotionTriggersGitCommit   PromotionTriggers = "GIT_COMMIT"
	PromotionTriggersDragAndDrop PromotionTriggers = "DRAG_AND_DROP"
	PromotionTriggersManual      PromotionTriggers = "MANUAL"
)

var AllPromotionTriggers = []PromotionTriggers{
	PromotionTriggersRestart,
	PromotionTriggersGitCommit,
	PromotionTriggersDragAndDrop,
	PromotionTriggersManual,
}

func (e PromotionTriggers) IsValid() bool {
	switch e {
	case PromotionTriggersRestart, PromotionTriggersGitCommit, PromotionTriggersDragAndDrop, PromotionTriggersManual:
		return true
	}
	return false
}

func (e PromotionTriggers) String() string {
	return string(e)
}

func (e *PromotionTriggers) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionTriggers(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionTriggers", str)
	}
	return nil
}

func (e PromotionTriggers) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromotionTriggers) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromotionTriggers) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promotion status enum
type PromotionsStatus string

const (
	PromotionsStatusFailed      PromotionsStatus = "FAILED"
	PromotionsStatusQueued      PromotionsStatus = "QUEUED"
	PromotionsStatusRunning     PromotionsStatus = "RUNNING"
	PromotionsStatusSucceeded   PromotionsStatus = "SUCCEEDED"
	PromotionsStatusSuspended   PromotionsStatus = "SUSPENDED"
	PromotionsStatusTerminated  PromotionsStatus = "TERMINATED"
	PromotionsStatusTerminating PromotionsStatus = "TERMINATING"
)

var AllPromotionsStatus = []PromotionsStatus{
	PromotionsStatusFailed,
	PromotionsStatusQueued,
	PromotionsStatusRunning,
	PromotionsStatusSucceeded,
	PromotionsStatusSuspended,
	PromotionsStatusTerminated,
	PromotionsStatusTerminating,
}

func (e PromotionsStatus) IsValid() bool {
	switch e {
	case PromotionsStatusFailed, PromotionsStatusQueued, PromotionsStatusRunning, PromotionsStatusSucceeded, PromotionsStatusSuspended, PromotionsStatusTerminated, PromotionsStatusTerminating:
		return true
	}
	return false
}

func (e PromotionsStatus) String() string {
	return string(e)
}

func (e *PromotionsStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionsStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionsStatus", str)
	}
	return nil
}

func (e PromotionsStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromotionsStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromotionsStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Promotion triggers enum
type PromotionsTriggers string

const (
	PromotionsTriggersRestart     PromotionsTriggers = "RESTART"
	PromotionsTriggersGitCommit   PromotionsTriggers = "GIT_COMMIT"
	PromotionsTriggersDragAndDrop PromotionsTriggers = "DRAG_AND_DROP"
	PromotionsTriggersManual      PromotionsTriggers = "MANUAL"
)

var AllPromotionsTriggers = []PromotionsTriggers{
	PromotionsTriggersRestart,
	PromotionsTriggersGitCommit,
	PromotionsTriggersDragAndDrop,
	PromotionsTriggersManual,
}

func (e PromotionsTriggers) IsValid() bool {
	switch e {
	case PromotionsTriggersRestart, PromotionsTriggersGitCommit, PromotionsTriggersDragAndDrop, PromotionsTriggersManual:
		return true
	}
	return false
}

func (e PromotionsTriggers) String() string {
	return string(e)
}

func (e *PromotionsTriggers) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionsTriggers(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionsTriggers", str)
	}
	return nil
}

func (e PromotionsTriggers) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PromotionsTriggers) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PromotionsTriggers) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Pull request state
type PullRequestState string

const (
	// Closed
	PullRequestStateClosed PullRequestState = "CLOSED"
	// Open
	PullRequestStateOpen PullRequestState = "OPEN"
)

var AllPullRequestState = []PullRequestState{
	PullRequestStateClosed,
	PullRequestStateOpen,
}

func (e PullRequestState) IsValid() bool {
	switch e {
	case PullRequestStateClosed, PullRequestStateOpen:
		return true
	}
	return false
}

func (e PullRequestState) String() string {
	return string(e)
}

func (e *PullRequestState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestState", str)
	}
	return nil
}

func (e PullRequestState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PullRequestState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PullRequestState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Release channel type
type ReleaseChannel string

const (
	ReleaseChannelLatest ReleaseChannel = "latest"
	ReleaseChannelStable ReleaseChannel = "stable"
)

var AllReleaseChannel = []ReleaseChannel{
	ReleaseChannelLatest,
	ReleaseChannelStable,
}

func (e ReleaseChannel) IsValid() bool {
	switch e {
	case ReleaseChannelLatest, ReleaseChannelStable:
		return true
	}
	return false
}

func (e ReleaseChannel) String() string {
	return string(e)
}

func (e *ReleaseChannel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReleaseChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReleaseChannel", str)
	}
	return nil
}

func (e ReleaseChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ReleaseChannel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ReleaseChannel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Release Rollout Disabled Reasons
type ReleaseRolloutDisabledReasons string

const (
	// Happens only when new commit occured (non-image change) while Rollout was progressing
	ReleaseRolloutDisabledReasonsRestartedDueNewCommit ReleaseRolloutDisabledReasons = "RESTARTED_DUE_NEW_COMMIT"
)

var AllReleaseRolloutDisabledReasons = []ReleaseRolloutDisabledReasons{
	ReleaseRolloutDisabledReasonsRestartedDueNewCommit,
}

func (e ReleaseRolloutDisabledReasons) IsValid() bool {
	switch e {
	case ReleaseRolloutDisabledReasonsRestartedDueNewCommit:
		return true
	}
	return false
}

func (e ReleaseRolloutDisabledReasons) String() string {
	return string(e)
}

func (e *ReleaseRolloutDisabledReasons) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReleaseRolloutDisabledReasons(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReleaseRolloutDisabledReasons", str)
	}
	return nil
}

func (e ReleaseRolloutDisabledReasons) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ReleaseRolloutDisabledReasons) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ReleaseRolloutDisabledReasons) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ResourceOperation
type ResourceOperation string

const (
	// Create resources
	ResourceOperationCreate ResourceOperation = "CREATE"
	// Delete resources
	ResourceOperationDelete ResourceOperation = "DELETE"
	// Update resources
	ResourceOperationUpdate ResourceOperation = "UPDATE"
)

var AllResourceOperation = []ResourceOperation{
	ResourceOperationCreate,
	ResourceOperationDelete,
	ResourceOperationUpdate,
}

func (e ResourceOperation) IsValid() bool {
	switch e {
	case ResourceOperationCreate, ResourceOperationDelete, ResourceOperationUpdate:
		return true
	}
	return false
}

func (e ResourceOperation) String() string {
	return string(e)
}

func (e *ResourceOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceOperation", str)
	}
	return nil
}

func (e ResourceOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceOperation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceOperation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Rollout Phases
type RolloutPhases string

const (
	// Degraded
	RolloutPhasesDegraded RolloutPhases = "Degraded"
	// Healthy
	RolloutPhasesHealthy RolloutPhases = "Healthy"
	// Paused
	RolloutPhasesPaused RolloutPhases = "Paused"
	// Progressing
	RolloutPhasesProgressing RolloutPhases = "Progressing"
	// Terminated
	RolloutPhasesTerminated RolloutPhases = "Terminated"
	// Unknown
	RolloutPhasesUnknown RolloutPhases = "Unknown"
)

var AllRolloutPhases = []RolloutPhases{
	RolloutPhasesDegraded,
	RolloutPhasesHealthy,
	RolloutPhasesPaused,
	RolloutPhasesProgressing,
	RolloutPhasesTerminated,
	RolloutPhasesUnknown,
}

func (e RolloutPhases) IsValid() bool {
	switch e {
	case RolloutPhasesDegraded, RolloutPhasesHealthy, RolloutPhasesPaused, RolloutPhasesProgressing, RolloutPhasesTerminated, RolloutPhasesUnknown:
		return true
	}
	return false
}

func (e RolloutPhases) String() string {
	return string(e)
}

func (e *RolloutPhases) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutPhases", str)
	}
	return nil
}

func (e RolloutPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RolloutPhases) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RolloutPhases) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Rollout Step Status
type RolloutStepStatus string

const (
	// ACTIVE
	RolloutStepStatusActive RolloutStepStatus = "ACTIVE"
	// FAILED
	RolloutStepStatusFailed RolloutStepStatus = "FAILED"
	// PASSED
	RolloutStepStatusPassed RolloutStepStatus = "PASSED"
	// PAUSED INCONCLUSIVE
	RolloutStepStatusPausedInconclusive RolloutStepStatus = "PAUSED_INCONCLUSIVE"
	// PAUSED INDEFINITE
	RolloutStepStatusPausedIndefinite RolloutStepStatus = "PAUSED_INDEFINITE"
	// PENDING
	RolloutStepStatusPending RolloutStepStatus = "PENDING"
	// TERMINATED
	RolloutStepStatusTerminated RolloutStepStatus = "TERMINATED"
)

var AllRolloutStepStatus = []RolloutStepStatus{
	RolloutStepStatusActive,
	RolloutStepStatusFailed,
	RolloutStepStatusPassed,
	RolloutStepStatusPausedInconclusive,
	RolloutStepStatusPausedIndefinite,
	RolloutStepStatusPending,
	RolloutStepStatusTerminated,
}

func (e RolloutStepStatus) IsValid() bool {
	switch e {
	case RolloutStepStatusActive, RolloutStepStatusFailed, RolloutStepStatusPassed, RolloutStepStatusPausedInconclusive, RolloutStepStatusPausedIndefinite, RolloutStepStatusPending, RolloutStepStatusTerminated:
		return true
	}
	return false
}

func (e RolloutStepStatus) String() string {
	return string(e)
}

func (e *RolloutStepStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStepStatus", str)
	}
	return nil
}

func (e RolloutStepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RolloutStepStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RolloutStepStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Rollout Strategy Names
type RolloutStrategyNames string

const (
	// BlueGreen
	RolloutStrategyNamesBlueGreen RolloutStrategyNames = "blueGreen"
	// Canary
	RolloutStrategyNamesCanary RolloutStrategyNames = "canary"
)

var AllRolloutStrategyNames = []RolloutStrategyNames{
	RolloutStrategyNamesBlueGreen,
	RolloutStrategyNamesCanary,
}

func (e RolloutStrategyNames) IsValid() bool {
	switch e {
	case RolloutStrategyNamesBlueGreen, RolloutStrategyNamesCanary:
		return true
	}
	return false
}

func (e RolloutStrategyNames) String() string {
	return string(e)
}

func (e *RolloutStrategyNames) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStrategyNames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStrategyNames", str)
	}
	return nil
}

func (e RolloutStrategyNames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RolloutStrategyNames) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RolloutStrategyNames) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// RuntimeOperationAction
type RuntimeOperationAction string

const (
	// Delete resources from runtime
	RuntimeOperationActionDelete RuntimeOperationAction = "DELETE"
	// Upsert resources to runtime
	RuntimeOperationActionUpsert RuntimeOperationAction = "UPSERT"
)

var AllRuntimeOperationAction = []RuntimeOperationAction{
	RuntimeOperationActionDelete,
	RuntimeOperationActionUpsert,
}

func (e RuntimeOperationAction) IsValid() bool {
	switch e {
	case RuntimeOperationActionDelete, RuntimeOperationActionUpsert:
		return true
	}
	return false
}

func (e RuntimeOperationAction) String() string {
	return string(e)
}

func (e *RuntimeOperationAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeOperationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeOperationAction", str)
	}
	return nil
}

func (e RuntimeOperationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RuntimeOperationAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RuntimeOperationAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Runtime Sync Mode
type RuntimeSyncMode string

const (
	// GITOPS
	RuntimeSyncModeGitops RuntimeSyncMode = "GITOPS"
	// HELM
	RuntimeSyncModeHelm RuntimeSyncMode = "HELM"
	// UNKNOWN
	RuntimeSyncModeUnknown RuntimeSyncMode = "UNKNOWN"
)

var AllRuntimeSyncMode = []RuntimeSyncMode{
	RuntimeSyncModeGitops,
	RuntimeSyncModeHelm,
	RuntimeSyncModeUnknown,
}

func (e RuntimeSyncMode) IsValid() bool {
	switch e {
	case RuntimeSyncModeGitops, RuntimeSyncModeHelm, RuntimeSyncModeUnknown:
		return true
	}
	return false
}

func (e RuntimeSyncMode) String() string {
	return string(e)
}

func (e *RuntimeSyncMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeSyncMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeSyncMode", str)
	}
	return nil
}

func (e RuntimeSyncMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RuntimeSyncMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RuntimeSyncMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Integration Entity Type
type SecretType string

const (
	// External Secret
	SecretTypeExternalSecret SecretType = "EXTERNAL_SECRET"
	// Sealed Secret
	SecretTypeSealedSecret SecretType = "SEALED_SECRET"
)

var AllSecretType = []SecretType{
	SecretTypeExternalSecret,
	SecretTypeSealedSecret,
}

func (e SecretType) IsValid() bool {
	switch e {
	case SecretTypeExternalSecret, SecretTypeSealedSecret:
		return true
	}
	return false
}

func (e SecretType) String() string {
	return string(e)
}

func (e *SecretType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecretType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecretType", str)
	}
	return nil
}

func (e SecretType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SecretType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SecretType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Service Sorting field
type ServiceSortingField string

const (
	// Last Update
	ServiceSortingFieldLastUpdate ServiceSortingField = "lastUpdate"
	// Service Name
	ServiceSortingFieldServiceName ServiceSortingField = "serviceName"
)

var AllServiceSortingField = []ServiceSortingField{
	ServiceSortingFieldLastUpdate,
	ServiceSortingFieldServiceName,
}

func (e ServiceSortingField) IsValid() bool {
	switch e {
	case ServiceSortingFieldLastUpdate, ServiceSortingFieldServiceName:
		return true
	}
	return false
}

func (e ServiceSortingField) String() string {
	return string(e)
}

func (e *ServiceSortingField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceSortingField", str)
	}
	return nil
}

func (e ServiceSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ServiceSortingField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ServiceSortingField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ServiceType
type ServiceType string

const (
	ServiceTypeClusterIP    ServiceType = "ClusterIP"
	ServiceTypeExternalName ServiceType = "ExternalName"
	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
	ServiceTypeNodePort     ServiceType = "NodePort"
)

var AllServiceType = []ServiceType{
	ServiceTypeClusterIP,
	ServiceTypeExternalName,
	ServiceTypeLoadBalancer,
	ServiceTypeNodePort,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeClusterIP, ServiceTypeExternalName, ServiceTypeLoadBalancer, ServiceTypeNodePort:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ServiceType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ServiceType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sorting order
type SortingOrder string

const (
	// ascending
	SortingOrderAsc SortingOrder = "asc"
	// descending
	SortingOrderDesc SortingOrder = "desc"
)

var AllSortingOrder = []SortingOrder{
	SortingOrderAsc,
	SortingOrderDesc,
}

func (e SortingOrder) IsValid() bool {
	switch e {
	case SortingOrderAsc, SortingOrderDesc:
		return true
	}
	return false
}

func (e SortingOrder) String() string {
	return string(e)
}

func (e *SortingOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingOrder", str)
	}
	return nil
}

func (e SortingOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortingOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortingOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Support Plan
type SupportPlan string

const (
	SupportPlanFree     SupportPlan = "FREE"
	SupportPlanGold     SupportPlan = "GOLD"
	SupportPlanPlatinum SupportPlan = "PLATINUM"
	SupportPlanSilver   SupportPlan = "SILVER"
)

var AllSupportPlan = []SupportPlan{
	SupportPlanFree,
	SupportPlanGold,
	SupportPlanPlatinum,
	SupportPlanSilver,
}

func (e SupportPlan) IsValid() bool {
	switch e {
	case SupportPlanFree, SupportPlanGold, SupportPlanPlatinum, SupportPlanSilver:
		return true
	}
	return false
}

func (e SupportPlan) String() string {
	return string(e)
}

func (e *SupportPlan) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SupportPlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SupportPlan", str)
	}
	return nil
}

func (e SupportPlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SupportPlan) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SupportPlan) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Supported CI Tools
type SupportedCITools string

const (
	// CLASSIC
	SupportedCIToolsClassic SupportedCITools = "classic"
	// GITHUB_ACTIONS
	SupportedCIToolsGithubActions SupportedCITools = "github_actions"
	// JENKINS
	SupportedCIToolsJenkins SupportedCITools = "jenkins"
)

var AllSupportedCITools = []SupportedCITools{
	SupportedCIToolsClassic,
	SupportedCIToolsGithubActions,
	SupportedCIToolsJenkins,
}

func (e SupportedCITools) IsValid() bool {
	switch e {
	case SupportedCIToolsClassic, SupportedCIToolsGithubActions, SupportedCIToolsJenkins:
		return true
	}
	return false
}

func (e SupportedCITools) String() string {
	return string(e)
}

func (e *SupportedCITools) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SupportedCITools(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SupportedCITools", str)
	}
	return nil
}

func (e SupportedCITools) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SupportedCITools) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SupportedCITools) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SyncResourceAction
type SyncActionOnResource string

const (
	// Configured / updated
	SyncActionOnResourceConfigured SyncActionOnResource = "Configured"
	// Created
	SyncActionOnResourceCreated SyncActionOnResource = "Created"
	// Pruned
	SyncActionOnResourcePruned SyncActionOnResource = "Pruned"
	// Prune Skipped
	SyncActionOnResourcePruneSkipped SyncActionOnResource = "PruneSkipped"
	// Sync Failed
	SyncActionOnResourceSyncFailed SyncActionOnResource = "SyncFailed"
	// Unchanged
	SyncActionOnResourceUnchanged SyncActionOnResource = "Unchanged"
	// Unknown
	SyncActionOnResourceUnknown SyncActionOnResource = "Unknown"
)

var AllSyncActionOnResource = []SyncActionOnResource{
	SyncActionOnResourceConfigured,
	SyncActionOnResourceCreated,
	SyncActionOnResourcePruned,
	SyncActionOnResourcePruneSkipped,
	SyncActionOnResourceSyncFailed,
	SyncActionOnResourceUnchanged,
	SyncActionOnResourceUnknown,
}

func (e SyncActionOnResource) IsValid() bool {
	switch e {
	case SyncActionOnResourceConfigured, SyncActionOnResourceCreated, SyncActionOnResourcePruned, SyncActionOnResourcePruneSkipped, SyncActionOnResourceSyncFailed, SyncActionOnResourceUnchanged, SyncActionOnResourceUnknown:
		return true
	}
	return false
}

func (e SyncActionOnResource) String() string {
	return string(e)
}

func (e *SyncActionOnResource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncActionOnResource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncActionOnResource", str)
	}
	return nil
}

func (e SyncActionOnResource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncActionOnResource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncActionOnResource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Sync error for cases when sync operation lasts more than X minutes
	SyncErrorCodesLongSync SyncErrorCodes = "LONG_SYNC"
	// Sync in impossible due to missing rollouts components
	SyncErrorCodesMissingRolloutsComponent SyncErrorCodes = "MISSING_ROLLOUTS_COMPONENT"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesLongSync,
	SyncErrorCodesMissingRolloutsComponent,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesLongSync, SyncErrorCodesMissingRolloutsComponent, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncErrorCodes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncErrorCodes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SyncHookType
type SyncHookType string

const (
	// PostSync
	SyncHookTypePostSync SyncHookType = "PostSync"
	// PreSync
	SyncHookTypePreSync SyncHookType = "PreSync"
	// Skip
	SyncHookTypeSkip SyncHookType = "Skip"
	// Sync
	SyncHookTypeSync SyncHookType = "Sync"
	// SyncFail
	SyncHookTypeSyncFail SyncHookType = "SyncFail"
)

var AllSyncHookType = []SyncHookType{
	SyncHookTypePostSync,
	SyncHookTypePreSync,
	SyncHookTypeSkip,
	SyncHookTypeSync,
	SyncHookTypeSyncFail,
}

func (e SyncHookType) IsValid() bool {
	switch e {
	case SyncHookTypePostSync, SyncHookTypePreSync, SyncHookTypeSkip, SyncHookTypeSync, SyncHookTypeSyncFail:
		return true
	}
	return false
}

func (e SyncHookType) String() string {
	return string(e)
}

func (e *SyncHookType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncHookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncHookType", str)
	}
	return nil
}

func (e SyncHookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncHookType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncHookType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SyncOperationPhase
type SyncOperationPhase string

const (
	// Error
	SyncOperationPhaseError SyncOperationPhase = "Error"
	// Failed
	SyncOperationPhaseFailed SyncOperationPhase = "Failed"
	// Running
	SyncOperationPhaseRunning SyncOperationPhase = "Running"
	// Succeeded
	SyncOperationPhaseSucceeded SyncOperationPhase = "Succeeded"
	// Terminating
	SyncOperationPhaseTerminating SyncOperationPhase = "Terminating"
	// Unknown
	SyncOperationPhaseUnknown SyncOperationPhase = "Unknown"
)

var AllSyncOperationPhase = []SyncOperationPhase{
	SyncOperationPhaseError,
	SyncOperationPhaseFailed,
	SyncOperationPhaseRunning,
	SyncOperationPhaseSucceeded,
	SyncOperationPhaseTerminating,
	SyncOperationPhaseUnknown,
}

func (e SyncOperationPhase) IsValid() bool {
	switch e {
	case SyncOperationPhaseError, SyncOperationPhaseFailed, SyncOperationPhaseRunning, SyncOperationPhaseSucceeded, SyncOperationPhaseTerminating, SyncOperationPhaseUnknown:
		return true
	}
	return false
}

func (e SyncOperationPhase) String() string {
	return string(e)
}

func (e *SyncOperationPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncOperationPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncOperationPhase", str)
	}
	return nil
}

func (e SyncOperationPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncOperationPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncOperationPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SyncPhase
type SyncPhase string

const (
	// PostSync
	SyncPhasePostSync SyncPhase = "PostSync"
	// PreSync
	SyncPhasePreSync SyncPhase = "PreSync"
	// Sync
	SyncPhaseSync SyncPhase = "Sync"
	// SyncFail
	SyncPhaseSyncFail SyncPhase = "SyncFail"
)

var AllSyncPhase = []SyncPhase{
	SyncPhasePostSync,
	SyncPhasePreSync,
	SyncPhaseSync,
	SyncPhaseSyncFail,
}

func (e SyncPhase) IsValid() bool {
	switch e {
	case SyncPhasePostSync, SyncPhasePreSync, SyncPhaseSync, SyncPhaseSyncFail:
		return true
	}
	return false
}

func (e SyncPhase) String() string {
	return string(e)
}

func (e *SyncPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncPhase", str)
	}
	return nil
}

func (e SyncPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SyncResultCode
type SyncResultCode string

const (
	// Pruned
	SyncResultCodePruned SyncResultCode = "Pruned"
	// PruneSkipped
	SyncResultCodePruneSkipped SyncResultCode = "PruneSkipped"
	// Synced
	SyncResultCodeSynced SyncResultCode = "Synced"
	// SyncFailed
	SyncResultCodeSyncFailed SyncResultCode = "SyncFailed"
	// Unknown
	SyncResultCodeUnknown SyncResultCode = "Unknown"
)

var AllSyncResultCode = []SyncResultCode{
	SyncResultCodePruned,
	SyncResultCodePruneSkipped,
	SyncResultCodeSynced,
	SyncResultCodeSyncFailed,
	SyncResultCodeUnknown,
}

func (e SyncResultCode) IsValid() bool {
	switch e {
	case SyncResultCodePruned, SyncResultCodePruneSkipped, SyncResultCodeSynced, SyncResultCodeSyncFailed, SyncResultCodeUnknown:
		return true
	}
	return false
}

func (e SyncResultCode) String() string {
	return string(e)
}

func (e *SyncResultCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncResultCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncResultCode", str)
	}
	return nil
}

func (e SyncResultCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncResultCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncResultCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SyncStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SyncStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of system type
type SystemType string

const (
	SystemTypeClassic          SystemType = "CLASSIC"
	SystemTypeGitops           SystemType = "GITOPS"
	SystemTypeGitopsAndClassic SystemType = "GITOPS_AND_CLASSIC"
	SystemTypeProjectOne       SystemType = "PROJECT_ONE"
)

var AllSystemType = []SystemType{
	SystemTypeClassic,
	SystemTypeGitops,
	SystemTypeGitopsAndClassic,
	SystemTypeProjectOne,
}

func (e SystemType) IsValid() bool {
	switch e {
	case SystemTypeClassic, SystemTypeGitops, SystemTypeGitopsAndClassic, SystemTypeProjectOne:
		return true
	}
	return false
}

func (e SystemType) String() string {
	return string(e)
}

func (e *SystemType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemType", str)
	}
	return nil
}

func (e SystemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SystemType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SystemType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Team sources
type TeamSource string

const (
	// auth0
	TeamSourceAuth0 TeamSource = "AUTH0"
	// azure
	TeamSourceAzure TeamSource = "AZURE"
	// github
	TeamSourceGithub TeamSource = "GITHUB"
	// google
	TeamSourceGoogle TeamSource = "GOOGLE"
	// keycloak
	TeamSourceKeycloak TeamSource = "KEYCLOAK"
	// ldap
	TeamSourceLdap TeamSource = "LDAP"
	// okta
	TeamSourceOkta TeamSource = "OKTA"
	// onelogin
	TeamSourceOnelogin TeamSource = "ONELOGIN"
)

var AllTeamSource = []TeamSource{
	TeamSourceAuth0,
	TeamSourceAzure,
	TeamSourceGithub,
	TeamSourceGoogle,
	TeamSourceKeycloak,
	TeamSourceLdap,
	TeamSourceOkta,
	TeamSourceOnelogin,
}

func (e TeamSource) IsValid() bool {
	switch e {
	case TeamSourceAuth0, TeamSourceAzure, TeamSourceGithub, TeamSourceGoogle, TeamSourceKeycloak, TeamSourceLdap, TeamSourceOkta, TeamSourceOnelogin:
		return true
	}
	return false
}

func (e TeamSource) String() string {
	return string(e)
}

func (e *TeamSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamSource", str)
	}
	return nil
}

func (e TeamSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TeamSource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TeamSource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of team
type TeamType string

const (
	// admin
	TeamTypeAdmin TeamType = "ADMIN"
	// default
	TeamTypeDefault TeamType = "DEFAULT"
	// default-sa
	TeamTypeDefaultSa TeamType = "DEFAULT_SA"
)

var AllTeamType = []TeamType{
	TeamTypeAdmin,
	TeamTypeDefault,
	TeamTypeDefaultSa,
}

func (e TeamType) IsValid() bool {
	switch e {
	case TeamTypeAdmin, TeamTypeDefault, TeamTypeDefaultSa:
		return true
	}
	return false
}

func (e TeamType) String() string {
	return string(e)
}

func (e *TeamType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamType", str)
	}
	return nil
}

func (e TeamType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TeamType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TeamType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Product Release termination strategy
type TerminationStrategy string

const (
	// force termination - stop all running pre/post action and wrapper workflows (default)
	TerminationStrategyForce TerminationStrategy = "FORCE"
	// graceful termination - finish the current step
	TerminationStrategyGraceful TerminationStrategy = "GRACEFUL"
)

var AllTerminationStrategy = []TerminationStrategy{
	TerminationStrategyForce,
	TerminationStrategyGraceful,
}

func (e TerminationStrategy) IsValid() bool {
	switch e {
	case TerminationStrategyForce, TerminationStrategyGraceful:
		return true
	}
	return false
}

func (e TerminationStrategy) String() string {
	return string(e)
}

func (e *TerminationStrategy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminationStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TerminationStrategy", str)
	}
	return nil
}

func (e TerminationStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TerminationStrategy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TerminationStrategy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Verify app status phase
type VerifyAppStatusPhase string

const (
	VerifyAppStatusPhasePending  VerifyAppStatusPhase = "PENDING"
	VerifyAppStatusPhaseSyncing  VerifyAppStatusPhase = "SYNCING"
	VerifyAppStatusPhaseComplete VerifyAppStatusPhase = "COMPLETE"
)

var AllVerifyAppStatusPhase = []VerifyAppStatusPhase{
	VerifyAppStatusPhasePending,
	VerifyAppStatusPhaseSyncing,
	VerifyAppStatusPhaseComplete,
}

func (e VerifyAppStatusPhase) IsValid() bool {
	switch e {
	case VerifyAppStatusPhasePending, VerifyAppStatusPhaseSyncing, VerifyAppStatusPhaseComplete:
		return true
	}
	return false
}

func (e VerifyAppStatusPhase) String() string {
	return string(e)
}

func (e *VerifyAppStatusPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerifyAppStatusPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerifyAppStatusPhase", str)
	}
	return nil
}

func (e VerifyAppStatusPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VerifyAppStatusPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VerifyAppStatusPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowNodePhases) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowNodePhases) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Name of the flows that can be the workflow origins
type WorkflowOrigins string

const (
	// workflow was created as a result of image reporting/enrichment by unknown source
	WorkflowOriginsCiEnrichment WorkflowOrigins = "CI_ENRICHMENT"
	// workflow was created as a result of image reporting/enrichment by github-action plugin
	WorkflowOriginsCiEnrichmentCodefreshClassic WorkflowOrigins = "CI_ENRICHMENT_CODEFRESH_CLASSIC"
	// workflow was created as a result of image reporting/enrichment by github-action plugin
	WorkflowOriginsCiEnrichmentGa WorkflowOrigins = "CI_ENRICHMENT_GA"
	// workflow was created as a result of image reporting/enrichment by jenkins plugin
	WorkflowOriginsCiEnrichmentJenkins WorkflowOrigins = "CI_ENRICHMENT_JENKINS"
	// workflow without specific origin, regular pipeline workflow
	WorkflowOriginsCommon WorkflowOrigins = "COMMON"
	// workflow was create as a result of running the workflow template
	WorkflowOriginsPlayground WorkflowOrigins = "PLAYGROUND"
)

var AllWorkflowOrigins = []WorkflowOrigins{
	WorkflowOriginsCiEnrichment,
	WorkflowOriginsCiEnrichmentCodefreshClassic,
	WorkflowOriginsCiEnrichmentGa,
	WorkflowOriginsCiEnrichmentJenkins,
	WorkflowOriginsCommon,
	WorkflowOriginsPlayground,
}

func (e WorkflowOrigins) IsValid() bool {
	switch e {
	case WorkflowOriginsCiEnrichment, WorkflowOriginsCiEnrichmentCodefreshClassic, WorkflowOriginsCiEnrichmentGa, WorkflowOriginsCiEnrichmentJenkins, WorkflowOriginsCommon, WorkflowOriginsPlayground:
		return true
	}
	return false
}

func (e WorkflowOrigins) String() string {
	return string(e)
}

func (e *WorkflowOrigins) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowOrigins(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowOrigins", str)
	}
	return nil
}

func (e WorkflowOrigins) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowOrigins) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowOrigins) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
	// Unknown
	WorkflowPhasesUnknown WorkflowPhases = "Unknown"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
	WorkflowPhasesUnknown,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded, WorkflowPhasesUnknown:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowPhases) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowPhases) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

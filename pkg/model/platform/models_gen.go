// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// Analysis run spec object base fields
type AnalysisRunMetricSpecBase interface {
	IsAnalysisRunMetricSpecBase()
}

// Application tree item might be Application or ApplicationSet
type ApplicationTreeItem interface {
	IsApplicationTreeItem()
}

// ArgoCD Notification
type ArgoCDNotification interface {
	IsArgoCDNotification()
}

// ArgoEvents Notification
type ArgoEventsNotification interface {
	IsArgoEventsNotification()
}

// Base entity
type BaseEntity interface {
	IsBaseEntity()
}

// Common entity payload
type CommonEntityEventPayload interface {
	IsCommonEntityEventPayload()
}

// "Common events properties
type CommonGitEventPayloadData interface {
	IsCommonGitEventPayloadData()
}

// Customer
type Customer interface {
	IsCustomer()
}

// Generic edge to allow cursors
type Edge interface {
	IsEdge()
}

// Entity types
type Entity interface {
	IsEntity()
}

// Error
type Error interface {
	IsError()
}

// Event
type Event interface {
	IsEvent()
}

// Event payload data types
type EventPayloadData interface {
	IsEventPayloadData()
}

// Favorable
type Favorable interface {
	IsFavorable()
}

// Favorable
type FavorableNotK8s interface {
	IsFavorableNotK8s()
}

// Favorable Not K8s Entity
type FavorableNotK8sEntity interface {
	IsFavorableNotK8sEntity()
}

// Notification That is part of a process
type GitOpsNotification interface {
	IsGitOpsNotification()
}

// "Push data
type GitPush interface {
	IsGitPush()
}

// Gitops entity
type GitopsEntity interface {
	IsBaseEntity()
	IsGitopsEntity()
}

// IDP Entity
type IDP interface {
	IsIDP()
}

// K8s logic entity
type K8sLogicEntity interface {
	IsK8sLogicEntity()
}

// Base entity
type K8sStandardEntity interface {
	IsK8sStandardEntity()
}

// Notification Base type
type Notification interface {
	IsNotification()
}

// Project based entity
type ProjectBasedEntity interface {
	IsProjectBasedEntity()
}

// PromotionTemplateFields
type PromotionTemplateFields interface {
	IsPromotionTemplateFields()
}

// ReadModelEventPayload base interface
type ReadModelEventPayload interface {
	IsReadModelEventPayload()
}

// Slice
type Slice interface {
	IsSlice()
}

// Workflow spec template
type WorkflowSpecTemplate interface {
	IsWorkflowSpecTemplate()
}

// Account is logical entity that group together users pipeliens and more
type Account struct {
	// The account id
	ID string `json:"id"`
	// The account unique name
	Name *string `json:"name,omitempty"`
	// Show to feature flags status for this account
	Features *AccountFeatures `json:"features,omitempty"`
	// Account SSO integrations
	SsoIntegrations []*Sso `json:"ssoIntegrations,omitempty"`
	// Users that are attached to this account
	Users []*User `json:"users,omitempty"`
	// Ids of all users that have account admin permission to this account
	Admins []string `json:"admins,omitempty"`
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains,omitempty"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains,omitempty"`
	// Account security
	Security *SecurityInfo `json:"security,omitempty"`
	// Collaborators
	Collaborators *AccountCollaborators `json:"collaborators,omitempty"`
	// Private account owner
	PrivateAccountOwner *string `json:"privateAccountOwner,omitempty"`
	// The git provider of the shared config repo
	GitProvider *GitProviders `json:"gitProvider,omitempty"`
	// The api url of the shared config repo git server
	GitAPIURL *string `json:"gitApiUrl,omitempty"`
	// Shared config repo url
	SharedConfigRepo *string `json:"sharedConfigRepo,omitempty"`
	// CSDP settings validated
	CsdpValidated *bool `json:"csdpValidated,omitempty"`
	// Features supported by all runtimes
	RuntimeFeatures []*RuntimeFeature `json:"runtimeFeatures"`
	// Supports Managed Runtime
	SupportsManagedRuntime *bool `json:"supportsManagedRuntime,omitempty"`
	// Pipeline settings
	PipelineConfig *PipelineConfig `json:"pipelineConfig,omitempty"`
	// System type
	SystemType *SystemType `json:"systemType,omitempty"`
	// System type prev
	SystemTypePrev *SystemType `json:"systemTypePrev,omitempty"`
	// Account badge token
	BadgeToken *string `json:"badgeToken,omitempty"`
	// Cloud Builds
	CloudBuilds *CloudBuilds `json:"cloudBuilds,omitempty"`
	// Account Settings
	Settings *AccountSettings `json:"settings,omitempty"`
}

// AccountCollaborators
type AccountCollaborators struct {
	// Limit
	Limit *int `json:"limit,omitempty"`
	// Used
	Used *int `json:"used,omitempty"`
}

// Account Features flags
type AccountFeatures struct {
	// Support ability to toggle between dark and light mode
	ThemeToggle *bool `json:"themeToggle,omitempty"`
	// Add ability to create/edit pipeline from UI in the configuration tab
	CreatePipelineArguments *bool `json:"createPipelineArguments,omitempty"`
	// Add ability to see workflow templates list page
	CsdpWorkflowTemplates *bool `json:"csdpWorkflowTemplates,omitempty"`
	// Add ability to see additonal widgets on the dashboard in home page
	CsdpDashboardWidgets *bool `json:"csdpDashboardWidgets,omitempty"`
	// Add ability to see and access DORA metrics page
	CsdpDoraMetrics *bool `json:"csdpDoraMetrics,omitempty"`
	// Add ability to see and access integration widgets on the dashboard
	CsdpManagedArgo *bool `json:"csdpManagedArgo,omitempty"`
	// Add ability to force reload route when navigation failed due to chunk error
	CsdpReloadOnChunkErrorFeature *bool `json:"csdpReloadOnChunkErrorFeature,omitempty"`
	// Show CSDP runtime resources in applications list
	ShowCSDPRuntimeResources *bool `json:"showCSDPRuntimeResources,omitempty"`
	// Shows button that links to classic codefresh
	ShowClassicCodefreshButton *bool `json:"showClassicCodefreshButton,omitempty"`
	// Support ability to use oauth2 for automatic registration
	Oauth2AutomaticRegistration *bool `json:"oauth2AutomaticRegistration,omitempty"`
	// Support ability to add integrations
	CsdpIntegrations *bool `json:"csdpIntegrations,omitempty"`
	// Support ability to add Amazon ECR integration
	CsdpAmazonECRIntegration *bool `json:"csdpAmazonECRIntegration,omitempty"`
	// Support ability to add authentications
	CsdpAuthentication *bool `json:"csdpAuthentication,omitempty"`
	// Adds ability to set SSH connection credentials to allow applications and sub modules to connect to a repository over SSH
	SupportSSHCreds *bool `json:"supportSSHCreds,omitempty"`
	// Gives access to application current state graph
	ShowAppCurrentStateGraph *bool `json:"showAppCurrentStateGraph,omitempty"`
	// Gives access to application release rollout details drawer
	ShowAppRolloutDetails *bool `json:"showAppRolloutDetails,omitempty"`
	// Gives access to application release analysis run details drawer
	ShowAppAnalysisRunsDetails *bool `json:"showAppAnalysisRunsDetails,omitempty"`
	// To build correct references beetween apps and appSets we always define metadata.cluster=https://kubernetes.default.svc because they always within same cluster
	UseDefaultSvcApplicationClusterMetadata *bool `json:"useDefaultSvcApplicationClusterMetadata,omitempty"`
	// Sets default codefresh authentication for runtime
	UseCodefreshAuthForManagedRuntime *bool `json:"useCodefreshAuthForManagedRuntime,omitempty"`
	// Retrieve runtime features for the active account
	CsdpRuntimesCompatibility *bool `json:"csdpRuntimesCompatibility,omitempty"`
	// Cut refsBy if parent app not present in list of applications
	CsdpAppUnexistedRefByCut *bool `json:"csdpAppUnexistedRefByCut,omitempty"`
	// Ability to sync application
	CsdpApplicationSync *bool `json:"csdpApplicationSync,omitempty"`
	// Ability to refresh application
	CsdpApplicationRefresh *bool `json:"csdpApplicationRefresh,omitempty"`
	// Adds ability to disable Sync from UI
	CsdpDisableSyncFromUI *bool `json:"csdpDisableSyncFromUi,omitempty"`
	// Ability to show application details
	CsdpApplicationDetails *bool `json:"csdpApplicationDetails,omitempty"`
	// Allows to send csdp audit events to classic platform
	CsdpAudit *bool `json:"csdpAudit,omitempty"`
	// Hides first release till it doesn't have attached rollout
	CsdpHideFirstRelease *bool `json:"csdpHideFirstRelease,omitempty"`
	// Allow runtime installation via helm chart
	KubeNativeInstall *bool `json:"kubeNativeInstall,omitempty"`
	// Applications dashboard cards view
	ApplicationsDashboardCardsView *bool `json:"applicationsDashboardCardsView,omitempty"`
	// Updated resources section in app release
	CsdpAppReleaseResourceDiff *bool `json:"csdpAppReleaseResourceDiff,omitempty"`
	// Application events tab
	ApplicationEventsTab *bool `json:"applicationEventsTab,omitempty"`
	// Ability to resume rollout
	CsdpRolloutResume *bool `json:"csdpRolloutResume,omitempty"`
	// Enable refresh token logic
	CsdpRefreshToken *bool `json:"csdpRefreshToken,omitempty"`
	// Adds ability to add jira oauth integration
	CsdpJiraOauthIntegration *bool `json:"csdpJiraOauthIntegration,omitempty"`
	// Supports GitLab for managed runtime
	GitlabSupportForManagedRuntime *bool `json:"gitlabSupportForManagedRuntime,omitempty"`
	// Supports Bitbucket for managed runtime
	BitbucketSupportForManagedRuntime *bool `json:"bitbucketSupportForManagedRuntime,omitempty"`
	// Adds ability to connect Gerrit as git provider
	SupportGerrit *bool `json:"supportGerrit,omitempty"`
	// Show new errors drawer for runtime
	NewRuntimeErrorsDrawer *bool `json:"newRuntimeErrorsDrawer,omitempty"`
	// Adds manifest field to resource tree object (temporary)
	ResourceTreeWithManifest *bool `json:"resourceTreeWithManifest,omitempty"`
	// Show require pruning label to resource
	RequirePruningLabelToResource *bool `json:"requirePruningLabelToResource,omitempty"`
	// Disables all actions for rollout resource: in playe (rollout details drawer), current state (three dot menu), release / services / section
	DisableRolloutActionsWithoutRbac *bool `json:"disableRolloutActionsWithoutRBAC,omitempty"`
	// Combines GitOps and Codefresh Classic menu items
	CommonSideMenu *bool `json:"commonSideMenu,omitempty"`
	// Gives access to Modules page with sidemenu settings
	ModulesConfigurationPage *bool `json:"modulesConfigurationPage,omitempty"`
	// UI Execution Context page in the account settings
	ExecutionContext *bool `json:"executionContext,omitempty"`
	// Account has ABAC support
	Abac *bool `json:"abac,omitempty"`
	// New ABAC permissions page
	AbacV2 *bool `json:"abacV2,omitempty"`
	// Shows user git personal token settings menu in project one
	UnifiedUserGitTokens *bool `json:"unifiedUserGitTokens,omitempty"`
	// Adds ability to rollback rollout from rollout drawer in app timeline
	GitOpsRolloutRollback *bool `json:"gitOpsRolloutRollback,omitempty"`
	// Shows Beamer widget for all platforms (What's new)
	BeamerWidget *bool `json:"beamerWidget,omitempty"`
	// Enables codefreshV2 for admins
	CodefreshV2 *bool `json:"codefreshV2,omitempty"`
	// Enables codefreshV2 for non admins
	CodefreshV2NonAdmins *bool `json:"codefreshV2NonAdmins,omitempty"`
	// Adds ability for account admins to switch account type
	ProjectOneSwitch *bool `json:"projectOneSwitch,omitempty"`
	// Adds ability to expand graph
	GraphExpand *bool `json:"graphExpand,omitempty"`
	// Theme configurations depend on systemType & prevSystemType fields
	ProjectOneSystemTypes *bool `json:"projectOneSystemTypes,omitempty"`
	// Shows gitops page in classic
	EnvironmentsV2Flag *bool `json:"environmentsV2Flag,omitempty"`
	// Shows gitOps home dashboard inside the project one menu only for gitOps users
	ShowGitOpsHomeDashboardInTheProjectOneMenu *bool `json:"showGitOpsHomeDashboardInTheProjectOneMenu,omitempty"`
	// Enables Unified Dashboard for Project One
	CommonDashboardProjectOne *bool `json:"commonDashboardProjectOne,omitempty"`
	// Adds ability to rollback release in native argo cd way
	GitopsArgoCdRollback *bool `json:"gitopsArgoCdRollback,omitempty"`
	// Enables CommandBar in the client
	Commandbar *bool `json:"commandbar,omitempty"`
	// Adds ability to group applications by annotation 'codefresh.io/app-group'
	GitopsAppGroups *bool `json:"gitopsAppGroups,omitempty"`
	// Enables environments view for gitops platform
	GitopsEnvironments *bool `json:"gitopsEnvironments,omitempty"`
	// Adds ability to copy link with account specific info
	AccountInfoCopyButton *bool `json:"accountInfoCopyButton,omitempty"`
	// Allows the creation of a restricted git source
	RestrictedGitSource *bool `json:"restrictedGitSource,omitempty"`
	// Enables Codefresh to track user activity with Fullstory in the UI
	Fullstory *bool `json:"fullstory,omitempty"`
	// Enables showing Delighted CX surveys in the UI
	DelightedSurvey *bool `json:"delightedSurvey,omitempty"`
	// Enables environments view used in the classic platform
	ClassicEnvironments *bool `json:"classicEnvironments,omitempty"`
	// Hide git-sources and related applications without git permissions and when permissions are not provided
	CsdpFilterAppsByGitPermissions *bool `json:"csdpFilterAppsByGitPermissions,omitempty"`
	// Hide Compositions item in navigation menu
	HideCompositionsMenuItem *bool `json:"hideCompositionsMenuItem,omitempty"`
	// Shows promotion workflows in the application menu
	PromotionWorkflows *bool `json:"promotionWorkflows,omitempty"`
	// Allows product components to be draggable and enables a promotion flow
	PromotionFlow *bool `json:"promotionFlow,omitempty"`
	// Feature provides a visual representation of the differences between the normalizedLiveState and predictedLiveState
	AppDiffView *bool `json:"appDiffView,omitempty"`
	// Install hosted runtimes using the gitops runtime helm chart
	HelmHostedRuntime *bool `json:"helmHostedRuntime,omitempty"`
	// Enables usage of argo-platform-broadcaster service instead of api-graphql for subscriptions
	APIBroadcasterEnabled *bool `json:"apiBroadcasterEnabled,omitempty"`
	// Enables promotion flows view
	PromotionFlowsManagement *bool `json:"promotionFlowsManagement,omitempty"`
	// Enables ability to display application info from AppProxy
	HeaderLiveState *bool `json:"headerLiveState,omitempty"`
	// Enables promotion orchestration for products including product's releases API and promotion flow API
	PromotionOrchestration *bool `json:"promotionOrchestration,omitempty"`
	// Enables promotion policies view
	PromotionPolicies *bool `json:"promotionPolicies,omitempty"`
	// Enables ability to display runtime observability
	GitopsRuntimeObservability *bool `json:"gitopsRuntimeObservability,omitempty"`
	// When enabled instead of showing the account switch dialog the account will automatically be switched
	AutoBuildSwitchAccount *bool `json:"autoBuildSwitchAccount,omitempty"`
	// Enables ability to display rolloout + analysis run info from AppProxy
	RolloutPlayerLiveState *bool `json:"rolloutPlayerLiveState,omitempty"`
	// Enables Product CRD functionality
	ProductCrd *bool `json:"productCRD,omitempty"`
	// Enables ability to create a shared service account user that's not tied to any specific person and holds account api-keys
	ServiceAccounts *bool `json:"serviceAccounts,omitempty"`
}

// Account Settings will hold a generic object with settings used by the UI
type AccountSettings struct {
	// Account Settings
	Settings string `json:"settings"`
	// Schema Version
	SchemaVersion string `json:"schemaVersion"`
	// Updated At
	UpdatedAt time.Time `json:"updatedAt"`
}

// Account Settings Input
type AccountSettingsInput struct {
	// Account Settings
	Settings string `json:"settings"`
	// Schema Version
	SchemaVersion string `json:"schemaVersion"`
	// Updated At
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Args to add user to account
type AddUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso,omitempty"`
}

// AnalysisRun
type AnalysisRun struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Live manifest
	LiveManifest *string `json:"liveManifest,omitempty"`
	// Rollout revision
	Revision int `json:"revision"`
	// Analysis Run Status
	Status *AnalysisRunStatus `json:"status"`
	// Analysis Run spec
	Spec *AnalysisRunSpec `json:"spec"`
}

func (AnalysisRun) IsK8sStandardEntity() {}

func (AnalysisRun) IsEntity() {}

// Analysis Datadog Spec
type AnalysisRunDatadogSpec struct {
	// Query
	Query string `json:"query"`
}

// AnalysisRun Edge
type AnalysisRunEdge struct {
	// Node contains the actual analysis run data
	Node *AnalysisRun `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (AnalysisRunEdge) IsEdge() {}

// Analysis Kayenta Spec
type AnalysisRunKayentaSpec struct {
	// Address
	Address string `json:"address"`
}

// Analysis run spec object
type AnalysisRunMetricSpec struct {
	// Name
	Name string `json:"name"`
	// Interval
	Interval *string `json:"interval,omitempty"`
	// Success Condition
	SuccessCondition *string `json:"successCondition,omitempty"`
	// Failure Condition
	FailureCondition *string `json:"failureCondition,omitempty"`
	// Failure Limit
	FailureLimit *string `json:"failureLimit,omitempty"`
	// Inconclusive Limit
	InconclusiveLimit *string `json:"inconclusiveLimit,omitempty"`
	// Consecutive Error Limit
	ConsecutiveErrorLimit *string `json:"consecutiveErrorLimit,omitempty"`
	// Count
	Count *string `json:"count,omitempty"`
	// Initial Delay
	InitialDelay *string `json:"initialDelay,omitempty"`
	// Analysis run spec object calculated - after processing template variables
	CalculatedValues *AnalysisRunMetricSpecCalculated `json:"calculatedValues,omitempty"`
	// Provider
	Provider *AnalysisRunProviderSpec `json:"provider"`
}

func (AnalysisRunMetricSpec) IsAnalysisRunMetricSpecBase() {}

// Analysis run spec object with calculated values - all fields conditinal
type AnalysisRunMetricSpecCalculated struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Interval
	Interval *string `json:"interval,omitempty"`
	// Success Condition
	SuccessCondition *string `json:"successCondition,omitempty"`
	// Failure Condition
	FailureCondition *string `json:"failureCondition,omitempty"`
	// Failure Limit
	FailureLimit *string `json:"failureLimit,omitempty"`
	// Inconclusive Limit
	InconclusiveLimit *string `json:"inconclusiveLimit,omitempty"`
	// Consecutive Error Limit
	ConsecutiveErrorLimit *string `json:"consecutiveErrorLimit,omitempty"`
	// Count
	Count *string `json:"count,omitempty"`
	// Initial Delay
	InitialDelay *string `json:"initialDelay,omitempty"`
}

func (AnalysisRunMetricSpecCalculated) IsAnalysisRunMetricSpecBase() {}

// Analysis NewRelic Spec
type AnalysisRunNewRelicSpec struct {
	// Query
	Query string `json:"query"`
}

// Analysis Run Prometheus spec
type AnalysisRunPrometheusSpec struct {
	// Address
	Address string `json:"address"`
	// Query
	Query string `json:"query"`
}

// Analysis status object
type AnalysisRunProviderSpec struct {
	// Job
	Job *string `json:"job,omitempty"`
	// Prometheus
	Prometheus *AnalysisRunPrometheusSpec `json:"prometheus,omitempty"`
	// Datadog
	Datadog *AnalysisRunDatadogSpec `json:"datadog,omitempty"`
	// New Relic
	NewRelic *AnalysisRunNewRelicSpec `json:"newRelic,omitempty"`
	// Wavefront
	Wavefront *AnalysisRunWavefrontSpec `json:"wavefront,omitempty"`
	// Web
	Web *AnalysisRunWebSpec `json:"web,omitempty"`
	// Kayenta
	Kayenta *AnalysisRunKayentaSpec `json:"kayenta,omitempty"`
	// Cloud Watch
	CloudWatch *string `json:"cloudWatch,omitempty"`
}

// AnalysisRun Slice
type AnalysisRunSlice struct {
	// Analysis run edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (AnalysisRunSlice) IsSlice() {}

// Analysis run spec metrics
type AnalysisRunSpec struct {
	// Metrics
	Metrics []*AnalysisRunMetricSpec `json:"metrics"`
}

// Analysis status object
type AnalysisRunStatus struct {
	// Message
	Message *string `json:"message,omitempty"`
	// Metric results
	MetricResults []*MetricResult `json:"metricResults"`
	// Total Successful
	TotalSuccessful int `json:"totalSuccessful"`
	// Total Failed
	TotalFailed int `json:"totalFailed"`
	// Total Inconclusive
	TotalInconclusive int `json:"totalInconclusive"`
	// Total Error
	TotalError int `json:"totalError"`
	// Entire state of analysis
	Phase *AnalysisPhases `json:"phase,omitempty"`
}

// Analysis Wavefront Spec
type AnalysisRunWavefrontSpec struct {
	// Address
	Address string `json:"address"`
	// Query
	Query string `json:"query"`
}

// Analysis Web Spec
type AnalysisRunWebSpec struct {
	// Url
	URL string `json:"url"`
}

// Analytics app group dropdown list
type AnalyticsAppGroupList struct {
	// App Groups
	AppGroups []string `json:"appGroups"`
}

// Analytics application dropdown list
type AnalyticsApplicationsList struct {
	// Applications
	Applications []string `json:"applications"`
}

// Classic Analytics Pipeline Dropdown
type AnalyticsClassicPipeline struct {
	// Pipeline Id
	PipelineID string `json:"pipelineId"`
	// Pipeline Name
	PipelineName string `json:"pipelineName"`
	// Pipeline Full Name
	PipelineFullName string `json:"pipelineFullName"`
	// Is pipeline deleted
	IsDeleted bool `json:"isDeleted"`
}

// Classic Analytics Pipeline Tags Dropdown
type AnalyticsClassicPipelineTag struct {
	// Tag Id
	TagID string `json:"tagId"`
	// Tag Name
	TagName string `json:"tagName"`
}

// Analytics classic pipelines dropdown list
type AnalyticsClassicPipelinesList struct {
	// Pipelines
	Pipelines []*AnalyticsClassicPipeline `json:"pipelines"`
}

// Classic Analytics Proejcts Dropdown
type AnalyticsClassicProject struct {
	// Project Id
	ProjectID string `json:"projectId"`
	// Project Name
	ProjectName string `json:"projectName"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Analytics classic projects dropdown list
type AnalyticsClassicProjectsList struct {
	// Projects
	Projects []*AnalyticsClassicProject `json:"projects"`
}

// Analytics classic pipelines dropdown list
type AnalyticsClassicTagsList struct {
	// Tags
	Tags []*AnalyticsClassicPipelineTag `json:"tags"`
}

// Analytics cluster dropdown list
type AnalyticsClustersList struct {
	// Cluster Names
	ClusterNamesList []*ClusterNamesDDRecord `json:"clusterNamesList"`
	// Cluster Names
	ClusterUrlsList []*ClusterURLDDRecord `json:"clusterUrlsList"`
}

// Analytics environment dropdown list
type AnalyticsEnvironmentList struct {
	// Environments
	Environments []string `json:"environments"`
}

// Analytics product dropdown list
type AnalyticsProductList struct {
	// Products
	Products []string `json:"products"`
}

// Analytics runtime dropdown list
type AnalyticsRuntimesList struct {
	// Runtimes
	RuntimeNames []string `json:"runtimeNames"`
}

// Annotation
type Annotation struct {
	// Annotation id
	ID *string `json:"id,omitempty"`
	// Annotation type
	Type string `json:"type"`
	// Annotation value
	Value *string `json:"value,omitempty"`
	// Annotation accountId
	AccountID *string `json:"accountId,omitempty"`
	// Annotation classicId
	ClassicID *string `json:"classicId,omitempty"`
	// Annotation entityId
	EntityID string `json:"entityId"`
	// Annotation entityType
	EntityType string `json:"entityType"`
	// Annotation key
	Key string `json:"key"`
}

// Args to set annotation for entity
type AnnotationArgs struct {
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId,omitempty"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId,omitempty"`
	// Event-source entityType
	EntityType string `json:"entityType"`
	// Event-source key
	Key string `json:"key"`
	// Event-source type
	Type string `json:"type"`
	// Annotation classicId
	ClassicID *string `json:"classicId,omitempty"`
	// Event-source issueValue
	IssueValue *IssueValue `json:"issueValue,omitempty"`
	// Event-source pullRequestValue
	PullRequestValue *PullRequestValue `json:"pullRequestValue,omitempty"`
	// Event-source genericValue
	GenericValue *string `json:"genericValue,omitempty"`
}

// Application Edge
type AnnotationEdge struct {
	// Node contains the actual application data
	Node *Annotation `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter annotation
type AnnotationFilterArgs struct {
	// Event-source id
	ID *string `json:"id,omitempty"`
	// Event-source k8sEntityId
	K8sEntityID *K8sEntityID `json:"k8sEntityId,omitempty"`
	// Event-source logicEntityId
	LogicEntityID *LogicEntityID `json:"logicEntityId,omitempty"`
	// Event-source entityType
	EntityType *string `json:"entityType,omitempty"`
	// Annotation classicId
	ClassicID *string `json:"classicId,omitempty"`
	// Event-source key
	Key *string `json:"key,omitempty"`
	// Event-source type
	Type *string `json:"type,omitempty"`
}

// Annotation Slice
type AnnotationSlice struct {
	// Annotation edges
	Edges []*AnnotationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// ApiKey
type APIKey struct {
	// ApiKey id
	ID string `json:"id"`
	// ApiKey name
	Name string `json:"name"`
	// ApiKey tokenPrefix
	TokenPrefix string `json:"tokenPrefix"`
	// ApiKey scopes
	Scopes []*string `json:"scopes"`
	// ApiKey scopeSnapshot
	ScopeSnapshot *APIKeyScopeSnapshot `json:"scopeSnapshot,omitempty"`
	// ApiKey subject
	Subject *APIKeySubject `json:"subject"`
	// ApiKey created
	Created *string `json:"created,omitempty"`
}

// ApiKeyArgs
type APIKeyArgs struct {
	// ApiKey name
	Name string `json:"name"`
	// ApiKey scopes
	Scopes []*string `json:"scopes"`
}

// "ApiKeyScope Entity
type APIKeyScope struct {
	// Resource full access scope name
	Name string `json:"name"`
	// Resource full access description
	Description string `json:"description"`
	// Resource full access title
	Title string `json:"title"`
	// Resource other scopes
	Scopes []*APIKeyScope `json:"scopes"`
}

// ApiKeyScopeSnapshot
type APIKeyScopeSnapshot struct {
	// ApiKeyScopeSnapshot ID
	ID string `json:"id"`
	// ApiKeyScopeSnapshot scopes
	Scopes []*string `json:"scopes"`
	// ApiKeyScopeSnapshot date
	Date *string `json:"date,omitempty"`
}

// ApiKeySubject
type APIKeySubject struct {
	// ApiKeySubject type
	Type *string `json:"type,omitempty"`
	// ApiKeySubject ref
	Ref *string `json:"ref,omitempty"`
}

// "Generate api token result
type APIToken struct {
	// The token to use in runtime installation and other requests
	Token *string `json:"token,omitempty"`
}

// AppAndAppSet Edge
type AppAndAppSetEdge struct {
	// Node contains the actual application data
	Node ApplicationTreeItem `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// AppAndAppSet Slice
type AppAndAppSetSlice struct {
	// Application edges
	Edges []*AppAndAppSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// RestrictedGitSource destination
type AppProjectDestination struct {
	// The destination server name (CAN NOT contain wildcards)
	Name *string `json:"name,omitempty"`
	// The destination server url (can contain wildcards)
	Server *string `json:"server,omitempty"`
	// The destination namespace (can contain wildcards)
	Namespace string `json:"namespace"`
}

// AppProjectReadModelEventPayload type
type AppProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (AppProjectReadModelEventPayload) IsReadModelEventPayload() {}

// App-Proxy Info
type AppProxyInfo struct {
	// Description
	Description *string `json:"description,omitempty"`
	// Status
	Status AppProxyStatus `json:"status"`
}

// AppResourceDifference
type AppResourceDifference struct {
	// Current record
	CurrentRecord *AppResourceDifferenceRecord `json:"currentRecord"`
	// Previous record
	PreviousRecord *AppResourceDifferenceRecord `json:"previousRecord,omitempty"`
}

// AppResourceDifferenceRecord
type AppResourceDifferenceRecord struct {
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
}

// App Resource metadata
type AppResourceMetadataInput struct {
	// Resource Name
	ResourceName string `json:"resourceName"`
	// Resource api version
	Version string `json:"version"`
	// Resource king
	Kind string `json:"kind"`
	// Resource group
	Group *string `json:"group,omitempty"`
	// Resource namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Application entity
type Application struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations,omitempty"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission,omitempty"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Updated At
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// RepoURL
	RepoURL *string `json:"repoURL,omitempty"`
	// Number of resources
	Size *int `json:"size,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Argo CD application destination config
	Destination *ArgoCDApplicationDestination `json:"destination,omitempty"`
	// Argo CD application spec source config
	SpecSource *ArgoCDApplicationSpecSource `json:"specSource,omitempty"`
	// Include files
	Include *string `json:"include,omitempty"`
	// Exclude files
	Exclude *string `json:"exclude,omitempty"`
	// Operation State (argo)
	OperationState *ApplicationOperationState `json:"operationState,omitempty"`
	// Sync info (argo)
	Sync *ApplicationSyncStatus `json:"sync,omitempty"`
	// Sync policy
	SyncPolicy *AppSyncPolicies `json:"syncPolicy,omitempty"`
	// Is HELM app flag
	IsHelmApp *bool `json:"isHelmApp,omitempty"`
	// Is git source app flag
	IsGitSource *bool `json:"isGitSource,omitempty"`
	// Related groups names list
	RelatedGroups []*string `json:"relatedGroups"`
	// Version of application and dependencies
	AppVersions *ProductComponentVersions `json:"appVersions,omitempty"`
	// Resolved when product app attached to specific product or null if unassigned. Normally should be 1 or 0. If more this means that collision in relation present and component belongs to different products
	Products []*Product `json:"products,omitempty"`
	// Resolved when product app attached to specific environment or null if unassigned
	Environments []*Environment `json:"environments,omitempty"`
}

func (Application) IsApplicationTreeItem() {}

func (Application) IsGitopsEntity() {}

func (Application) IsBaseEntity() {}

func (Application) IsProjectBasedEntity() {}

func (Application) IsFavorable() {}

func (Application) IsEntity() {}

// Application Edge
type ApplicationEdge struct {
	// Node contains the actual application data
	Node *Application `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationEdge) IsEdge() {}

// ApplicationField Entity
type ApplicationField struct {
	// Destination info
	Destination *ApplicationFormDestination `json:"destination,omitempty"`
	// Status
	Status *ArgoCDApplicationStatus `json:"status,omitempty"`
	// Issues
	Issues []*Annotation `json:"issues,omitempty"`
	// PullRequest
	Prs []*Annotation `json:"prs,omitempty"`
	// Committers
	Committers []*CommitterLabel `json:"committers,omitempty"`
	// ArgoCD application target revision
	Revision *string `json:"revision,omitempty"`
	// Build
	Builds []*Build `json:"builds,omitempty"`
}

// Application form data object
type ApplicationFormData struct {
	// Metadata
	Metadata *ApplicationFormMetadata `json:"metadata"`
	// Destination info
	Destination *ApplicationFormDestination `json:"destination"`
	// Application source
	Source *ApplicationFormSource `json:"source"`
	// Project of application
	Project string `json:"project"`
	// Sync policy settings
	SyncPolicy *ApplicationFormSyncPolicy `json:"syncPolicy,omitempty"`
	// Ignore differences list
	IgnoreDifferences []*ApplicationFormIgnoreDifferences `json:"ignoreDifferences,omitempty"`
}

// Application form Destination
type ApplicationFormDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Destination namespace
	Namespace *string `json:"namespace,omitempty"`
	// Cluster address
	Server *string `json:"server,omitempty"`
}

// Application ignore differences
type ApplicationFormIgnoreDifferences struct {
	// Group of ignored resource
	Group *string `json:"group,omitempty"`
	// Kind of ignored resource
	Kind string `json:"kind"`
	// Name of ignored resource
	Name *string `json:"name,omitempty"`
	// Namespace of ignored resource
	Namespace *string `json:"namespace,omitempty"`
	// Ignored json paths
	JSONPointers []string `json:"jsonPointers,omitempty"`
	// Jq Path Expressions
	JqPathExpressions []string `json:"jqPathExpressions,omitempty"`
	// ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take precedence over the desired state defined in the SCM and won't be displayed in diffs
	ManagedFieldsManagers []string `json:"managedFieldsManagers,omitempty"`
}

// Application form input data object
type ApplicationFormInputData struct {
	// Metadata
	Metadata *ApplicationFormInputMetadata `json:"metadata"`
	// Destination info
	Destination *ApplicationFormInputDestination `json:"destination"`
	// Application source
	Source *ApplicationFormInputSource `json:"source"`
	// Project of application
	Project string `json:"project"`
	// Sync policy settings
	SyncPolicy *ApplicationFormInputSyncPolicy `json:"syncPolicy,omitempty"`
	// Ignore differences list
	IgnoreDifferences []*ApplicationFormInputIgnoreDifferences `json:"ignoreDifferences,omitempty"`
}

// Application form Destination
type ApplicationFormInputDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Destination namespace
	Namespace *string `json:"namespace,omitempty"`
	// Cluster address
	Server *string `json:"server,omitempty"`
}

// Application input ignore differences
type ApplicationFormInputIgnoreDifferences struct {
	// Group of ignored resource
	Group *string `json:"group,omitempty"`
	// Kind of ignored resource
	Kind string `json:"kind"`
	// Name of ignored resource
	Name *string `json:"name,omitempty"`
	// Namespace of ignored resource
	Namespace *string `json:"namespace,omitempty"`
	// Ignored json paths
	JSONPointers []string `json:"jsonPointers,omitempty"`
	// jq Path Expressions
	JqPathExpressions []string `json:"jqPathExpressions,omitempty"`
	// ManagedFieldsManagers is a list of trusted managers. Fields mutated by those managers will take precedence over the desired state defined in the SCM and won't be displayed in diffs
	ManagedFieldsManagers []string `json:"managedFieldsManagers,omitempty"`
}

// Application form metadata
type ApplicationFormInputMetadata struct {
	// Application name
	Name string `json:"name"`
	// Application namespace
	Namespace *string `json:"namespace,omitempty"`
	// Application finalizers
	Finalizers []string `json:"finalizers,omitempty"`
	// Annotations
	Annotations *string `json:"annotations,omitempty"`
	// Labels
	Labels *string `json:"labels,omitempty"`
}

// Application form Source
type ApplicationFormInputSource struct {
	// Path
	Path *string `json:"path,omitempty"`
	// Repository url
	RepoURL string `json:"repoURL"`
	// Target revision
	TargetRevision string `json:"targetRevision"`
	// Helm chart
	Chart *string `json:"chart,omitempty"`
	// Directory
	Directory *ApplicationFormInputSourceDirectory `json:"directory,omitempty"`
	// HEML
	Helm *ApplicationFormInputSourceHelm `json:"helm,omitempty"`
	// Kustomize
	Kustomize *ApplicationFormInputSourceKustomize `json:"kustomize,omitempty"`
	// Ksonnet
	Ksonnet *ApplicationFormInputSourceKsonnet `json:"ksonnet,omitempty"`
	// Plugin
	Plugin *ApplicationFormInputSourcePlugin `json:"plugin,omitempty"`
}

// Application form Source Directory
type ApplicationFormInputSourceDirectory struct {
	// Directory recurse
	Recurse *bool `json:"recurse,omitempty"`
	// Exclude
	Exclude *string `json:"exclude,omitempty"`
	// Include
	Include *string `json:"include,omitempty"`
	// Directory jsonnet options
	Jsonnet *ApplicationFormInputSourceDirectoryJsonnet `json:"jsonnet,omitempty"`
}

// Application form Source Directory Jsonnet
type ApplicationFormInputSourceDirectoryJsonnet struct {
	// Top level vars
	Tlas []*NameValueCodeInput `json:"tlas,omitempty"`
	// External vars
	ExtVars []*NameValueCodeInput `json:"extVars,omitempty"`
	// Libs
	Libs []string `json:"libs,omitempty"`
}

// Application form Source Helm
type ApplicationFormInputSourceHelm struct {
	// Values
	Values *string `json:"values,omitempty"`
	// Value files
	ValueFiles []string `json:"valueFiles,omitempty"`
	// Parameters
	Parameters []*NameValueInput `json:"parameters,omitempty"`
}

// Application form Source Ksonnet
type ApplicationFormInputSourceKsonnet struct {
	// Environment
	Environment string `json:"environment"`
}

// Application form Source Kustomize
type ApplicationFormInputSourceKustomize struct {
	// Name prefix
	NamePrefix *string `json:"namePrefix,omitempty"`
	// Name suffix
	NameSuffix *string `json:"nameSuffix,omitempty"`
	// Images
	Images []string `json:"images,omitempty"`
}

// Application form Source Plugin
type ApplicationFormInputSourcePlugin struct {
	// Plagin name
	Name *string `json:"name,omitempty"`
	// Plagin parameters
	Parameters []string `json:"parameters,omitempty"`
	// Array of env variables
	Env []*NameValueInput `json:"env,omitempty"`
}

// Application form Sync Automated Policy
type ApplicationFormInputSyncAutomatedPolicy struct {
	// Prune policy flag
	Prune *bool `json:"prune,omitempty"`
	// Self heal policy flag
	SelfHeal *bool `json:"selfHeal,omitempty"`
	// AllowEmpty allows apps have zero live resources
	AllowEmpty *bool `json:"allowEmpty,omitempty"`
}

// Application form Sync Policy
type ApplicationFormInputSyncPolicy struct {
	// Automated sync policy options
	Automated *ApplicationFormInputSyncAutomatedPolicy `json:"automated,omitempty"`
	// Sync options
	SyncOptions []string `json:"syncOptions,omitempty"`
	// Retry options
	Retry *ApplicationFormInputSyncRetryOptions `json:"retry,omitempty"`
}

// Application form Sync Policy retry options
type ApplicationFormInputSyncRetryBackoffOptions struct {
	// Duration
	Duration string `json:"duration"`
	// Max duration
	MaxDuration string `json:"maxDuration"`
	// Factor
	Factor int `json:"factor"`
}

// Application form Sync Policy retry options
type ApplicationFormInputSyncRetryOptions struct {
	// Retries amount
	Limit int `json:"limit"`
	// Backoff options
	Backoff *ApplicationFormInputSyncRetryBackoffOptions `json:"backoff"`
}

// Application form metadata
type ApplicationFormMetadata struct {
	// Application name
	Name string `json:"name"`
	// Application namespace
	Namespace *string `json:"namespace,omitempty"`
	// Application finalizers
	Finalizers []string `json:"finalizers,omitempty"`
	// Annotations
	Annotations *string `json:"annotations,omitempty"`
	// Labels
	Labels *string `json:"labels,omitempty"`
}

// Application form Source
type ApplicationFormSource struct {
	// Path
	Path *string `json:"path,omitempty"`
	// Repository url
	RepoURL string `json:"repoURL"`
	// Target revision
	TargetRevision *string `json:"targetRevision,omitempty"`
	// Helm chart
	Chart *string `json:"chart,omitempty"`
	// Directory
	Directory *ApplicationFormSourceDirectory `json:"directory,omitempty"`
	// HEML
	Helm *ApplicationFormSourceHelm `json:"helm,omitempty"`
	// Kustomize
	Kustomize *ApplicationFormSourceKustomize `json:"kustomize,omitempty"`
	// Ksonnet
	Ksonnet *ApplicationFormSourceKsonnet `json:"ksonnet,omitempty"`
	// Plugin
	Plugin *ApplicationFormSourcePlugin `json:"plugin,omitempty"`
	// Name of ref source
	Ref *string `json:"ref,omitempty"`
}

// Application form Source Directory
type ApplicationFormSourceDirectory struct {
	// Directory recurse
	Recurse *bool `json:"recurse,omitempty"`
	// Exclude
	Exclude *string `json:"exclude,omitempty"`
	// Include
	Include *string `json:"include,omitempty"`
	// Directory jsonnet options
	Jsonnet *ApplicationFormSourceDirectoryJsonnet `json:"jsonnet,omitempty"`
}

// Application form Source Directory Jsonnet
type ApplicationFormSourceDirectoryJsonnet struct {
	// Top level vars
	Tlas []*NameValueCodeOutput `json:"tlas,omitempty"`
	// External vars
	ExtVars []*NameValueCodeOutput `json:"extVars,omitempty"`
	// Libs
	Libs []string `json:"libs,omitempty"`
}

// Application form Source Helm
type ApplicationFormSourceHelm struct {
	// Values
	Values *string `json:"values,omitempty"`
	// Value files
	ValueFiles []string `json:"valueFiles,omitempty"`
	// Parameters
	Parameters []*NameValueOutput `json:"parameters,omitempty"`
	// File Parameters
	FileParameters []*ArgoCdDTOHelmFileParameter `json:"fileParameters,omitempty"`
	// Ignore Missing Value Files
	IgnoreMissingValueFiles *bool `json:"ignoreMissingValueFiles,omitempty"`
	// Pass Credentials
	PassCredentials *bool `json:"passCredentials,omitempty"`
	// Release Name
	ReleaseName *string `json:"releaseName,omitempty"`
	// Skip Crds
	SkipCrds *bool `json:"skipCrds,omitempty"`
	// Values Object
	ValuesObject *ArgoCdDTORuntimeRawExtension `json:"valuesObject,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// Application form Source Ksonnet
type ApplicationFormSourceKsonnet struct {
	// Environment
	Environment string `json:"environment"`
}

// Application form Source Kustomize
type ApplicationFormSourceKustomize struct {
	// Name prefix
	NamePrefix *string `json:"namePrefix,omitempty"`
	// Name suffix
	NameSuffix *string `json:"nameSuffix,omitempty"`
	// Images
	Images []string `json:"images,omitempty"`
	// CommonAnnotations
	CommonAnnotations *string `json:"commonAnnotations,omitempty"`
	// CommonAnnotationsEnvsubst
	CommonAnnotationsEnvsubst *bool `json:"commonAnnotationsEnvsubst,omitempty"`
	// CommonLabels
	CommonLabels *string `json:"commonLabels,omitempty"`
	// Components
	Components []*string `json:"components,omitempty"`
	// ForceCommonAnnotations
	ForceCommonAnnotations *bool `json:"forceCommonAnnotations,omitempty"`
	// ForceCommonLabels
	ForceCommonLabels *bool `json:"forceCommonLabels,omitempty"`
	// ForceNamespace
	ForceNamespace *bool `json:"forceNamespace,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Patches
	Patches []*ArgoCdDTOKustomizePatch `json:"patches,omitempty"`
	// Replicas
	Replicas []*ArgoCdDTOKustomizeReplica `json:"replicas,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// Application form Source Plugin
type ApplicationFormSourcePlugin struct {
	// Plagin name
	Name *string `json:"name,omitempty"`
	// Plagin parameters
	Parameters []*ArgoCdDTOApplicationSourcePluginParameter `json:"parameters,omitempty"`
	// Array of env variables
	Env []*NameValueOutput `json:"env,omitempty"`
}

// Application form Sync Automated Policy
type ApplicationFormSyncAutomatedPolicy struct {
	// Prune policy flag
	Prune *bool `json:"prune,omitempty"`
	// Self heal policy flag
	SelfHeal *bool `json:"selfHeal,omitempty"`
	// AllowEmpty allows apps have zero live resources
	AllowEmpty *bool `json:"allowEmpty,omitempty"`
}

// Application form Sync Policy
type ApplicationFormSyncPolicy struct {
	// Automated sync policy options
	Automated *ApplicationFormSyncAutomatedPolicy `json:"automated,omitempty"`
	// Sync options - e.g. ['key=value']
	SyncOptions []string `json:"syncOptions,omitempty"`
	// Retry options
	Retry *ApplicationFormSyncRetryOptions `json:"retry,omitempty"`
	// Managed namespace metadata
	ManagedNamespaceMetadata *ArgoCdDTOManagedNamespaceMetadata `json:"managedNamespaceMetadata,omitempty"`
}

// Application form Sync Policy retry options
type ApplicationFormSyncRetryBackoffOptions struct {
	// Duration
	Duration string `json:"duration"`
	// Max duration
	MaxDuration string `json:"maxDuration"`
	// Factor
	Factor int `json:"factor"`
}

// Application form Sync Policy retry options
type ApplicationFormSyncRetryOptions struct {
	// Retries amount
	Limit int `json:"limit"`
	// Backoff options
	Backoff *ApplicationFormSyncRetryBackoffOptions `json:"backoff"`
}

// Application Group Entity
type ApplicationGroup struct {
	// Entity db id
	ID string `json:"id"`
	// Group name
	Name string `json:"name"`
	// Group Applications count
	ApplicationCount *int `json:"applicationCount,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Is group marked as favorite (user scope)
	Favorite *bool `json:"favorite,omitempty"`
}

func (ApplicationGroup) IsFavorableNotK8s() {}

func (ApplicationGroup) IsFavorableNotK8sEntity() {}

func (ApplicationGroup) IsEntity() {}

// ApplicationGroup Edge
type ApplicationGroupEdge struct {
	// Node contains the actual application group data
	Node *ApplicationGroup `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationGroupEdge) IsEdge() {}

// Args to filter ApplicationGroup
type ApplicationGroupFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
}

// Application Group Slice
type ApplicationGroupSlice struct {
	// Application Group edges
	Edges []*ApplicationGroupEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationGroupSlice) IsSlice() {}

// Application Groups sorting arguments
type ApplicationGroupSortArg struct {
	// Field for sorting
	Field ApplicationGroupsSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Application manifest hierarchy
type ApplicationManifestHierarchy struct {
	// Block name
	Name string `json:"name"`
	// Block line number
	Line *int `json:"line,omitempty"`
	// Nested items
	Children []*ApplicationManifestHierarchy `json:"children"`
}

// Application Operation
type ApplicationOperation struct {
	// Initiated By
	InitiatedBy *ApplicationOperationInitiatedBy `json:"initiatedBy,omitempty"`
	// Retry
	Retry *ApplicationOperationRetryOptions `json:"retry,omitempty"`
	// Info
	Info []*NameValueOutput `json:"info,omitempty"`
	// Sync
	Sync *ApplicationOperationSync `json:"sync,omitempty"`
}

// ApplicationOperationInitiator
type ApplicationOperationInitiatedBy struct {
	// Automated
	Automated *bool `json:"automated,omitempty"`
	// Username
	Username *string `json:"username,omitempty"`
}

// Application form Sync Policy retry options
type ApplicationOperationRetryBackoffOptions struct {
	// Duration
	Duration *string `json:"duration,omitempty"`
	// Max duration
	MaxDuration *string `json:"maxDuration,omitempty"`
	// Factor
	Factor *int `json:"factor,omitempty"`
}

// ApplicationOperationRetryOptions
type ApplicationOperationRetryOptions struct {
	// Limit is the maximum Int of attempts for retrying a failed sync. If set to 0, no retries will be performed.
	Limit *int `json:"limit,omitempty"`
	// Backoff
	Backoff *ApplicationOperationRetryBackoffOptions `json:"backoff,omitempty"`
}

// Application Operation State
type ApplicationOperationState struct {
	// Finished At
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Started At
	StartedAt string `json:"startedAt"`
	// Message
	Message *string `json:"message,omitempty"`
	// Phase
	Phase SyncOperationPhase `json:"phase"`
	// Type
	Type AppOperationType `json:"type"`
	// Retry Count
	RetryCount *int `json:"retryCount,omitempty"`
	// Operation
	Operation *ApplicationOperation `json:"operation"`
	// Sync Result
	SyncResult *ApplicationSyncResult `json:"syncResult,omitempty"`
}

// ArgoCdDTO SyncOperation object
type ApplicationOperationSync struct {
	// Prune
	Prune *bool `json:"prune,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// Sync Options - e.g. ['key=value']
	SyncOptions []string `json:"syncOptions,omitempty"`
	// Resources
	Resources []*ApplicationOperationSyncResource `json:"resources,omitempty"`
	// Sync Strategy
	SyncStrategy *ApplicationOperationSyncStrategy `json:"syncStrategy,omitempty"`
	// DryRun
	DryRun *bool `json:"dryRun,omitempty"`
	// Manifests
	Manifests []*string `json:"manifests,omitempty"`
	// Revisions is the list of revision (Git) or chart version (Helm) which to sync each source in sources field for the application to. If omitted, will use the revision specified in app spec.
	Revisions []*string `json:"revisions,omitempty"`
	// Source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Sources
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
}

// ApplicationOperationSyncResource
type ApplicationOperationSyncResource struct {
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Group
	Group *string `json:"group,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// ApplicationOperationSyncStrategy
type ApplicationOperationSyncStrategy struct {
	// Apply
	Apply *ArgoCdDTOSyncStrategyApply `json:"apply,omitempty"`
	// Hook
	Hook *ArgoCdDTOSyncStrategyHook `json:"hook,omitempty"`
}

// ApplicationOrderedStatistics
type ApplicationOrderedStatistics struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Applications stats
	ApplicationsStats []*ApplicationOrderedStatisticsData `json:"applicationsStats"`
}

// Ordered Application Stats single application statistics
type ApplicationOrderedStatisticsData struct {
	// Application
	Application string `json:"application"`
	// Namespace
	Namespace string `json:"namespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Cluster
	Cluster string `json:"cluster"`
	// Application deployment statistics by status
	DeploymentStatusBreakdown []*DeploymentStatisticsInfo `json:"deploymentStatusBreakdown"`
	// Total deployments
	TotalDeployments *MetricWithTrend `json:"totalDeployments"`
}

// ApplicationReadModelEventPayload type
type ApplicationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (ApplicationReadModelEventPayload) IsReadModelEventPayload() {}

// Application ref
type ApplicationRef struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Kind
	Kind string `json:"kind"`
	// Version
	Version string `json:"version"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Is reference was cut during tree normalizing
	IsReferenceCut *bool `json:"isReferenceCut,omitempty"`
}

// ApplicationSet entity
type ApplicationSet struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations,omitempty"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Updated At
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// RepoURL
	RepoURL *string `json:"repoURL,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// Number of resources
	Size *int `json:"size,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
}

func (ApplicationSet) IsBaseEntity() {}

func (ApplicationSet) IsProjectBasedEntity() {}

func (ApplicationSet) IsFavorable() {}

func (ApplicationSet) IsApplicationTreeItem() {}

func (ApplicationSet) IsEntity() {}

// Application Set Edge
type ApplicationSetEdge struct {
	// Node contains the actual application set data
	Node *ApplicationSet `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ApplicationSetEdge) IsEdge() {}

// ApplicationSet Slice
type ApplicationSetSlice struct {
	// Application edges
	Edges []*ApplicationSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSetSlice) IsSlice() {}

// Application Slice
type ApplicationSlice struct {
	// Application edges
	Edges []*ApplicationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ApplicationSlice) IsSlice() {}

// Application Sync Compared To
type ApplicationSyncComparedTo struct {
	// Destination
	Destination *ApplicationFormDestination `json:"destination"`
	// Source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Sources - present for multisourced apps
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
}

// ApplicationSyncResult
type ApplicationSyncResult struct {
	// Revision
	Revision string `json:"revision"`
	// Revisions
	Revisions []string `json:"revisions,omitempty"`
	// Resources
	Resources []*SyncResultResource `json:"resources,omitempty"`
	// Source
	Source *ApplicationFormSource `json:"source,omitempty"`
	// Sources - present for multisourced apps
	Sources []*ApplicationFormSource `json:"sources,omitempty"`
}

// Application Sync Status
type ApplicationSyncStatus struct {
	// Status
	Status SyncStatus `json:"status"`
	// Revision - null is not multisourced
	Revision *string `json:"revision,omitempty"`
	// Revisions - present if multisourced
	Revisions []string `json:"revisions,omitempty"`
	// ComparedTo
	ComparedTo *ApplicationSyncComparedTo `json:"comparedTo,omitempty"`
}

// Application tree filter arguments
type ApplicationTreeFilterArgs struct {
	// Filter applications from a specific project
	Project *string `json:"project,omitempty"`
	// Filter applications from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter applications from runtime list
	Runtimes []string `json:"runtimes,omitempty"`
	// Filter applications by list of names
	Applications []string `json:"applications,omitempty"`
	// Filter applications by name fragment
	ApplicationName *string `json:"applicationName,omitempty"`
	// Filter applications by name
	ApplicationFullName *string `json:"applicationFullName,omitempty"`
	// Filter applications by status
	Statuses []SyncStatus `json:"statuses,omitempty"`
	// Filter applications by health status
	HealthStatuses []HealthStatus `json:"healthStatuses,omitempty"`
	// Filter applications by namespace list
	Namespaces []string `json:"namespaces,omitempty"`
	// Filter applications by namespace
	Namespace *string `json:"namespace,omitempty"`
	// Filter applications by kind
	Kinds []string `json:"kinds,omitempty"`
	// Filter applications by cluster urls list
	ClusterUrls []string `json:"clusterUrls,omitempty"`
	// Filter applications by cluster url
	ClusterURL *string `json:"clusterUrl,omitempty"`
	// Filter applications by cluster url
	Clusters []string `json:"clusters,omitempty"`
	// Filter applications by favorite using userId
	UserID *string `json:"userId,omitempty"`
	// Filter applications by favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Filter applications by labels
	Labels []string `json:"labels,omitempty"`
	// Filter applications by groups
	Groups []string `json:"groups,omitempty"`
	// Filter applications by version
	Versions []string `json:"versions,omitempty"`
	// Filter applications by list of application groups (annotation)
	AppGroups []string `json:"appGroups,omitempty"`
}

// Application Tree Health Status Statistic
type ApplicationTreeHealthStatusStatisticRecord struct {
	// Health Status
	Type HealthStatus `json:"type"`
	// Count
	Count int `json:"count"`
}

// Application tree sorting arguments
type ApplicationTreeSortArg struct {
	// Field for sorting
	Field ApplicationTreeSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Application filter arguments
type ApplicationsFilterArgs struct {
	// Filter applications from a specific project
	Project *string `json:"project,omitempty"`
	// Filter applications from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter applications from runtime list
	Runtimes []string `json:"runtimes,omitempty"`
	// Filter applications by list of names
	Applications []string `json:"applications,omitempty"`
	// Filter applications by name fragment
	ApplicationName *string `json:"applicationName,omitempty"`
	// Filter applications by status
	Statuses []SyncStatus `json:"statuses,omitempty"`
	// Filter applications by health status
	HealthStatuses []HealthStatus `json:"healthStatuses,omitempty"`
	// Filter applications by namespace list
	Namespaces []string `json:"namespaces,omitempty"`
	// Filter applications by namespace
	Namespace *string `json:"namespace,omitempty"`
	// Filter applications by kind
	Kinds []string `json:"kinds,omitempty"`
	// Filter applications by cluster urls list
	ClusterUrls []string `json:"clusterUrls,omitempty"`
	// Filter applications by cluster url
	ClusterURL *string `json:"clusterUrl,omitempty"`
	// Filter applications by favorite using userId
	UserID *string `json:"userId,omitempty"`
	// Filter applications by favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Filter applications by labels
	Labels []string `json:"labels,omitempty"`
	// Filter applications by groups
	Groups []string `json:"groups,omitempty"`
	// Filter applications by versions
	Versions []string `json:"versions,omitempty"`
	// Used by the runtime to get applications that did not receive events for a long time and need to be finalized
	Inactive *bool `json:"inactive,omitempty"`
	// Include runtime components in the result
	IncludeComponents *bool `json:"includeComponents,omitempty"`
}

// Application relations
type AppsRelations struct {
	// Entities referencing this entity
	ReferencedBy []*ApplicationRef `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []*ApplicationRef `json:"references,omitempty"`
}

// Argo CD Application destination config
type ArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Cluster url
	Server *string `json:"server,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Argo CD Application spec source
type ArgoCDApplicationSpecSource struct {
	// Path
	Path *string `json:"path,omitempty"`
	// Repo url
	RepoURL string `json:"repoURL"`
	// Branch/Tag or chart version (for helm)
	TargetRevision *string `json:"targetRevision,omitempty"`
	// Chart name
	Chart *string `json:"chart,omitempty"`
}

// Argo CD Application status
type ArgoCDApplicationStatus struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Sync started at
	SyncStartedAt *string `json:"syncStartedAt,omitempty"`
	// Sync finished at
	SyncFinishedAt *string `json:"syncFinishedAt,omitempty"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Revision
	Revision string `json:"revision"`
	// Version
	Version string `json:"version"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// CommitAvatar
	CommitAvatar *string `json:"commitAvatar,omitempty"`
	// CommitUrl
	CommitURL *string `json:"commitUrl,omitempty"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage,omitempty"`
	// CommitDate
	CommitDate *string `json:"commitDate,omitempty"`
	// History Id
	HistoryID *int `json:"historyId,omitempty"`
	// History Id
	MinHistoryID *int `json:"minHistoryId,omitempty"`
}

// ArgoCdDTOApplicationSourcePluginParameter
type ArgoCdDTOApplicationSourcePluginParameter struct {
	// Array is the value of an array type parameter.
	Array []*string `json:"array,omitempty"`
	// Map is the value of a map type parameter. {[k: String]: String }
	Map *string `json:"map,omitempty"`
	// Name is the name identifying a parameter.
	Name *string `json:"name,omitempty"`
	// String_ is the value of a String type parameter.
	String *string `json:"string,omitempty"`
}

// ArgoCdDTOHelmFileParameter
type ArgoCdDTOHelmFileParameter struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
}

// ArgoCdDTOIntstrIntOrString
type ArgoCdDTOIntstrIntOrString struct {
	// IntVal
	IntVal *int `json:"intVal,omitempty"`
	// StrVal
	StrVal *string `json:"strVal,omitempty"`
	// Type
	Type *int `json:"type,omitempty"`
}

// ArgoCdDTOKustomizeGvk
type ArgoCdDTOKustomizeGvk struct {
	// Group
	Group *string `json:"group,omitempty"`
	// Kind
	Kind *string `json:"kind,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// ArgoCdDTOKustomizePatch
type ArgoCdDTOKustomizePatch struct {
	// { [k: String]: Boolean }
	Options *string `json:"options,omitempty"`
	// Patch
	Patch *string `json:"patch,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Target
	Target *ArgoCdDTOKustomizeSelector `json:"target,omitempty"`
}

// ArgoCdDTOKustomizeReplica
type ArgoCdDTOKustomizeReplica struct {
	// Count
	Count *ArgoCdDTOIntstrIntOrString `json:"count"`
	// Name
	Name string `json:"name"`
}

// ArgoCdDTOKustomizeResId
type ArgoCdDTOKustomizeResID struct {
	// Gvk
	Gvk *ArgoCdDTOKustomizeGvk `json:"gvk,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// ArgoCdDTOKustomizeSelector
type ArgoCdDTOKustomizeSelector struct {
	// AnnotationSelector
	AnnotationSelector *string `json:"annotationSelector,omitempty"`
	// LabelSelector
	LabelSelector *string `json:"labelSelector,omitempty"`
	// ResId
	ResID *ArgoCdDTOKustomizeResID `json:"resId,omitempty"`
}

// ArgoCdDTOManagedNamespaceMetadata
type ArgoCdDTOManagedNamespaceMetadata struct {
	// { [k: String]: String }
	Annotations *string `json:"annotations,omitempty"`
	// { [k: String]: String }
	Labels *string `json:"labels,omitempty"`
}

// RawExtension is used to hold extensions in external versions. To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
type ArgoCdDTORuntimeRawExtension struct {
	// Raw
	Raw *string `json:"raw,omitempty"`
}

// ArgoCdDTOSyncStrategyApply
type ArgoCdDTOSyncStrategyApply struct {
	// Force indicates whether or not to supply the --force flag to `kubectl apply`. The --force flag deletes and re-create the resource, when PATCH encounters conflict and has retried for 5 times.
	Force *bool `json:"force,omitempty"`
}

// SyncStrategyHook will perform a sync using hooks annotations. If no hook annotation is specified falls back to `kubectl apply`.
type ArgoCdDTOSyncStrategyHook struct {
	// SyncStrategyApply
	SyncStrategyApply *ArgoCdDTOSyncStrategyApply `json:"syncStrategyApply,omitempty"`
}

// Argo Hub Template
type ArgoHubTemplate struct {
	// Version
	ID *string `json:"id,omitempty"`
	// Manifest
	Manifest *string `json:"manifest,omitempty"`
	// Manifest url
	ManifestURL *string `json:"manifestUrl,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// Categories
	Categories []*string `json:"categories,omitempty"`
}

// Argo Hub Templates
type ArgoHubTemplates struct {
	// Starter template name
	Data []*ArgoHubTemplatesSlice `json:"data,omitempty"`
}

// Argo Hub templates filter arguments
type ArgoHubTemplatesFilterArgs struct {
	// Filter Argo Hub Templates by category
	Category *string `json:"category,omitempty"`
	// Filter Argo Hub Templates by name
	Name *string `json:"name,omitempty"`
}

// Argo Hub Templates Slice
type ArgoHubTemplatesSlice struct {
	// Template name
	Name *string `json:"name,omitempty"`
	// Versions
	Versions []*ArgoHubTemplate `json:"versions,omitempty"`
	// Latest version
	LatestVersion *ArgoHubTemplate `json:"latestVersion,omitempty"`
}

// Audit Classic MetaInfo
type AuditClassicMetaInfo struct {
	// UserId
	UserID *string `json:"userId,omitempty"`
	// AccountId
	AccountID *string `json:"accountId,omitempty"`
	// Entity
	Entity string `json:"entity"`
	// Action
	Action string `json:"action"`
	// EntityId
	EntityID *string `json:"entityId,omitempty"`
	// EntityName
	EntityName *string `json:"entityName,omitempty"`
	// UserEmail
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName
	UserName *string `json:"userName,omitempty"`
	// LoggedInByAdminId
	LoggedInByAdminID *string `json:"loggedInByAdminId,omitempty"`
	// LoggedInByAdminName
	LoggedInByAdminName *string `json:"loggedInByAdminName,omitempty"`
	// CorrelationId
	CorrelationID *string `json:"correlationId,omitempty"`
	// Ip
	IP *string `json:"ip,omitempty"`
}

// Audit Classic Request Data
type AuditClassicRequest struct {
	// Url
	URL string `json:"url"`
	// Body
	Body *string `json:"body,omitempty"`
	// Query
	Query *string `json:"query,omitempty"`
	// Params
	Params *string `json:"params,omitempty"`
}

// Audit Classic Response Data
type AuditClassicResponse struct {
	// Status
	Status int `json:"status"`
	// Body
	Body *string `json:"body,omitempty"`
}

// Audit Edge
type AuditEdge struct {
	// Node contains the actual audit record
	Node *AuditEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Audit Entity Record
type AuditEntity struct {
	// Timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// AccountId
	AccountID *string `json:"accountId,omitempty"`
	// AccountName
	AccountName *string `json:"accountName,omitempty"`
	// UserId
	UserID *string `json:"userId,omitempty"`
	// UserName
	UserName *string `json:"userName,omitempty"`
	// Action
	Action string `json:"action"`
	// AuthEntityType
	AuthEntityType string `json:"authEntityType"`
	// EventType
	EventType string `json:"eventType"`
	// EntityType
	EntityType string `json:"entityType"`
	// EntityId
	EntityID *string `json:"entityId,omitempty"`
	// EntityName
	EntityName string `json:"entityName"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// IP
	IP *string `json:"ip,omitempty"`
	// Method
	Method *string `json:"method,omitempty"`
	// Url
	URL *string `json:"url,omitempty"`
	// Params
	Params *string `json:"params,omitempty"`
	// Query
	Query *string `json:"query,omitempty"`
	// Headers
	Headers *string `json:"headers,omitempty"`
	// Payload
	Payload *string `json:"payload,omitempty"`
	// Status
	Status *int `json:"status,omitempty"`
	// Response
	Response *string `json:"response,omitempty"`
}

// Audit Entity Classic
type AuditEntityClassic struct {
	// Metainfo
	Metainfo *AuditClassicMetaInfo `json:"metainfo"`
	// Request
	Request *AuditClassicRequest `json:"request"`
	// Response
	Response *AuditClassicResponse `json:"response"`
}

// Args to filter audit
type AuditFilterArgs struct {
	// Status
	Status *int `json:"status,omitempty"`
}

// Audit Slice
type AuditSlice struct {
	// Audit edges
	Edges []*AuditEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Auth0SSO
type Auth0sso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
}

func (Auth0sso) IsIDP() {}

// Authorization input
type AuthArgs struct {
	// x-access-token
	AccessToken *string `json:"accessToken,omitempty"`
	// api key
	APIKey *string `json:"apiKey,omitempty"`
}

// Stats for avg change failure rate
type AvgChangeFailureRateStatistics struct {
	// Avg change failure rate data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Avg change failure rate info
	Info *DoraStatisticsSummery `json:"info"`
}

// Stats for Avg time to restore service
type AvgTimeToRestoreServiceStatistics struct {
	// Avg time to restore service data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Avg time to restore service info
	Info *DoraStatisticsSummery `json:"info"`
}

// AzureSSO
type AzureSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// Tenant
	Tenant *string `json:"tenant,omitempty"`
	// Object Id in Azure
	AppID *string `json:"appId,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Cookie key
	CookieKey *string `json:"cookieKey,omitempty"`
	// Cookie iv
	CookieIv *string `json:"cookieIv,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
}

func (AzureSso) IsIDP() {}

// BasePrice
type BasePrice struct {
	// Month
	Month *int `json:"month,omitempty"`
	// Year
	Year *int `json:"year,omitempty"`
}

// references info
type BaseReference struct {
	// Object metadata
	Metadata *EntityReferenceMeta `json:"metadata,omitempty"`
}

// BitbucketCloud trigger conditions
type BitbucketCloudTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
	// Repo filter argumets
	Repo *RepoBitbucketCloudFilterArgs `json:"repo"`
}

// BitbucketCloud trigger conditions
type BitbucketCloudTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// repo filter argumets
	Repo *RepoBitbucketCloudFilterArgsInput `json:"repo"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// BitbucketServer trigger conditions
type BitbucketServerTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Bitbucket Server url
	BaseURL string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// BitbucketServer trigger conditions
type BitbucketServerTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Base url
	BaseURL string `json:"baseUrl"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// Build Entity
type Build struct {
	// Build Id
	ID string `json:"id"`
	// PipelineRef
	Pipeline *PipelineRef `json:"pipeline"`
}

// ClusterCacheInfo contains information about the cluster cache
type CacheInfo struct {
	// ResourcesCount holds number of observed Kubernetes resources
	ResourcesCount *int `json:"resourcesCount,omitempty"`
	// APIsCount holds number of observed Kubernetes API count
	ApisCount *int `json:"apisCount,omitempty"`
	// LastCacheSyncTime holds time of most recent cache synchronization
	LastCacheSyncTime *string `json:"lastCacheSyncTime,omitempty"`
}

// Cluster cache info input
type CacheInfoInput struct {
	// Number of observed Kubernetes resources
	ResourcesCount *int `json:"resourcesCount,omitempty"`
	// Number of observed Kubernetes API count
	ApisCount *int `json:"apisCount,omitempty"`
	// Last cache sync time
	LastCacheSyncTime *string `json:"lastCacheSyncTime,omitempty"`
}

// Calendar event payload data
type CalendarEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// TBD
	Schedule *string `json:"schedule,omitempty"`
	// TBD
	Interval *string `json:"interval,omitempty"`
	// TBD
	Timezone *string `json:"timezone,omitempty"`
	// TBD
	Metadata *string `json:"metadata,omitempty"`
}

func (CalendarEventPayloadData) IsEventPayloadData() {}

// Calendar trigger conditions
type CalendarTriggerConditions struct {
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Number of seconds, minutes, hours, etc..
	Interval *string `json:"interval,omitempty"`
	// Cron expression
	Schedule *string `json:"schedule,omitempty"`
	// TimeZone
	Timezone *string `json:"timezone,omitempty"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Calendar trigger conditions
type CalendarTriggerConditionsArgs struct {
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Number of seconds, minutes, hours, etc..
	Interval *string `json:"interval,omitempty"`
	// Cron expression
	Schedule *string `json:"schedule,omitempty"`
	// TimeZone
	Timezone *string `json:"timezone,omitempty"`
	// Metadata
	Metadata *string `json:"metadata,omitempty"`
}

// ChildApplicationField Entity
type ChildApplicationField struct {
	// Name
	Name string `json:"name"`
	// Repo
	Repo *string `json:"repo,omitempty"`
	// Cluster
	Cluster *string `json:"cluster,omitempty"`
	// Status
	Status *SyncStatus `json:"status,omitempty"`
}

// Child workflow reference
type ChildWorkflowRef struct {
	// Child workflow
	Workflow *Workflow `json:"workflow,omitempty"`
	// Child workflow type
	Type *string `json:"type,omitempty"`
	// Node ref
	NodeRef *string `json:"nodeRef,omitempty"`
}

// Filter argument for classic analytics dropdowns
type ClassicDropdownFilterArgs struct {
	// Name
	Name string `json:"name"`
}

// Classic pipeline duration stats
type ClassicPipelineDurationMetric struct {
	// Duration Name
	DurationName DurationName `json:"durationName"`
	// Duration statistics
	DurationStats *ClassicPipelineMetric `json:"durationStats"`
}

// Classic pipeline metric
type ClassicPipelineMetric struct {
	// Info
	Info *PipelineClassicStatsInfo `json:"info"`
	// Data
	Data []*TimeSeriesDataRecord `json:"data"`
}

// Classic Pipeline Performance Record
type ClassicPipelinePerformanceRecord struct {
	// Pipeline Id
	PipelineID string `json:"pipelineId"`
	// Pipeline Name
	PipelineName string `json:"pipelineName"`
	// Project Id
	ProjectID *string `json:"projectId,omitempty"`
	// Project Name
	ProjectName *string `json:"projectName,omitempty"`
	// Number of exeuctions statistic
	Executions *MetricWithTrend `json:"executions"`
	// Pipeline Duration Statitstic
	Duration *MetricWithTrend `json:"duration"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Pipeline statistics to be used in analytics module
type ClassicPipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *ClassicPipelineMetric `json:"successRateStats"`
	// Duration stats
	DurationStats []*ClassicPipelineDurationMetric `json:"durationStats"`
}

// Classic Pipelines Performance Statistics
type ClassicPipelinesPerformanceStatistics struct {
	// Performance stats
	PerformancesStats []*ClassicPipelinePerformanceRecord `json:"performancesStats"`
	// Duration type
	DurationType *PipelineClassicStatisticDurationMetricType `json:"durationType,omitempty"`
	// Time dimension info
	Info *StatsTimePeriodData `json:"info,omitempty"`
}

// ClientIP
type ClientIP struct {
	// TimeoutSeconds
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// Cloud Builds
type CloudBuilds struct {
	// Is cloud builds activated
	IsActivated *bool `json:"isActivated,omitempty"`
	// Who was it performed by
	PerformedBy *string `json:"performedBy,omitempty"`
	// Is cloud builds requested
	IsRequested *bool `json:"isRequested,omitempty"`
	// Date
	Date *string `json:"date,omitempty"`
}

// Cluster entity
type Cluster struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references"`
	// Server is the API server URL of the Kubernetes cluster
	Server string `json:"server"`
	// Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
	Namespaces []string `json:"namespaces"`
	// RefreshRequestedAt holds time when cluster cache refresh has been requested
	RefreshRequestedAt *string `json:"refreshRequestedAt,omitempty"`
	// Shard contains optional shard number. Calculated on the fly by the application controller if not specified.
	Shard *int `json:"shard,omitempty"`
	// Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
	ClusterResources bool `json:"clusterResources"`
	// Info holds information about cluster cache and state
	Info *ClusterInfo `json:"info"`
}

func (Cluster) IsBaseEntity() {}

func (Cluster) IsEntity() {}

// Cluster Edge
type ClusterEdge struct {
	// Node contains the actual cluster data
	Node *Cluster `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ClusterEdge) IsEdge() {}

// ClusterInfo contains information about the cluster
type ClusterInfo struct {
	// ConnectionState contains information about the connection to the cluster
	ConnectionState *ConnectionState `json:"connectionState"`
	// ServerVersion contains information about the Kubernetes version of the cluster
	ServerVersion *string `json:"serverVersion,omitempty"`
	// CacheInfo contains information about the cluster cache
	CacheInfo *CacheInfo `json:"cacheInfo,omitempty"`
	// ApplicationsCount is the number of applications managed by Argo CD on the cluster
	ApplicationsCount int `json:"applicationsCount"`
	// APIVersions contains list of API versions supported by the cluster
	APIVersions []*string `json:"apiVersions,omitempty"`
}

// Cluster info input
type ClusterInfoInput struct {
	// Connection state
	ConnectionState *ConnectionStateInput `json:"connectionState"`
	// The Kubernetes version of the cluster
	ServerVersion *string `json:"serverVersion,omitempty"`
	// Cache info
	CacheInfo *CacheInfoInput `json:"cacheInfo,omitempty"`
	// Number of applications managed by Argo CD on the cluster
	ApplicationsCount int `json:"applicationsCount"`
	// APIVersions contains list of API versions supported by the cluster
	APIVersions []*string `json:"apiVersions,omitempty"`
}

// Cluster Names Record For Dropdown
type ClusterNamesDDRecord struct {
	// Name
	Name string `json:"name"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Cluster Slice
type ClusterSlice struct {
	// Cluster edges
	Edges []*ClusterEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ClusterSlice) IsSlice() {}

// Cluster upsert args
type ClusterUpsertArgs struct {
	// Cluster name
	Name string `json:"name"`
	// The runtime of which the cluster belongs
	Runtime string `json:"runtime"`
	// Cluster server URL
	Server string `json:"server"`
	// Cluster info
	Info *ClusterInfoInput `json:"info"`
}

// Cluster Url Record For Dropdown
type ClusterURLDDRecord struct {
	// Name
	Name string `json:"name"`
	// Url
	URL string `json:"url"`
	// Is Deleted
	IsDeleted bool `json:"isDeleted"`
}

// Clusters statistics
type ClustersStatistics struct {
	// Total clusters number
	Total int `json:"total"`
	// Number of connected runtimes
	Connected int `json:"connected"`
	// Number of failed connection clusters
	Failed int `json:"failed"`
	// Number of unknown connection clusters
	Unknown int `json:"unknown"`
}

// Commits
type Commits struct {
	// url
	URL *string `json:"url,omitempty"`
	// userName
	UserName *string `json:"userName,omitempty"`
	// sha
	Sha *string `json:"sha,omitempty"`
	// message
	Message *string `json:"message,omitempty"`
	// commitDate
	CommitDate *string `json:"commitDate,omitempty"`
}

// Commits output
type CommitsOutput struct {
	// Commit url
	URL string `json:"url"`
	// Commit author
	UserName string `json:"userName"`
	// Commit sha
	Sha string `json:"sha"`
	// Commit message
	Message string `json:"message"`
}

// Committer Label
type CommitterLabel struct {
	// UserName
	UserName string `json:"userName"`
	// Avatar
	Avatar *string `json:"avatar,omitempty"`
	// Committer commits list
	Commits []*CommitsOutput `json:"commits,omitempty"`
}

// Common entity event response
type CommonEntityEventResponse struct {
	// Time of event
	Time string `json:"time"`
	// Payload of event
	Payload CommonEntityEventPayload `json:"payload,omitempty"`
}

// Component entity
type Component struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self,omitempty"`
	// History of the component
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Component's version
	Version string `json:"version"`
}

func (Component) IsBaseEntity() {}

func (Component) IsK8sLogicEntity() {}

func (Component) IsProjectBasedEntity() {}

func (Component) IsEntity() {}

// Yaml contents of dependencies description
type ComponentDependenciesContent struct {
	// Source of dependencies
	Source *string `json:"source,omitempty"`
	// Yaml of dependencies
	Content *string `json:"content,omitempty"`
}

// Component Edge
type ComponentEdge struct {
	// Node contains the actual component data
	Node *Component `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ComponentEdge) IsEdge() {}

// Component Notification
type ComponentNotification struct {
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (ComponentNotification) IsNotification() {}

func (ComponentNotification) IsArgoCDNotification() {}

func (ComponentNotification) IsGitOpsNotification() {}

// ComponentReadModelEventPayload type
type ComponentReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (ComponentReadModelEventPayload) IsReadModelEventPayload() {}

// Component Slice
type ComponentSlice struct {
	// Component edges
	Edges []*ComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ComponentSlice) IsSlice() {}

// Composite Slice
type CompositeSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo []*CompositeSliceInfo `json:"pageInfo"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Infomration about a slice of a specific kind
type CompositeSliceInfo struct {
	// Key of the slice
	Key string `json:"key"`
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor,omitempty"`
}

// Pagination arguments to request kind-slice
type CompositeSlicePaginationArgs struct {
	// References a specific key
	Key string `json:"key"`
	// Returns entities after the provided cursor
	After *string `json:"after,omitempty"`
	// Returns entities before the provided cursor
	Before *string `json:"before,omitempty"`
	// Returns the first X entities
	First *int `json:"first,omitempty"`
	// Returns the last X entities
	Last *int `json:"last,omitempty"`
}

// ConfigMap Form Data object
type ConfigMapFormData struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata,omitempty"`
	// Data
	Data *string `json:"data,omitempty"`
	// Data
	BinaryData *string `json:"binaryData,omitempty"`
	// Sync status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
}

// GitAuthConfig form input data object
type ConfigMapFormInputData struct {
	// Metadata
	Metadata *ConfigMapFormInputMetadata `json:"metadata"`
	// Data
	Data *string `json:"data,omitempty"`
	// Binary Data
	BinaryData *string `json:"binaryData,omitempty"`
}

// ConfigMap form input metadata object
type ConfigMapFormInputMetadata struct {
	// ConfigMap name
	Name string `json:"name"`
	// ConfigMap namespace
	Namespace *string `json:"namespace,omitempty"`
}

// ConfigMapMetadata
type ConfigMapMetadata struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Labels
	Labels []*StringPair `json:"labels,omitempty"`
}

// ConnectionState contains information about remote resource connection state, currently used for clusters and repositories
type ConnectionState struct {
	// Status contains the current status indicator for the connection
	Status ClusterConnectionStatus `json:"status"`
	// Message contains human readable information about the connection status
	Message *string `json:"message,omitempty"`
	// AttemptedAt contains the timestamp when this connection status has been determined
	AttemptedAt *string `json:"attemptedAt,omitempty"`
}

// Cluster connection state input
type ConnectionStateInput struct {
	// Current status indicator for the connection
	Status ClusterConnectionStatusInput `json:"status"`
	// Human readable information about the connection status
	Message *string `json:"message,omitempty"`
	// Last attempt for connection
	AttemptedAt *string `json:"attemptedAt,omitempty"`
}

// Create Audit Classic Record Response
type CreateAuditClassicRecordResponse struct {
	// IsError
	IsError bool `json:"isError"`
	// Error message
	Message *string `json:"message,omitempty"`
}

// Create Environment Input
type CreateEnvironmentArgs struct {
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// List of clusters that belong to this environment
	Clusters []*EnvironmentClusterInput `json:"clusters"`
}

// Input for git-source placeholder
type CreateGitSourcePlaceholderInput struct {
	// App name
	AppName string `json:"appName"`
	// The path to the source watched by the git-source
	AppSpecifier string `json:"appSpecifier"`
	// The server on which the resources will be applied
	DestServer string `json:"destServer"`
	// The server on which the resources will be applied
	DestNamespace string `json:"destNamespace"`
	// The labels of the git-source
	Labels *string `json:"labels,omitempty"`
	// Files to be included
	Include *string `json:"include,omitempty"`
	// Files to be excluded
	Exclude *string `json:"exclude,omitempty"`
	// Is this a codefresh internal git-source
	IsInternal *bool `json:"isInternal,omitempty"`
	// Is this a restricted git-source
	IsRestricted *bool `json:"isRestricted,omitempty"`
}

// Create Product Input
type CreateProductArgs struct {
	// Product name
	Name string `json:"name"`
	// Tags list
	Tags []*string `json:"tags"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilter struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template,omitempty"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// Data filter is the raw argo events DataFilter ported from their types
type DataFilterArgs struct {
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
	// Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key.
	Path string `json:"path"`
	// Template is a go-template for extracting a string from the event's data. A Template is evaluated with provided path, type and value. The templating follows the standard go-template syntax as well as sprig's extra functions
	Template *string `json:"template,omitempty"`
	// Type contains the JSON type of the data
	Type string `json:"type"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []*string `json:"value"`
}

// DataRetention
type DataRetention struct {
	// Weeks
	Weeks *int `json:"weeks,omitempty"`
}

// DefaultDindResources
type DefaultDindResources struct {
	// Requests
	Requests *ResourcesRequests `json:"requests,omitempty"`
}

// Delete Environment Input
type DeleteEnvironmentArgs struct {
	// Id of the environment
	ID string `json:"id"`
}

// Delete Product Input
type DeleteProductArgs struct {
	// Id of the Product
	ID string `json:"id"`
}

// Deployment entity
type Deployment struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Deployment Entity
	Spec *DeploymentSpec `json:"spec"`
	// Deployment Status
	Status *DeploymentStatus `json:"status,omitempty"`
}

func (Deployment) IsGitopsEntity() {}

func (Deployment) IsBaseEntity() {}

func (Deployment) IsProjectBasedEntity() {}

func (Deployment) IsEntity() {}

// Container
type DeploymentContainer struct {
	// Containers
	Name *string `json:"name,omitempty"`
	// Image
	Image *string `json:"image,omitempty"`
	// ImagePullPolicy
	ImagePullPolicy *ImagePullPolicy `json:"imagePullPolicy,omitempty"`
}

// Deployment Edge
type DeploymentEdge struct {
	// Node contains the actual Deployment data
	Node *Deployment `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (DeploymentEdge) IsEdge() {}

// Stats for deployment frequency
type DeploymentFrequencyStatistics struct {
	// Deployment frequency statistics data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Deployments frequency info
	Info *DoraStatisticsSummery `json:"info"`
}

// DeploymentReadModelEventPayload type
type DeploymentReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (DeploymentReadModelEventPayload) IsReadModelEventPayload() {}

// Deployment Slice
type DeploymentSlice struct {
	// Deployment edges
	Edges []*DeploymentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (DeploymentSlice) IsSlice() {}

// Deployment Spec
type DeploymentSpec struct {
	// Template
	Template *PodTemplateSpec `json:"template,omitempty"`
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
}

// DeploymentSpecPart
type DeploymentSpecPart struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	// Status
	Status *DeploymentStatus `json:"status,omitempty"`
	// Containers
	Containers []*DeploymentContainer `json:"containers,omitempty"`
}

// Deployment statistics
type DeploymentStatistics struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Deployment statistics data
	Data []*DeploymentStatisticsData `json:"data"`
	// Deplyment statistics total
	Info []*DeploymentStatisticsInfo `json:"info"`
}

// Stats data for deployments - holds daily stats
type DeploymentStatisticsData struct {
	// Time
	Time string `json:"time"`
	// Deployment status
	Status DeploymentStatisticsStatus `json:"status"`
	// Number Of Syncs
	Value int `json:"value"`
}

// Stats info for deployments holds total data for each of the statuses
type DeploymentStatisticsInfo struct {
	// Deployment status
	Status DeploymentStatisticsStatus `json:"status"`
	// Total number of deployments in the given time period
	TotalDeployments *MetricWithTrend `json:"totalDeployments"`
	// Last deployment
	LastDeployment *MetricWithTrend `json:"lastDeployment,omitempty"`
}

// Deployment Status
type DeploymentStatus struct {
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
	// AvailableReplicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
	// ReadyReplicas
	ReadyReplicas *int `json:"readyReplicas,omitempty"`
	// UnavailableReplicas
	UnavailableReplicas *int `json:"unavailableReplicas,omitempty"`
	// UpdatedReplicas
	UpdatedReplicas *int `json:"updatedReplicas,omitempty"`
}

// General stats data
type DoraGeneralStatistics struct {
	// Total
	Total float64 `json:"total"`
}

// General dora metrics stats data
type DoraMetricsGeneralStatistics struct {
	// Deployments
	Deployments *DoraGeneralStatistics `json:"deployments"`
	// Rollback
	Rollbacks *DoraGeneralStatistics `json:"rollbacks"`
	// Failure rate
	FailureRate *DoraGeneralStatistics `json:"failureRate"`
	// Commit / pull request
	CommitOrPullRequests *DoraGeneralStatistics `json:"commitOrPullRequests"`
}

// Stats data for deployment frequency
type DoraStatisticsData struct {
	// Time
	Time string `json:"time"`
	// Number of deployment
	Value float64 `json:"value"`
}

// Stats summery for all dora graphs
type DoraStatisticsSummery struct {
	// Avg
	Summery float64 `json:"summery"`
}

// Dora statistics filter arguments
type DoraStatsFilterArgs struct {
	// Date range
	DateRange *StatisticsDateRangeFilterWithTz `json:"dateRange"`
	// Runtime
	RuntimeName []string `json:"runtimeName,omitempty"`
	// Cluster
	ClusterName []string `json:"clusterName,omitempty"`
	// Cluster Url
	ClusterURL []string `json:"clusterUrl,omitempty"`
	// Application
	Application []string `json:"application,omitempty"`
	// Labels
	Labels []*LabelStringPair `json:"labels,omitempty"`
	// Favorite applications
	Favorite *bool `json:"favorite,omitempty"`
	// App Group
	AppGroup []string `json:"appGroup,omitempty"`
	// Product
	Product []string `json:"product,omitempty"`
	// Environment
	Environment []string `json:"environment,omitempty"`
}

// Args to edit user to account
type EditUserToAccountArgs struct {
	// User email
	UserEmail string `json:"userEmail"`
	// Is user Admin
	IsAdmin bool `json:"isAdmin"`
	// Users chosen sso id
	Sso *string `json:"sso,omitempty"`
	// The user id
	ID string `json:"id"`
	// The current status of this user
	Status string `json:"status"`
}

// Db Entity Reference
type EntityReference struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// Entity Reference Meta
type EntityReferenceMeta struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
}

// Environment Entity
type Environment struct {
	// Entity db id
	ID string `json:"id"`
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// Position of the environment on the dashboard
	Position float64 `json:"position"`
	// List of clusters that belong to this environment
	Clusters []*EnvironmentCluster `json:"clusters"`
	// List of userIds that mark resource as favorite
	Favorites []string `json:"favorites,omitempty"`
	// Is favorite
	Favorite bool `json:"favorite"`
}

func (Environment) IsFavorableNotK8s() {}

func (Environment) IsFavorableNotK8sEntity() {}

// Environment Cluster
type EnvironmentCluster struct {
	// Runtime name
	RuntimeName string `json:"runtimeName"`
	// Cluster name
	Name string `json:"name"`
	// Cluster address
	Server string `json:"server"`
	// Cluster namespaces
	Namespaces []string `json:"namespaces"`
}

// Environment Cluster
type EnvironmentClusterInput struct {
	// Runtime name
	RuntimeName string `json:"runtimeName"`
	// Cluster name
	Name string `json:"name"`
	// Cluster address
	Server string `json:"server"`
	// Cluster namespaces
	Namespaces []string `json:"namespaces"`
}

// EnvironmentConcurrency
type EnvironmentConcurrency struct {
	// Price
	Price *BasePrice `json:"price,omitempty"`
	// Amount
	Amount *int `json:"amount,omitempty"`
	// Min
	Min *int `json:"min,omitempty"`
}

// Args to filter ApplicationGroup
type EnvironmentFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
}

// Error Context
type ErrorContext struct {
	// Repo url
	RepoURL string `json:"repoURL"`
	// Related revision
	Revision string `json:"revision"`
	// Git commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Git commit date
	CommitDate *string `json:"commitDate,omitempty"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// Path to related file
	Path string `json:"path"`
	// Related line
	Line *int `json:"line,omitempty"`
	// Commit url
	CommitURL *string `json:"commitUrl,omitempty"`
	// Commit url with file
	FileURL *string `json:"fileUrl,omitempty"`
}

// Event payload entity
type EventPayload struct {
	// UID of event
	UID *string `json:"uid,omitempty"`
	// Content of the event
	Data *string `json:"data,omitempty"`
	// Time
	Time *string `json:"time,omitempty"`
	// Event source
	EventSource *EventSource `json:"eventSource,omitempty"`
	// Event name
	EventName *string `json:"eventName,omitempty"`
	// Event type
	EventType *string `json:"eventType,omitempty"`
	// Account
	Account *string `json:"account,omitempty"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
}

func (EventPayload) IsEntity() {}

// EventPayload Edge
type EventPayloadEdge struct {
	// Node contains the actual event payload data
	Node *EventPayload `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventPayloadEdge) IsEdge() {}

// EventPayloadReadModelEventPayload type
type EventPayloadReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (EventPayloadReadModelEventPayload) IsReadModelEventPayload() {}

// EventPayload Slice
type EventPayloadSlice struct {
	// EventPayload edges
	Edges []*EventPayloadEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventPayloadSlice) IsSlice() {}

// Event source entity
type EventSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the event-source
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
}

func (EventSource) IsBaseEntity() {}

func (EventSource) IsGitopsEntity() {}

func (EventSource) IsProjectBasedEntity() {}

func (EventSource) IsEntity() {}

// Event source Edge
type EventSourceEdge struct {
	// Node contains the actual event source data
	Node *EventSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (EventSourceEdge) IsEdge() {}

// EventSourceReadModelEventPayload type
type EventSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (EventSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Event source Slice
type EventSourceSlice struct {
	// Event source edges
	Edges []*EventSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (EventSourceSlice) IsSlice() {}

// Event source type
type EventSourceType struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// List of the supported events by this event source type. CAP know how to filter this kind of events.
	Events []*SupportedEventMapping `json:"events"`
}

// Args to set favorite for entity
type FavoriteInfoArgs struct {
	// Event-source kind
	Kind string `json:"kind"`
	// Event-source group
	Group string `json:"group"`
	// Event-source group
	Version string `json:"version"`
	// Event-source runtime name
	Runtime string `json:"runtime"`
	// Event-source name
	Name string `json:"name"`
	// Event-source namespace
	Namespace *string `json:"namespace,omitempty"`
	// Event-source cluster URL
	Cluster *string `json:"cluster,omitempty"`
}

// FileSource entity
type FileSource struct {
	// File path
	File string `json:"file"`
	// JSON path to the value in the file
	JSONPath string `json:"jsonPath"`
}

// Flow step
type FlowStep struct {
	// Environment name
	Environment string `json:"environment"`
	// DependsOn array
	DependsOn []string `json:"dependsOn"`
	// Policy
	Policy *PromotionPolicyDefinition `json:"policy,omitempty"`
}

// From State Entity
type FromState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Returns runtimes and clusters statistics
type GeneralStatistics struct {
	// Runtimes statistics
	Runtimes *RuntimesStatistics `json:"runtimes"`
	// Clusters statistics
	Clusters *ClustersStatistics `json:"clusters"`
}

// Generic entity
type GenericEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
}

func (GenericEntity) IsGitopsEntity() {}

func (GenericEntity) IsBaseEntity() {}

func (GenericEntity) IsProjectBasedEntity() {}

func (GenericEntity) IsEntity() {}

// GenericEntity Edge
type GenericEntityEdge struct {
	// Node contains the actual app-project data
	Node *GenericEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GenericEntityEdge) IsEdge() {}

// GenericEntity Slice
type GenericEntitySlice struct {
	// GenericEntity edges
	Edges []*GenericEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GenericEntitySlice) IsSlice() {}

// Argo events generic Error Notification
type GenericErrorNotification struct {
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Notification type
	Type *string `json:"type,omitempty"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
}

func (GenericErrorNotification) IsNotification() {}

func (GenericErrorNotification) IsArgoEventsNotification() {}

// GitAuthConfig
type GitAuthConfig struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata,omitempty"`
	// Data
	Data *GitAuthProvidersData `json:"data,omitempty"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Entity source
	Source *GitConfigEntitySource `json:"source,omitempty"`
}

// GitAuthConfig form data object
type GitAuthConfigFormData struct {
	// Metadata
	Metadata *ConfigMapMetadata `json:"metadata,omitempty"`
	// Data
	Data *GitAuthProvidersData `json:"data"`
	// Sync status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
}

// GitAuthConfig form input data object
type GitAuthConfigFormInputData struct {
	// Metadata
	Metadata *GitAuthConfigFormInputMetadata `json:"metadata,omitempty"`
	// Data
	Data *GitAuthProviderDataInput `json:"data"`
}

// GitAuthConfig form metadata
type GitAuthConfigFormInputMetadata struct {
	// GitAuthConfig name
	Name *string `json:"name,omitempty"`
	// GitAuthConfig namespace
	Namespace *string `json:"namespace,omitempty"`
	// GitAuthConfig runtime
	Runtime *string `json:"runtime,omitempty"`
}

// GitAuthProviderConfigData
type GitAuthProviderConfig struct {
	// Provider
	Provider string `json:"provider"`
	// Mode
	Mode GitAuthMode `json:"mode"`
	// AppName
	AppName *string `json:"appName,omitempty"`
	// Secret
	Secret *SecretData `json:"secret,omitempty"`
}

// GitAuthProviderConfig input data object
type GitAuthProviderConfigInput struct {
	// Provider
	Provider string `json:"provider"`
	// Mode
	Mode GitAuthMode `json:"mode"`
	// AppName
	AppName *string `json:"appName,omitempty"`
	// Secret
	Secret *SecretDataInput `json:"secret,omitempty"`
}

// GitAuthProviderData input data object
type GitAuthProviderDataInput struct {
	// Config
	Config *GitAuthProviderConfigInput `json:"config"`
}

// GitAuthProvidersData
type GitAuthProvidersData struct {
	// Config
	Config *GitAuthProviderConfig `json:"config,omitempty"`
}

// GitConfigEntitySource
type GitConfigEntitySource struct {
	// GitSource
	GitSource *string `json:"gitSource,omitempty"`
	// RepoURL
	RepoURL *string `json:"repoURL,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Revision
	Revision *string `json:"revision,omitempty"`
	// CommitMessage
	CommitMessage *string `json:"commitMessage,omitempty"`
	// CommitDate
	CommitDate *string `json:"commitDate,omitempty"`
	// CommitAuthor
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// SyncStartedAt
	SyncStartedAt *string `json:"syncStartedAt,omitempty"`
	// SyncFinishedAt
	SyncFinishedAt *string `json:"syncFinishedAt,omitempty"`
	// ResourceAction
	ResourceAction *ResourceAction `json:"resourceAction,omitempty"`
}

// GitOps Edge
type GitOpsEdge struct {
	// Node contains the actual component data
	Node GitopsEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// GitOps settings
type GitOpsSettings struct {
	// Account id
	AccountID string `json:"accountId"`
	// Is hide runtime hosted boxes in ui
	IsHideHostedRuntimeBoxes bool `json:"isHideHostedRuntimeBoxes"`
}

// GitOpsSettings Input
type GitOpsSettingsInput struct {
	// isHideHostedRuntimeBoxes flag to show/hide hosted runtime boxes in UI
	IsHideHostedRuntimeBoxes *bool `json:"isHideHostedRuntimeBoxes,omitempty"`
}

// GitOps Slice
type GitOpsSlice struct {
	// GitOps edges
	Edges []*GitOpsEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// "PR data
type GitPr struct {
	// PR action
	Action string `json:"action"`
	// PR id
	ID string `json:"id"`
	// PR title
	Title string `json:"title"`
	// PR url
	URL string `json:"url"`
	// PR number
	Number int `json:"number"`
	// PR labels
	Labels []string `json:"labels"`
	// PR head
	Head *GitPushCommitRevision `json:"head"`
	// PR target
	Target *GitPushCommitTargetRevision `json:"target"`
	// Indicates if a PR was merged
	Merged *bool `json:"merged,omitempty"`
	// Indicates if a PR comes  from forked repo
	Fork *GitPrFork `json:"fork,omitempty"`
	// PR comment
	Comment *GitPRComment `json:"comment,omitempty"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles,omitempty"`
}

// "PR Comment data
type GitPRComment struct {
	// Comment message
	Message string `json:"message"`
	// Comment author
	Author string `json:"author"`
	// Comment author association
	AuthorAssociation *string `json:"authorAssociation,omitempty"`
}

// "PR event
type GitPREventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// PR data
	Pr *GitPr `json:"pr,omitempty"`
}

func (GitPREventPayloadData) IsCommonGitEventPayloadData() {}

func (GitPREventPayloadData) IsEventPayloadData() {}

// "PR fork data
type GitPrFork struct {
	// Repository
	Repository *WorkflowRepository `json:"repository"`
}

// "Push commit event data
type GitPushCommit struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Push revision
	Head *GitPushCommitRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles,omitempty"`
}

func (GitPushCommit) IsGitPush() {}

// "Commit revision data
type GitPushCommitRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "PR target commit revision data
type GitPushCommitTargetRevision struct {
	// Branch name
	Branch string `json:"branch"`
	// Branch URL
	BranchURL string `json:"branchURL"`
	// SHA
	Sha *string `json:"sha,omitempty"`
	// SHA URL
	ShaURL *string `json:"shaURL,omitempty"`
}

// "Push event
type GitPushEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// Push data
	Push GitPush `json:"push"`
}

func (GitPushEventPayloadData) IsCommonGitEventPayloadData() {}

func (GitPushEventPayloadData) IsEventPayloadData() {}

// "Push commit event data
type GitPushTag struct {
	// Commit message
	Message string `json:"message"`
	// Commit url
	URL string `json:"url"`
	// Tag revision
	Head *GitPushTagRevision `json:"head"`
	// Push subject type
	SubjectType GitPushPayloadDataTypes `json:"subjectType"`
	// Modified files
	ModifiedFiles []string `json:"modifiedFiles,omitempty"`
}

func (GitPushTag) IsGitPush() {}

// "Tag revision data
type GitPushTagRevision struct {
	// Tag name
	Tag string `json:"tag"`
	// Tag URL
	TagURL string `json:"tagURL"`
	// SHA
	Sha string `json:"sha"`
	// SHA URL
	ShaURL string `json:"shaURL"`
}

// "Release data
type GitRelease struct {
	// Release action
	Action string `json:"action"`
	// Release id
	ID string `json:"id"`
	// Release name
	Name string `json:"name"`
	// Release tag name
	TagName string `json:"tagName"`
	// Indicates if current release is a pre release
	IsPreRelease bool `json:"isPreRelease"`
}

// "Release event
type GitReleaseEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// Release data
	Release *GitRelease `json:"release,omitempty"`
}

func (GitReleaseEventPayloadData) IsCommonGitEventPayloadData() {}

func (GitReleaseEventPayloadData) IsEventPayloadData() {}

// Git source entity
type GitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Application `json:"self,omitempty"`
	// History of the GitSource
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Is this a restricted git-source
	IsRestricted bool `json:"isRestricted"`
	// Restricted Git Source details
	RestrictedDetails *RestrictedGitSourceDetails `json:"restrictedDetails,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Permissions to this git source
	Permissions []*Permission `json:"permissions"`
}

func (GitSource) IsK8sLogicEntity() {}

func (GitSource) IsBaseEntity() {}

func (GitSource) IsProjectBasedEntity() {}

func (GitSource) IsEntity() {}

// Git source Edge
type GitSourceEdge struct {
	// Node contains the actual git source data
	Node *GitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (GitSourceEdge) IsEdge() {}

// Git Source Notification
type GitSourceNotification struct {
	// Commit information that triggered sync
	Source *GitopsEntitySource `json:"source,omitempty"`
	// Link to the git-source in git provider
	GsRepoLink *string `json:"gsRepoLink,omitempty"`
	// Sync status
	GsSyncStatus SyncStatus `json:"gsSyncStatus"`
	// Revision
	Revision string `json:"revision"`
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (GitSourceNotification) IsNotification() {}

func (GitSourceNotification) IsArgoCDNotification() {}

func (GitSourceNotification) IsGitOpsNotification() {}

// GitSourceReadModelEventPayload type
type GitSourceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (GitSourceReadModelEventPayload) IsReadModelEventPayload() {}

// Git source Slice
type GitSourceSlice struct {
	// Git source edges
	Edges []*GitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (GitSourceSlice) IsSlice() {}

// "Unknown Git event
type GitUnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Name of the git event
	Event string `json:"event"`
	// Git provider
	Provider string `json:"provider"`
	// Repository
	Repository *WorkflowRepository `json:"repository"`
	// Event timestamp
	Timestamp *string `json:"timestamp,omitempty"`
	// Event initiator
	Initiator *Initiator `json:"initiator"`
}

func (GitUnknownEventPayloadData) IsCommonGitEventPayloadData() {}

func (GitUnknownEventPayloadData) IsEventPayloadData() {}

// Github event
type GithubEvent struct {
	// Name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository names
	Repositories []string `json:"repositories"`
	// Webhook events
	Events []string `json:"events"`
}

func (GithubEvent) IsEvent() {}

// Github trigger conditions
type GithubTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Base url for github enterprise
	BaseURL *string `json:"baseUrl,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters chosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Github trigger conditions
type GithubTriggerConditionsArgs struct {
	// Specific github event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Base url for github enterprise
	BaseURL *string `json:"baseUrl,omitempty"`
	// Repositories
	Repositories []*string `json:"repositories"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// Gitlab trigger conditions
type GitlabTriggerConditions struct {
	// Event type from mapping (push, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Gitlab enterprise url
	BaseURL *string `json:"baseUrl,omitempty"`
	// Filters for this trigger condition
	Filters *TriggerConditionFilters `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameter `json:"parameters"`
}

// Gitlab trigger conditions
type GitlabTriggerConditionsArgs struct {
	// Specific gitlab event (push, push.heads, pull_request etc.)
	EventType string `json:"eventType"`
	// EventSource name (for backward converting from trigger conditions)
	EventSource *string `json:"eventSource,omitempty"`
	// EventSource event name (for backward converting from trigger conditions)
	EventSourceEvent *string `json:"eventSourceEvent,omitempty"`
	// Dependency name (for backward converting from trigger conditions)
	Dependency *string `json:"dependency,omitempty"`
	// Repositories
	Repositories []string `json:"repositories"`
	// Base url
	BaseURL *string `json:"baseUrl,omitempty"`
	// Filters for this trigger condition
	Filters *TriggerConditionFiltersArgs `json:"filters"`
	// Parameters choosen for each event type (push, pull_request...)
	Parameters []*TriggerConditionParameterArgs `json:"parameters"`
	// serverCertSecret refers the secret that contains the server cert.
	ServerCertSecret *SecretKeySelector `json:"serverCertSecret,omitempty"`
}

// Gitops entity source
type GitopsEntitySource struct {
	// Entity source
	GitSource *GitSource `json:"gitSource,omitempty"`
	// Repo URL
	RepoURL *string `json:"repoURL,omitempty"`
	// Path
	Path *string `json:"path,omitempty"`
	// Full web url to file in commit
	FileURL *string `json:"fileURL,omitempty"`
	// Git revision
	Revision *string `json:"revision,omitempty"`
	// Git commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Git commit date
	CommitDate *string `json:"commitDate,omitempty"`
	// Git commit web url
	CommitURL *string `json:"commitURL,omitempty"`
	// Git commit author
	CommitAuthor *string `json:"commitAuthor,omitempty"`
	// Author web profile url
	ProfileURL *string `json:"profileURL,omitempty"`
	// Author avatar url
	AvatarURL *string `json:"avatarURL,omitempty"`
	// Git manifest
	GitManifest *string `json:"gitManifest,omitempty"`
	// The resource action
	ResourceAction *ResourceAction `json:"resourceAction,omitempty"`
}

// Gitops Release Entity
type GitopsRelease struct {
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
	// History id
	HistoryID int `json:"historyId"`
	// Related argocd history id
	ArgoHistoryID *int `json:"argoHistoryId,omitempty"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Operation State (argo)
	OperationState *ApplicationOperationState `json:"operationState,omitempty"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState,omitempty"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
	// Current release flag
	Current *bool `json:"current,omitempty"`
}

// Args to define application
type GitopsReleaseApplicationArgs struct {
	// App Group name
	AppGroupName *string `json:"appGroupName,omitempty"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Group
	Group *string `json:"group,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
	// Kind
	Kind *string `json:"kind,omitempty"`
}

// Gitops Release chart record
type GitopsReleaseChartRecord struct {
	// Date
	Date string `json:"date"`
	// Date
	Releases []*GitopsReleaseChartRelease `json:"releases"`
}

// Gitops Release chart release
type GitopsReleaseChartRelease struct {
	// Date
	SyncStartedAt *string `json:"syncStartedAt,omitempty"`
	// Health status
	HealthStatus HealthStatus `json:"healthStatus"`
	// History id
	HistoryID int `json:"historyId"`
	// Object metadata
	ApplicationMetadata *ObjectMeta `json:"applicationMetadata"`
}

// Release Edge
type GitopsReleaseEdge struct {
	// Node contains the actual application data
	Node *GitopsRelease `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Args to filter release
type GitopsReleaseFilterArgs struct {
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Group
	Group *string `json:"group,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
	// Kind
	Kind *string `json:"kind,omitempty"`
	// HistoryId
	HistoryID *int `json:"historyId,omitempty"`
	// Issue key
	IssueKey *string `json:"issueKey,omitempty"`
	// PR key
	PrKey *string `json:"prKey,omitempty"`
	// Committer
	Committer *string `json:"committer,omitempty"`
	// Issue key array
	IssueKeys []string `json:"issueKeys,omitempty"`
	// PR key array
	PrKeys []string `json:"prKeys,omitempty"`
	// Committers array
	Committers []string `json:"committers,omitempty"`
	// Filter workflows from a specific start date
	SyncStartDateFrom *string `json:"syncStartDateFrom,omitempty"`
	// Filter workflows to a specific start date
	SyncStartDateTo *string `json:"syncStartDateTo,omitempty"`
	// Start date
	StartDate *string `json:"startDate,omitempty"`
	// End date
	EndDate *string `json:"endDate,omitempty"`
	// Jira report filter
	JiraReportFilter *bool `json:"jiraReportFilter,omitempty"`
	// App Group name
	AppGroupName *string `json:"appGroupName,omitempty"`
}

// Gitops Release Slice
type GitopsReleaseSlice struct {
	// Release edges
	Edges []*GitopsReleaseEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Gitops releases sorting arguments
type GitopsReleaseSortArg struct {
	// Field for sorting
	Field GitopsReleasesSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// GoogleSSO
type GoogleSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// ClientHost
	ClientHost *string `json:"clientHost,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Keyfile
	Keyfile *string `json:"keyfile,omitempty"`
	// Subject
	Subject *string `json:"subject,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// SyncField
	SyncField *string `json:"syncField,omitempty"`
}

func (GoogleSso) IsIDP() {}

// Health Error
type HealthError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion,omitempty"`
	// The entity related to this error
	Object BaseEntity `json:"object,omitempty"`
	// Error code
	Code HealthErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
}

func (HealthError) IsError() {}

// Health Error Input
type HealthErrorInput struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Message
	Message string `json:"message"`
}

// Workflow template ref Hierarchy
type HierarchyRef struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Ref line number
	Line *int `json:"line,omitempty"`
}

// WorkflowTemplate Hierarchy Step
type HierarchyStep struct {
	// Step name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line,omitempty"`
}

// WorkflowTemplate Steps Template
type HierarchyTemplate struct {
	// Template name
	Name string `json:"name"`
	// Line number of the step
	Line *int `json:"line,omitempty"`
	// Steps
	Steps []*HierarchyStep `json:"steps,omitempty"`
}

// WorkflowTemplate templates hierarchy
type HierarchyTemplates struct {
	// WorkflowTemlate name
	Name *string `json:"name,omitempty"`
	// WorkflowTemlate name line number
	Line *int `json:"line,omitempty"`
	// WorkflowTemplate templates structer heiarchy
	Steps []*HierarchyTemplate `json:"steps,omitempty"`
	// WorkflowTemplate templates structer heiarchy
	Refs []*HierarchyRef `json:"refs,omitempty"`
}

// History arguments
type HistoryArgs struct {
	// History Pagination arguments
	Pagination []*CompositeSlicePaginationArgs `json:"pagination,omitempty"`
	// Page Size
	PageSize *int `json:"pageSize,omitempty"`
	// Sync Success - SUCCESS/FAILURE
	SyncSuccess *SyncSuccess `json:"syncSuccess,omitempty"`
	// Repo
	Repo *string `json:"repo,omitempty"`
}

// Image application
type ImageApplication struct {
	// Application Ref metadata
	ApplicationRef *ObjectMeta `json:"applicationRef"`
	// Argo CD application destination config
	ApplicationDestination *ArgoCDApplicationDestination `json:"applicationDestination,omitempty"`
	// Application git info
	ApplicationGitInfo *ImageApplicationGitInfo `json:"applicationGitInfo,omitempty"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Image service name
	ServiceName *string `json:"serviceName,omitempty"`
	// Related binary
	Binary *ImageBinary `json:"binary,omitempty"`
	// Currently deployed
	CurrentlyDeployed bool `json:"currentlyDeployed"`
	// Image name
	ImageName *string `json:"imageName,omitempty"`
	// Image registry domain
	ImageRegistryDomain ImageRegistryType `json:"imageRegistryDomain"`
}

// Application Commit Author
type ImageApplicationCommitAuthor struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Profile Url
	ProfileURL *string `json:"profileUrl,omitempty"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// Image Application Git Info
type ImageApplicationGitInfo struct {
	// Git repo url
	RepoURL *string `json:"repoURL,omitempty"`
	// Git branch
	Branch *string `json:"branch,omitempty"`
	// Commit author
	Author *ImageApplicationCommitAuthor `json:"author,omitempty"`
	// Commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// Commit url
	CommitURL *string `json:"commitUrl,omitempty"`
}

// Image binary info
type ImageBinariesInfo struct {
	// ImageBinaries
	Images []*ImageBinary `json:"images"`
	// PRs annotations
	Prs []*Annotation `json:"prs,omitempty"`
	// Issues annotations
	Issues []*Annotation `json:"issues,omitempty"`
	// Generic annotations
	Annotations []*Annotation `json:"annotations,omitempty"`
	// Dockerfile
	DockerFile *string `json:"dockerFile,omitempty"`
	// Branch
	Branch *string `json:"branch,omitempty"`
	// Commit
	Commit *string `json:"commit,omitempty"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	// CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	// Git repository
	GitRepository *string `json:"gitRepository,omitempty"`
	//  Runtime
	Runtime *RuntimeInfo `json:"runtime,omitempty"`
	// Author
	Author *ImageBinaryAuthor `json:"author,omitempty"`
}

// Image binary entity
type ImageBinary struct {
	//  Runtime
	Runtime *RuntimeInfo `json:"runtime,omitempty"`
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// ImageName
	ImageName string `json:"imageName"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Branch
	Branch *string `json:"branch,omitempty"`
	// Commit
	Commit *string `json:"commit,omitempty"`
	// CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	// CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	// Git repository
	GitRepository *string `json:"gitRepository,omitempty"`
	// Git provider
	GitProvider *string `json:"gitProvider,omitempty"`
	//  AccountId
	AccountID string `json:"accountId"`
	//  DockerFile
	DockerFile *string `json:"dockerFile,omitempty"`
	// Size
	Size *float64 `json:"size,omitempty"`
	// OS
	Os *string `json:"os,omitempty"`
	// Architecture
	Architecture *string `json:"architecture,omitempty"`
	// Info
	Info *string `json:"info,omitempty"`
	// Author
	Author *ImageBinaryAuthor `json:"author,omitempty"`
	// Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CI provider
	CiProvider *string `json:"ciProvider,omitempty"`
	// Logs url
	LogsURL *string `json:"logsUrl,omitempty"`
	// Image registry
	ImageRegistryDomains []ImageRegistryType `json:"imageRegistryDomains"`
	// Image hash
	Hash *string `json:"hash,omitempty"`
	// Image internal ID
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Image repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Image domain
	ImageDomain ImageRegistryType `json:"imageDomain"`
}

func (ImageBinary) IsEntity() {}

// ImageBinaryAuthor
type ImageBinaryAuthor struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Full name
	FullName *string `json:"fullName,omitempty"`
	// Profile Url
	ProfileURL *string `json:"profileUrl,omitempty"`
	// Avatar Url
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// ImageBinaryAuthorInput
type ImageBinaryAuthorInput struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Avatar URL
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// ImageBinaryAuthorOutput
type ImageBinaryAuthorOutput struct {
	// Username
	Username *string `json:"username,omitempty"`
	// Avatar URL
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

// Image Binary Edge
type ImageBinaryEdge struct {
	// Node contains the actual image binary data
	Node *ImageBinary `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageBinaryEdge) IsEdge() {}

// ImageBinaryInput
type ImageBinaryInput struct {
	//  Id
	ID string `json:"id"`
	//  Created
	Created string `json:"created"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch,omitempty"`
	//  Commit
	Commit *string `json:"commit,omitempty"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	//  CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	//  DockerFile
	DockerFile *string `json:"dockerFile,omitempty"`
	//  Size
	Size *float64 `json:"size,omitempty"`
	//  Os
	Os *string `json:"os,omitempty"`
	//  Architecture
	Architecture *string `json:"architecture,omitempty"`
	//  Info
	Info *string `json:"info,omitempty"`
	//  Info
	Author *ImageBinaryAuthorInput `json:"author,omitempty"`
	//  Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// Logs url
	LogsURL *string `json:"logsUrl,omitempty"`
	// Image hash
	Hash *string `json:"hash,omitempty"`
	// Image internal ID
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Image repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
}

// ImageBinaryOutput
type ImageBinaryOutput struct {
	//  Id
	ID string `json:"id"`
	//  ImageName
	ImageName string `json:"imageName"`
	//  Branch
	Branch *string `json:"branch,omitempty"`
	//  Commit
	Commit *string `json:"commit,omitempty"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	//  CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	//  DockerFile
	DockerFile *string `json:"dockerFile,omitempty"`
	//  Size
	Size *float64 `json:"size,omitempty"`
	//  Os
	Os *string `json:"os,omitempty"`
	//  Architecture
	Architecture *string `json:"architecture,omitempty"`
	//  Info
	Info *string `json:"info,omitempty"`
	//  Info
	Author *ImageBinaryAuthorOutput `json:"author,omitempty"`
	//  Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CI provider
	CiProvider *string `json:"ciProvider,omitempty"`
	// Logs url
	LogsURL *string `json:"logsUrl,omitempty"`
	// Image hash
	Hash *string `json:"hash,omitempty"`
	// Image internal ID
	InternalImageID *string `json:"internalImageId,omitempty"`
	// Image repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
}

// ImageBinaryPatch
type ImageBinaryPatchInput struct {
	//  Branch
	Branch *string `json:"branch,omitempty"`
	//  Commit
	Commit *string `json:"commit,omitempty"`
	//  CommitMsg
	CommitMsg *string `json:"commitMsg,omitempty"`
	//  CommitURL
	CommitURL *string `json:"commitURL,omitempty"`
	// Git provider
	GitProvider *string `json:"gitProvider,omitempty"`
	//  DockerFile
	DockerFile *string `json:"dockerFile,omitempty"`
	//  Size
	Size *float64 `json:"size,omitempty"`
	//  Os
	Os *string `json:"os,omitempty"`
	//  Architecture
	Architecture *string `json:"architecture,omitempty"`
	//  Info
	Info *string `json:"info,omitempty"`
	//  Info
	Author *ImageBinaryAuthorInput `json:"author,omitempty"`
	//  Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// Logs url
	LogsURL *string `json:"logsUrl,omitempty"`
}

// Images Binary Slice
type ImageBinarySlice struct {
	// Image edges
	Edges []*ImageBinaryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageBinarySlice) IsSlice() {}

// Image Details
type ImageDetails struct {
	// Image name
	Name *string `json:"name,omitempty"`
	// Registry type
	Type *ImageRegistryType `json:"type,omitempty"`
	// Link
	Link *string `json:"link,omitempty"`
}

// ImageLayerInput
type ImageLayerInput struct {
	// Created
	Created string `json:"created"`
	// Instruction
	Instruction string `json:"instruction"`
	// Size
	Size float64 `json:"size"`
	// Args
	Args *string `json:"args,omitempty"`
}

// ImageLayerOutput
type ImageLayerOutput struct {
	// Created
	Created string `json:"created"`
	// Instruction
	Instruction string `json:"instruction"`
	// Size
	Size float64 `json:"size"`
	// Args
	Args *string `json:"args,omitempty"`
}

// Image layers filter arguments
type ImageLayersFilterArgs struct {
	// Filter by image
	Image string `json:"image"`
}

// ImageLayersInput
type ImageLayersInput struct {
	// Image
	Image string `json:"image"`
	// LayerDigests
	LayerDigests []string `json:"layerDigests,omitempty"`
	// Layers
	Layers []*ImageLayerInput `json:"layers"`
}

// ImageLayersOutput
type ImageLayersOutput struct {
	// AccountId
	AccountID string `json:"accountId"`
	// Created
	Created string `json:"created"`
	// Image
	Image string `json:"image"`
	// LayerDigests
	LayerDigests []string `json:"layerDigests,omitempty"`
	// Layers
	Layers []*ImageLayerOutput `json:"layers"`
}

// Image Registry entity
type ImageRegistry struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	//  AccountId
	AccountID string `json:"accountId"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Tags
	Tags []*ImageTag `json:"tags"`
	// Registry
	Registry *Registry `json:"registry"`
	// Image internal id
	InternalImageID *string `json:"internalImageId,omitempty"`
}

func (ImageRegistry) IsEntity() {}

// Image Registry Edge
type ImageRegistryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRegistry `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRegistryEdge) IsEdge() {}

// ImageRegistryInput
type ImageRegistryInput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName string `json:"imageName"`
	// Repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Tags
	Tags []*ImageTagInput `json:"tags,omitempty"`
	// Registry
	Registry *RegistryInput `json:"registry,omitempty"`
	// Image internal id
	InternalImageID *string `json:"internalImageId,omitempty"`
}

// ImageRegistryOutput
type ImageRegistryOutput struct {
	// Binary Id
	BinaryID string `json:"binaryId"`
	// Created
	Created string `json:"created"`
	// Image name
	ImageName *string `json:"imageName,omitempty"`
	// Repo digest
	RepoDigest *string `json:"repoDigest,omitempty"`
	// Tags
	Tags []*ImageTagOutput `json:"tags,omitempty"`
	// Registry
	Registry *RegistryOutput `json:"registry,omitempty"`
	// Image internal id
	InternalImageID *string `json:"internalImageId,omitempty"`
}

// Images Registry Slice
type ImageRegistrySlice struct {
	// Image registry edges
	Edges []*ImageRegistryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRegistrySlice) IsSlice() {}

// Image Repo Tag entity
type ImageRepoTag struct {
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Tag
	Tag string `json:"tag"`
	// Created Date
	Created string `json:"created"`
	// Related binaries
	Binaries []*ImageBinary `json:"binaries,omitempty"`
	// Image applications
	Applications []*ImageApplication `json:"applications,omitempty"`
}

func (ImageRepoTag) IsEntity() {}

// Image repo tag Edge
type ImageRepoTagEdge struct {
	// Node contains the actual image repo tag data
	Node *ImageRepoTag `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepoTagEdge) IsEdge() {}

// Image repo tags filter arguments
type ImageRepoTagFilterArgs struct {
	// Filter image repo tags by image name
	RepositoryName string `json:"repositoryName"`
	// Filter image repo tags by tag
	Tag *string `json:"tag,omitempty"`
	// Filter image repo tags by registry type
	RegistryTypes []ImageRegistryType `json:"registryTypes,omitempty"`
	// Filter image repo tags by git branch
	GitBranch *string `json:"gitBranch,omitempty"`
	// Filter image repo tags by git repositories
	GitRepositories []string `json:"gitRepositories,omitempty"`
	// Filter image repositories by deployed application names
	DeployedApplications []string `json:"deployedApplications,omitempty"`
	// Filter image repo tags by currently deployed apps flag
	CurrentlyDeployed *bool `json:"currentlyDeployed,omitempty"`
}

// Images repo tag Slice
type ImageRepoTagSlice struct {
	// Image Repository edges
	Edges []*ImageRepoTagEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepoTagSlice) IsSlice() {}

// Image repository sorting arguments
type ImageRepoTagSortArg struct {
	// Field for sorting
	Field ImageRepoTagSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Image Repository entity
type ImageRepository struct {
	// Image repository name
	Name string `json:"name"`
	// Account Id
	AccountID string `json:"accountId"`
	// Last update
	LastUpdate string `json:"lastUpdate"`
	// Image repository registry domain types
	RegistryDomains []ImageRegistryType `json:"registryDomains"`
	// Image applications
	Applications []*ImageApplication `json:"applications"`
}

func (ImageRepository) IsEntity() {}

// Image Repository Edge
type ImageRepositoryEdge struct {
	// Node contains the actual image registry data
	Node *ImageRepository `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ImageRepositoryEdge) IsEdge() {}

// Image repository filter arguments
type ImageRepositoryFilterArgs struct {
	// Filter image repositories by image repository name
	Name *string `json:"name,omitempty"`
	// Filter image repositories by image repository names array
	Names []string `json:"names,omitempty"`
	// Filter image repositories by tag
	Tag *string `json:"tag,omitempty"`
	// Filter image repositories by registry type
	RegistryTypes []ImageRegistryType `json:"registryTypes,omitempty"`
	// Filter image repositories by git branch
	GitBranch *string `json:"gitBranch,omitempty"`
	// Filter image repositories by git repositories
	GitRepositories []string `json:"gitRepositories,omitempty"`
	// Filter image repositories by deployed application names
	DeployedApplications []string `json:"deployedApplications,omitempty"`
	// Filter image repositories by currently deployed apps flag
	CurrentlyDeployed *bool `json:"currentlyDeployed,omitempty"`
}

// Images Repository Slice
type ImageRepositorySlice struct {
	// Image Repository edges
	Edges []*ImageRepositoryEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ImageRepositorySlice) IsSlice() {}

// Image repository sorting arguments
type ImageRepositorySortArg struct {
	// Field for sorting
	Field ImageRepositorySortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// ImageTag
type ImageTag struct {
	// Registry
	Registry *string `json:"registry,omitempty"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagInput struct {
	// Registry
	Registry *string `json:"registry,omitempty"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// ImageTagInput
type ImageTagOutput struct {
	// Registry
	Registry *string `json:"registry,omitempty"`
	// Tag
	Tag string `json:"tag"`
	// Created
	Created string `json:"created"`
}

// Images Entity
type Images struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Image
	Image *string `json:"image,omitempty"`
	// RepositoryName
	RepositoryName *string `json:"repositoryName,omitempty"`
	// BinaryId
	BinaryID *string `json:"binaryId,omitempty"`
	// WorkflowName
	WorkflowName *string `json:"workflowName,omitempty"`
	// WorkflowUrl
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CiProvider
	CiProvider *string `json:"ciProvider,omitempty"`
}

// Ingress
type Ingress struct {
	// Hostname
	Hostname *string `json:"hostname,omitempty"`
	// Ip
	IP *string `json:"ip,omitempty"`
}

// "Event initiator
type Initiator struct {
	// Git user username
	UserName string `json:"userName"`
	// Git user id
	UserID string `json:"userId"`
	// Git user email
	UserEmail string `json:"userEmail"`
	// Link to the user avatar image
	UserAvatarURL string `json:"userAvatarUrl"`
	// Link to the user git profile
	UserProfileURL string `json:"userProfileUrl"`
}

// Input for Argo CD Application destination config
type InputArgoCDApplicationDestination struct {
	// Cluster name
	Name *string `json:"name,omitempty"`
	// Cluster url
	Server *string `json:"server,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Integration entity
type IntegrationConfig struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self,omitempty"`
	// Integration Type
	IntegrationType string `json:"integrationType"`
	// Integration Type
	ProviderInfo *string `json:"providerInfo,omitempty"`
}

func (IntegrationConfig) IsBaseEntity() {}

func (IntegrationConfig) IsGitopsEntity() {}

func (IntegrationConfig) IsProjectBasedEntity() {}

// Application Edge
type IntegrationEdge struct {
	// Node contains the actual application data
	Node *IntegrationEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Integration
type IntegrationEntity struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Integration type usually consists of `<type>.<subtype>`, for example `issue.jira`.
	//
	// Take a look on libs/db/src/entities/common/integration/operation-state.types.ts to see the allowed values
	Type *string `json:"type,omitempty"`
	// Provider info contains all non-secure data related to the integration,
	// for example `host` and `username` for `registry.quay` integration.
	//
	// Depends on the integration `type`
	ProviderInfo *string `json:"providerInfo,omitempty"`
	// Runtimes
	Runtimes []string `json:"runtimes,omitempty"`
	// Sync Status
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
	// All runtimes enabled
	IsAllRuntimes *bool `json:"isAllRuntimes,omitempty"`
	// Enabled integration consumers
	EnabledIntegrationConsumers []*IntegrationConsumer `json:"enabledIntegrationConsumers,omitempty"`
}

// Args to filter annotation
type IntegrationFilterArgs struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Integration type usually consists of `<type>.<subtype>`, for example `issue.jira`.
	//
	// Take a look on libs/db/src/entities/common/integration/operation-state.types.ts to see the allowed values
	Type *string `json:"type,omitempty"`
	// Category type
	CategoryType *string `json:"categoryType,omitempty"`
	// Ci tool
	CiTool *SupportedCITools `json:"ciTool,omitempty"`
	// Runtime name
	Runtime *string `json:"runtime,omitempty"`
	// Include default integrations
	IncludeDefaultIntegrations *bool `json:"includeDefaultIntegrations,omitempty"`
	// Enabled Integration Consumers
	EnabledIntegrationConsumers []*IntegrationConsumer `json:"enabledIntegrationConsumers,omitempty"`
	// Exclude not supported enrichment integrations
	ExcludeNotSupportedEnrichment *bool `json:"excludeNotSupportedEnrichment,omitempty"`
}

// IntegrationGenerationInput
type IntegrationGenerationInput struct {
	// Metadata
	Metadata *IntegrationGenerationMetadata `json:"metadata"`
	// Provider info
	ProviderInfo string `json:"providerInfo"`
	// Intended operation over integration
	Operation ResourceOperation `json:"operation"`
	// Yaml containing encrypted sealed secret
	SealedSecretYaml *string `json:"sealedSecretYaml,omitempty"`
}

// IntegrationGenerationInput
type IntegrationGenerationMetadata struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
	// Runtimes
	Runtimes []string `json:"runtimes"`
	// IsAllRuntimes
	IsAllRuntimes bool `json:"isAllRuntimes"`
	// Enabled Integration Consumers
	EnabledIntegrationConsumers []*IntegrationConsumer `json:"enabledIntegrationConsumers,omitempty"`
}

// IntegrationGenerationInput
type IntegrationGenerationOutput struct {
	// Operations
	Operations []*RuntimeOperation `json:"operations"`
	// Manifests
	Manifests []*ResourceManifest `json:"manifests"`
}

// IntegrationReadModelEventPayload type
type IntegrationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (IntegrationReadModelEventPayload) IsReadModelEventPayload() {}

// Integration entity
type IntegrationSecret struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self,omitempty"`
	// Integration Type
	IntegrationType string `json:"integrationType"`
	// Integration Name
	IntegrationName string `json:"integrationName"`
	// Secret Type
	SecretType SecretType `json:"secretType"`
}

func (IntegrationSecret) IsBaseEntity() {}

func (IntegrationSecret) IsGitopsEntity() {}

func (IntegrationSecret) IsProjectBasedEntity() {}

// Integration Slice
type IntegrationSlice struct {
	// Integration edges
	Edges []*IntegrationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Issue value
type IssueValue struct {
	// Issue url
	URL string `json:"url"`
	// Issue title
	Title string `json:"title"`
	// Issue status
	Status string `json:"status"`
	// Issue avatar URL
	AvatarURL *string `json:"avatarURL,omitempty"`
	// Issue assignee
	Assignee *string `json:"assignee,omitempty"`
}

// Jira command
type JiraCommand struct {
	// Command
	Command *string `json:"command,omitempty"`
}

// Jira Deployments
type JiraDeployment struct {
	// DeploymentSequenceNumber
	DeploymentSequenceNumber float64 `json:"deploymentSequenceNumber"`
	// UpdateSequenceNumber
	UpdateSequenceNumber float64 `json:"updateSequenceNumber"`
	// IssueKeys
	IssueKeys []*string `json:"issueKeys,omitempty"`
	// Associations
	Associations []*string `json:"associations,omitempty"`
	// DisplayName
	DisplayName string `json:"displayName"`
	// Url
	URL string `json:"url"`
	// Description
	Description string `json:"description"`
	// LastUpdated
	LastUpdated string `json:"lastUpdated"`
	// Label
	Label *string `json:"label,omitempty"`
	// State
	State *string `json:"state,omitempty"`
	// Pipeline
	Pipeline *JiraPipeline `json:"pipeline"`
	// Environment
	Environment *JiraEnvironment `json:"environment"`
	// Commands
	Commands []*JiraCommand `json:"commands,omitempty"`
	// SchemaVersion
	SchemaVersion *string `json:"schemaVersion,omitempty"`
}

// jira Deployments output
type JiraDeploymentsOutput struct {
	// Jira Deployment
	Deployments []*JiraDeployment `json:"deployments"`
	// Exist Candidates To Report
	ExistCandidatesToReport *bool `json:"existCandidatesToReport,omitempty"`
}

// Jira environment
type JiraEnvironment struct {
	// Id
	ID string `json:"id"`
	// DisplayName
	DisplayName string `json:"displayName"`
	// Type
	Type string `json:"type"`
}

// Jira pipeline
type JiraPipeline struct {
	// Id
	ID string `json:"id"`
	// DisplayName
	DisplayName string `json:"displayName"`
	// Url
	URL string `json:"url"`
}

// K8s entity id
type K8sEntityID struct {
	// name
	Name string `json:"name"`
	// namespace
	Namespace *string `json:"namespace,omitempty"`
}

// KeycloakSSO
type KeycloakSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Host
	Host *string `json:"host,omitempty"`
	// Realm
	Realm *string `json:"realm,omitempty"`
}

func (KeycloakSso) IsIDP() {}

// Label arrays
type LabelArrays struct {
	// Key
	Key string `json:"key"`
	// Value
	Value []string `json:"value"`
}

// Label
type LabelStringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// LdapSSO
type LdapSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Password
	Password *string `json:"password,omitempty"`
	// URL
	URL *string `json:"url,omitempty"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// Search base
	SearchBase *string `json:"searchBase,omitempty"`
	// Search filter
	SearchFilter *string `json:"searchFilter,omitempty"`
	// Certificate
	Certificate *string `json:"certificate,omitempty"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync,omitempty"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync,omitempty"`
}

func (LdapSso) IsIDP() {}

// Stats for lead time for changes statistics
type LeadTimeForChangesStatistics struct {
	// Lead time for changes statistics data
	Data []*DoraStatisticsData `json:"data"`
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData"`
	// Lead time for changes statistics info
	Info *DoraStatisticsSummery `json:"info"`
}

// LoadBalancer
type LoadBalancer struct {
	// Ingress
	Ingress []*Ingress `json:"ingress,omitempty"`
}

// Logic entity id
type LogicEntityID struct {
	// id
	ID string `json:"id"`
}

// Mapping between the var name and the path to the value in event payload
type Mapping struct {
	// Name of the variable
	VarName string `json:"varName"`
	// Description of the variable
	Description string `json:"description"`
	// Indicates if the mapping should be used in filtering expressions. Some mappings can be useless for filtering, like GIT_REPO that will be the same for each event.
	Filter bool `json:"filter"`
}

// MetricMeasurement
type MetricMeasurement struct {
	// Finished at date
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Started at date
	StartedAt *string `json:"startedAt,omitempty"`
	// Analysis Phase
	Phase *AnalysisPhases `json:"phase,omitempty"`
	// Measurements metadata object (@job-name etc.)
	Metadata *string `json:"metadata,omitempty"`
	// Measurement value
	Value *string `json:"value,omitempty"`
}

// Metric result
type MetricResult struct {
	// Name
	Name string `json:"name"`
	// Provider type
	ProviderType AnalysisMetricProviderTypes `json:"providerType"`
	// Phase
	Phase AnalysisPhases `json:"phase"`
	// Measurements
	Measurements []*MetricMeasurement `json:"measurements"`
	// Message
	Message *string `json:"message,omitempty"`
	// Successful measurements
	Successful *int `json:"successful,omitempty"`
	// Failed measurements
	Failed *int `json:"failed,omitempty"`
	// Inconclusive measurements
	Inconclusive *int `json:"inconclusive,omitempty"`
	// Error measurements
	Error *int `json:"error,omitempty"`
	// Failure Limit
	FailureLimit *int `json:"failureLimit,omitempty"`
	// Inconclusive Limit
	InconclusiveLimit *int `json:"inconclusiveLimit,omitempty"`
	// Measurements count
	Count *int `json:"count,omitempty"`
	// Consecutive error limit
	ConsecutiveErrorLimit *int `json:"consecutiveErrorLimit,omitempty"`
}

// Pipeline metric with trend
type MetricWithTrend struct {
	// Metric value
	Value int `json:"value"`
	// Percent Diff between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Mutation root
type Mutation struct {
}

// Reference Entity by runtime/name/namespace
type NameReferenceInput struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Runtime
	Runtime string `json:"runtime"`
	// Resource name
	Name string `json:"name"`
	// Resource namespace
	Namespace string `json:"namespace"`
	// Resource cluster URL
	Cluster *string `json:"cluster,omitempty"`
}

// Object with name / value / code fields
type NameValueCodeInput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
	// Code
	Code *bool `json:"code,omitempty"`
}

// Object with name / value / code fields
type NameValueCodeOutput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
	// Code
	Code *bool `json:"code,omitempty"`
}

// Object with name and value fields
type NameValueInput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
}

// Object with name and value fields
type NameValueOutput struct {
	// Name
	Name string `json:"name"`
	// Value
	Value string `json:"value"`
}

// Named Resource
type NamedResource struct {
	// Name
	Name string `json:"name"`
}

// retriving many entities matching name
type NamespacedFindManyArgs struct {
	// Runtime name
	Runtime string `json:"runtime"`
	// Names
	Names []string `json:"names"`
	// Namespace
	Namespace string `json:"namespace"`
	// Kind
	Kind *string `json:"kind,omitempty"`
	// Group
	Group *string `json:"group,omitempty"`
	// Version
	Version *string `json:"version,omitempty"`
}

// Node status
type NodeStatus struct {
	// Type
	Type string `json:"type"`
	// Name
	Name string `json:"name"`
	// Display name
	DisplayName string `json:"displayName"`
	// Template Name
	TemplateName *string `json:"templateName,omitempty"`
	// Node children
	Children []*string `json:"children,omitempty"`
	// Current step phase
	Phase *WorkflowNodePhases `json:"phase,omitempty"`
	// Progress
	Progress *string `json:"progress,omitempty"`
	// Message
	Message *string `json:"message,omitempty"`
	// Start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Inputs
	Inputs *string `json:"inputs,omitempty"`
	// Outputs
	Outputs *string `json:"outputs,omitempty"`
	// Script
	Script *string `json:"script,omitempty"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses"`
	// Id
	ID *string `json:"id,omitempty"`
	// Resources Duration
	ResourcesDuration *string `json:"resourcesDuration,omitempty"`
	// Template Ref
	TemplateRef *string `json:"templateRef,omitempty"`
	// Host node name
	HostNodeName *string `json:"hostNodeName,omitempty"`
	// Template
	Template *string `json:"template,omitempty"`
	// Template scope
	TemplateScope *string `json:"templateScope,omitempty"`
}

// Notification Edge
type NotificationEdge struct {
	// Node contains the actual notification data
	Node Notification `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// NotificationReadModelEventPayload
type NotificationReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
	// Payload of event
	Notification Notification `json:"notification"`
}

func (NotificationReadModelEventPayload) IsReadModelEventPayload() {}

// Notification Slice
type NotificationSlice struct {
	// Notification edges
	Edges []*NotificationEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// Object metadata
type ObjectMeta struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Description
	Description *string `json:"description,omitempty"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Runtime
	Runtime string `json:"runtime"`
	// Cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Account name
	Account string `json:"account"`
	// Labels
	Labels []*StringPair `json:"labels,omitempty"`
	// Annotations
	Annotations []*StringPair `json:"annotations,omitempty"`
	// Last updated
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Created
	Created *string `json:"created,omitempty"`
	// K8s object uid
	UID *string `json:"uid,omitempty"`
	// Favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Revision number
	Revision *int `json:"revision,omitempty"`
}

// OktaSSO
type OktaSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Scopes
	Scopes []*string `json:"scopes,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// AutoGroupSync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// App Id
	AppID *string `json:"appId,omitempty"`
	// Sync mirror accounts
	SyncMirrorAccounts []*string `json:"syncMirrorAccounts,omitempty"`
	// Remove deactivated users after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
}

func (OktaSso) IsIDP() {}

// "get one time token for a user
type OneTimeToken struct {
	// One time access token
	AccessToken string `json:"accessToken"`
}

// OneloginSSO
type OneloginSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// API client id
	APIClientID *string `json:"apiClientId,omitempty"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret,omitempty"`
}

func (OneloginSso) IsIDP() {}

// Pack
type Pack struct {
	// Metadata
	Metadata *PackMetadata `json:"metadata,omitempty"`
	// Workflows
	Workflows *WorkflowConcurrency `json:"workflows,omitempty"`
	// Runtime
	Runtime *PackRuntime `json:"runtime,omitempty"`
	// Id
	ID *string `json:"id,omitempty"`
}

// PackMetadata
type PackMetadata struct {
	// Description
	Description *string `json:"description,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
}

// PackRuntime
type PackRuntime struct {
	// DefaultDindResources
	DefaultDindResources *DefaultDindResources `json:"defaultDindResources,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// OS
	Os *string `json:"os,omitempty"`
	// Architecture
	Architecture *string `json:"architecture,omitempty"`
	// CPU
	CPU *string `json:"cpu,omitempty"`
	// Memory
	Memory *string `json:"memory,omitempty"`
	// Storage
	Storage *string `json:"storage,omitempty"`
	// DindStorage
	DindStorage *string `json:"dindStorage,omitempty"`
}

// Parent workflow reference
type ParentWorkflowRef struct {
	// Parent workflow
	Workflow *Workflow `json:"workflow,omitempty"`
	// Parent workflow type
	Type *string `json:"type,omitempty"`
}

// PastDue
type PastDue struct {
	// IsPastDue
	IsPastDue *bool `json:"isPastDue,omitempty"`
	// ShowPastDueWarning
	ShowPastDueWarning *bool `json:"showPastDueWarning,omitempty"`
}

// Permission model
type Permission struct {
	// The id of the user with the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
	// Deprecated: The user with the permission
	User *User `json:"user"`
}

// Permission input
type PermissionInput struct {
	// The id of the user the permission
	UserID string `json:"userId"`
	// Has read permission?
	Read bool `json:"read"`
	// Has write permission?
	Write bool `json:"write"`
}

// Pipeline entity
type Pipeline struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *Sensor `json:"self,omitempty"`
	// History of the pipeline
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Trigger name
	Spec *PipelineSpec `json:"spec"`
	// Statistics
	Statistics *PipelineStatistics `json:"statistics,omitempty"`
	// List of last N workflows
	RecentActivity *WorkflowSlice `json:"recentActivity,omitempty"`
}

func (Pipeline) IsBaseEntity() {}

func (Pipeline) IsK8sLogicEntity() {}

func (Pipeline) IsProjectBasedEntity() {}

func (Pipeline) IsEntity() {}

// Pipeline statistics for average duration
type PipelineAverageDurationStats struct {
	// Info
	Info *PipelineAverageDurationStatsInfo `json:"info"`
	// Data
	Data []*PipelineAverageDurationStatsData `json:"data"`
}

// Stats data for pipline average duration
type PipelineAverageDurationStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Average duration
	AverageDuration *float64 `json:"averageDuration,omitempty"`
}

// Stats info for pipeline success rate.
type PipelineAverageDurationStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total average duration for the all time period
	AverageDuration float64 `json:"averageDuration"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Stats info for pipeline success rate.
type PipelineClassicStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Value for the all time period
	Value *MetricWithTrend `json:"value,omitempty"`
}

// Pipeline statistics for pipline success rate
type PipelineCommittersStats struct {
	// Info
	Info *PipelineCommittersStatsInfo `json:"info"`
	// Data
	Data []*PipelineCommittersStatsData `json:"data"`
}

// Stats data for pipline committers
type PipelineCommittersStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Committers
	Committers *int `json:"committers,omitempty"`
}

// Stats info for pipeline committers.
type PipelineCommittersStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total number of committers for the all time period
	TotalCommitters int `json:"totalCommitters"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Pipeline config
type PipelineConfig struct {
	// General Pipeline Config
	General *PipelineConfigGeneral `json:"general,omitempty"`
	// Pipeline YAML Config
	Yaml *PipelineConfigYaml `json:"yaml,omitempty"`
	// Pipeline Execution Config
	Execution *PipelineConfigExecution `json:"execution,omitempty"`
	// Pending Approval Config
	PendingApproval *PipelineConfigPendingApproval `json:"pendingApproval,omitempty"`
	// Pipeline service account
	ServiceAccount *string `json:"serviceAccount,omitempty"`
	// Enable argo workflows pipelines
	EnableArgoWorkflows *bool `json:"enableArgoWorkflows,omitempty"`
}

// Pipeline Execution Config
type PipelineConfigExecution struct {
	// Keeping PVS for pending approval steps
	KeepPVCsForPendingApproval *bool `json:"keepPVCsForPendingApproval,omitempty"`
	// Include builds that are pending for approval to the number of concurrent builds
	PendingApprovalConcurrencyApplied *bool `json:"pendingApprovalConcurrencyApplied,omitempty"`
	// Marketplace registry
	MarketplaceRegistry *string `json:"marketplaceRegistry,omitempty"`
}

// General Pipeline Config
type PipelineConfigGeneral struct {
	// Templates
	Templates *bool `json:"templates,omitempty"`
	// Clone
	Clone *bool `json:"clone,omitempty"`
}

// Pipeline Execution Config
type PipelineConfigPendingApproval struct {
	// Pending approval confirmation modal window
	PendingApprovalConfirmation *string `json:"pendingApprovalConfirmation,omitempty"`
}

// Pipeline YAML Config
type PipelineConfigYaml struct {
	// Enable inline YAMLs
	Inline *bool `json:"inline,omitempty"`
	// Enable YAMLs from repository
	Git *bool `json:"git,omitempty"`
	// Enable YAMLs from URL
	URL *bool `json:"url,omitempty"`
}

// Pipeline Edge
type PipelineEdge struct {
	// Node contains the actual pipeline data
	Node *Pipeline `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PipelineEdge) IsEdge() {}

// Pipeline statistics for pipline executions
type PipelineExecutionsStats struct {
	// Info
	Info *PipelineExecutionsStatsInfo `json:"info"`
	// Data
	Data []*PipelineExecutionsStatsData `json:"data"`
}

// Stats data for pipline executions
type PipelineExecutionsStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Executions
	Executions *int `json:"executions,omitempty"`
}

// Stats info for pipeline executions.
type PipelineExecutionsStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total number of executions for the all time period
	TotalExecutions int `json:"totalExecutions"`
	// Diff in totals between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Pipeline Ordered statistics
type PipelineOrderedStatistics struct {
	// Pipeline name
	PipelineName string `json:"pipelineName"`
	// Pipeline namespace
	PipelineNamespace string `json:"pipelineNamespace"`
	// Runtime
	Runtime string `json:"runtime"`
	// Position
	Position int `json:"position"`
	// Position Diff from last time frame
	PositionDiffFromLastTimeFrame *int `json:"positionDiffFromLastTimeFrame,omitempty"`
	// Success Rate stats
	SuccessRateStats *MetricWithTrend `json:"successRateStats,omitempty"`
	// Average duration stats
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats,omitempty"`
	// Execution stats
	ExecutionsStats *MetricWithTrend `json:"executionsStats,omitempty"`
}

// PipelineReadModelEventPayload type
type PipelineReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (PipelineReadModelEventPayload) IsReadModelEventPayload() {}

// Pipeline Reference
type PipelineRef struct {
	// Id
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Project
	Project string `json:"project"`
	// ProjectId
	ProjectID string `json:"projectId"`
}

// Pipeline Slice
type PipelineSlice struct {
	// Pipeline edges
	Edges []*PipelineEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PipelineSlice) IsSlice() {}

// Pipeline Spec
type PipelineSpec struct {
	// Trigger
	Trigger string `json:"trigger"`
}

// Pipeline statistics to be used in analytics module
type PipelineStatistics struct {
	// Success Rate stats
	SuccessRateStats *PipelineSuccessRateStats `json:"successRateStats,omitempty"`
	// Average duration stats
	AverageDurationStats *PipelineAverageDurationStats `json:"averageDurationStats,omitempty"`
	// Execution stats
	ExecutionsStats *PipelineExecutionsStats `json:"executionsStats,omitempty"`
	// Committers stats
	CommittersStats *PipelineCommittersStats `json:"committersStats,omitempty"`
}

// Pipeline Step
type PipelineStepStatistics struct {
	// Step Name
	StepName *string `json:"stepName,omitempty"`
	// Template Name
	TemplateName *string `json:"templateName,omitempty"`
	// Workflow Template
	WorkflowTemplate *string `json:"workflowTemplate,omitempty"`
	// Node Type
	NodeType *string `json:"nodeType,omitempty"`
	// Step Average duration
	AverageDurationStats *MetricWithTrend `json:"averageDurationStats,omitempty"`
	// Step Executions count
	ExecutionsStats *MetricWithTrend `json:"executionsStats,omitempty"`
	// Step Average CPU usage
	CPUStats *MetricWithTrend `json:"cpuStats,omitempty"`
	// Step Average Memory
	MemoryStats *MetricWithTrend `json:"memoryStats,omitempty"`
	// Step Errors count
	ErrorsCountStats *MetricWithTrend `json:"errorsCountStats,omitempty"`
}

// Pipeline statistics for pipline success rate
type PipelineSuccessRateStats struct {
	// Info
	Info *PipelineSuccessRateStatsInfo `json:"info"`
	// Data
	Data []*PipelineSuccessRateStatsData `json:"data"`
}

// Stats data for pipline success rate
type PipelineSuccessRateStatsData struct {
	// Time
	Time *string `json:"time,omitempty"`
	// Success rate
	SuccessRate *int `json:"successRate,omitempty"`
}

// Stats info for pipeline success rate.
type PipelineSuccessRateStatsInfo struct {
	// Time period data
	TimePeriodData *StatsTimePeriodData `json:"timePeriodData,omitempty"`
	// Total average success rate for the all time period
	AverageSuccessRate int `json:"averageSuccessRate"`
	// Diff in avarages between the current time period and the previous time period
	PctDiffFromLastTimeFrame *float64 `json:"pctDiffFromLastTimeFrame,omitempty"`
}

// Pipeline filter arguments
type PipelinesFilterArgs struct {
	// Filter pipelines from a specific project
	Project *string `json:"project,omitempty"`
	// Filter pipelines from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter pipelines from a specific runtime
	Namespace *string `json:"namespace,omitempty"`
	// Filter pipelines from a specific cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Filter pipelines from a specific pipeline
	Name *string `json:"name,omitempty"`
	// Filter pipelines from a specific groups
	Groups []*string `json:"groups,omitempty"`
	// Filter pipelines from a specific versions
	Versions []*string `json:"versions,omitempty"`
	// Filter pipelines by workflowTemplate
	WorkflowTemplate *string `json:"workflowTemplate,omitempty"`
}

// Plan
type Plan struct {
	// Stripe
	Stripe *Stripe `json:"stripe,omitempty"`
	// Trial
	Trial *Trial `json:"trial,omitempty"`
	// BasePrice
	BasePrice *BasePrice `json:"basePrice,omitempty"`
	// Workflows
	Workflows *PlanWorkflows `json:"workflows,omitempty"`
	// Environments
	Environments *PlanEnvironment `json:"environments,omitempty"`
	// DataRetention
	DataRetention *DataRetention `json:"dataRetention,omitempty"`
	// Collaborators
	Collaborators *PlanCollaborators `json:"collaborators,omitempty"`
	// PastDue
	PastDue *PastDue `json:"pastDue,omitempty"`
	// NewPricingModel
	NewPricingModel *bool `json:"newPricingModel,omitempty"`
	// Azure
	Azure *bool `json:"azure,omitempty"`
	// Currency
	Currency *string `json:"currency,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Dedicated
	Dedicated *bool `json:"dedicated,omitempty"`
	// PrivateRepo
	PrivateRepo *bool `json:"privateRepo,omitempty"`
	// PaymentInterval
	PaymentInterval *string `json:"paymentInterval,omitempty"`
	// IsWiredTransfer
	IsWiredTransfer *bool `json:"isWiredTransfer,omitempty"`
	// Packs
	Packs []*Pack `json:"packs,omitempty"`
	// TotalPrice
	TotalPrice *int `json:"totalPrice,omitempty"`
	// DisplayName
	DisplayName *string `json:"displayName,omitempty"`
	// Id
	ID *string `json:"id,omitempty"`
	// DefaultPack
	DefaultPack *string `json:"defaultPack,omitempty"`
	// Segment
	Segment *string `json:"segment,omitempty"`
	// MRR
	Mrr *int `json:"mrr,omitempty"`
	// ARR
	Arr *int `json:"arr,omitempty"`
}

// PlanCollaborators
type PlanCollaborators struct {
	// Limit
	Limit *int `json:"limit,omitempty"`
}

// PlanEnvironment
type PlanEnvironment struct {
	// Concurrency
	Concurrency *EnvironmentConcurrency `json:"concurrency,omitempty"`
}

// PlanWorkflows
type PlanWorkflows struct {
	// Concurrency
	Concurrency *WorkflowConcurrency `json:"concurrency,omitempty"`
}

// Pod Spec
type PodSpec struct {
	// Containers
	Containers []*DeploymentContainer `json:"containers,omitempty"`
}

// PodTemplate Spec
type PodTemplateSpec struct {
	// Metadata
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	// Spec
	Spec *PodSpec `json:"spec,omitempty"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilter struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
}

// Predefined filter is similar to Classic Codefresh filters by branch, repo etc.
type PredefinedFilterArgs struct {
	// Key is the name of predefined filter
	Key string `json:"key"`
	// Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored
	Value []string `json:"value"`
	// Comparator compares the event data with a user given value. Can be '>=', '>', '=', '!=', '<', or '<='. Is optional, and if left blank treated as equality '='.
	Comparator *string `json:"comparator,omitempty"`
}

// Result of the promotion policy preview. Action is optional.
type PreviewedPromotionPolicy struct {
	// Resolved preAction
	PreAction *ResolvedPromotionPolicyItem `json:"preAction,omitempty"`
	// Resolved postAction
	PostAction *ResolvedPromotionPolicyItem `json:"postAction,omitempty"`
	// Resolved action
	Action *ResolvedPromotionPolicyItem `json:"action,omitempty"`
}

// Product Entity
type Product struct {
	// Entity db id
	ID string `json:"id"`
	// Deprecated: Use metadata.name instead
	Name string `json:"name"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Is group marked as favorite (user scope)
	Favorite *bool `json:"favorite,omitempty"`
	// Annotaion pairs array strings(key=value)
	AnnotationPairs []*string `json:"annotationPairs"`
	// List of environments that has at least 1 product component associated with this product
	Environments []*Environment `json:"environments"`
	// Tags list
	Tags []*string `json:"tags"`
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Promotion flows and their selectors
	PromotionFlows []*ProductPromotionFlowSelectors `json:"promotionFlows,omitempty"`
}

func (Product) IsFavorableNotK8sEntity() {}

func (Product) IsGitopsEntity() {}

func (Product) IsBaseEntity() {}

func (Product) IsProjectBasedEntity() {}

func (Product) IsFavorable() {}

func (Product) IsEntity() {}

// Product App application
type ProductApplication struct {
	// Entity id object
	Self *ProductApplicationEntityID `json:"self"`
	// Resolved application based on self object
	AppEntity *Application `json:"appEntity,omitempty"`
	// Runtime name
	Runtime string `json:"runtime"`
	// Deployed to object
	DeployedTo *ProductApplicationDeployedTo `json:"deployedTo"`
	// Product App Application Status object
	Status *ProductApplicationStatus `json:"status"`
	// Annotaion pairs array strings(key=value)
	AnnotationPairs []*string `json:"annotationPairs"`
	// Latest application release
	Release *ProductApplicationRelease `json:"release,omitempty"`
}

// Product Application deployed to
type ProductApplicationDeployedTo struct {
	// Destination cluster name
	Name *string `json:"name,omitempty"`
	// Destination server url
	Server *string `json:"server,omitempty"`
	// Destination namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Product application entity id
type ProductApplicationEntityID struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Cluster
	Cluster string `json:"cluster"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// Product Application Release
type ProductApplicationRelease struct {
	// History id
	HistoryID int `json:"historyId"`
	// Related argocd history id
	ArgoHistoryID *int `json:"argoHistoryId,omitempty"`
	// Application field
	Application *ApplicationField `json:"application"`
	// Child applications
	ChildApps []*ChildApplicationField `json:"childApps"`
	// From state
	FromState *FromState `json:"fromState,omitempty"`
	// To state
	ToState *ToState `json:"toState"`
	// Transition
	Transition *Transition `json:"transition"`
	// Version of application and dependencies
	AppVersions *ProductComponentVersions `json:"appVersions,omitempty"`
}

// Product App deployed to
type ProductApplicationStatus struct {
	// Application sync status
	Sync *SyncStatus `json:"sync,omitempty"`
	// Application health status
	Health *HealthStatus `json:"health,omitempty"`
}

// Product Component Entity
type ProductComponent struct {
	// Entity db id
	ID string `json:"id"`
	// Component name
	Name string `json:"name"`
	// Product app type
	Type ProductComponentType `json:"type"`
	// Pending Pull Requests
	PendingPullRequests []*PullRequest `json:"pendingPullRequests,omitempty"`
	// Application
	Application *ProductApplication `json:"application,omitempty"`
	// Promotion workflow
	PromotedBy *ProductComponentPromotedByWorkflow `json:"promotedBy,omitempty"`
	// ID of product to which component is manually attached
	ManuallyAttachedToProductID *string `json:"manuallyAttachedToProductId,omitempty"`
	// Resolved when product app attached to specific product or null if unassigned. Normally should be 1 or 0. If more this means that collision in relation present and component belongs to different products
	Products []*Product `json:"products,omitempty"`
	// Resolved when product app attached to specific environment or null if unassigned
	Environments []*Environment `json:"environments,omitempty"`
	// Favorites
	Favorites []string `json:"favorites,omitempty"`
	// Is group marked as favorite (user scope)
	Favorite *bool `json:"favorite,omitempty"`
}

func (ProductComponent) IsFavorableNotK8s() {}

func (ProductComponent) IsEntity() {}

// Product component Edge
type ProductComponentEdge struct {
	// Node contains the actual Product data
	Node *ProductComponent `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProductComponentEdge) IsEdge() {}

// Args to filter Product Components
type ProductComponentFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Issue key array
	IssueKeys []string `json:"issueKeys,omitempty"`
	// PR key array
	PrKeys []string `json:"prKeys,omitempty"`
	// Committers array
	Committers []string `json:"committers,omitempty"`
	// Images array
	Images []string `json:"images,omitempty"`
	// Product names array
	Products []string `json:"products,omitempty"`
	// If 'true' returns unassigned components, 'false' ignored
	NotInProduct *bool `json:"notInProduct,omitempty"`
	// Environments names array
	Environments []string `json:"environments,omitempty"`
	// If 'true' returns components that belong to any environment, 'false' ignored
	InEnvironment *bool `json:"inEnvironment,omitempty"`
	// By application health status
	HealthStatuses []HealthStatus `json:"healthStatuses,omitempty"`
	// If 'true' returns components that have at least 1 pending PR
	HasPendingPullRequests *bool `json:"hasPendingPullRequests,omitempty"`
}

// Info about the workflow that promoted component
type ProductComponentPromotedByWorkflow struct {
	// Workflow name
	WorkflowName string `json:"workflowName"`
	// Workflow status
	Status WorkflowPhases `json:"status"`
	// Git commit SHA that triggered the workflow
	Revision string `json:"revision"`
	// Workflow start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Workflow finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
}

// Product Component sorting arguments
type ProductComponentSortArg struct {
	// Field for sorting
	Field ProductComponentSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Version of product and dependencies
type ProductComponentVersions struct {
	// AppVersion
	AppVersion *string `json:"appVersion,omitempty"`
	// VersionSources as yaml resources
	VersionSources []*ComponentDependenciesContent `json:"versionSources,omitempty"`
	// Versions
	VersionSummary []*SingleComponentDependency `json:"versionSummary,omitempty"`
}

// Product Components Counts
type ProductComponentsCounts struct {
	// Assigned Product Components Health Status Statistic
	Assigned []*ProductComponentsHealthStatusStatisticRecord `json:"assigned,omitempty"`
	// Unassigned Product Components Health Status Statistic
	Unassigned []*ProductComponentsHealthStatusStatisticRecord `json:"unassigned,omitempty"`
}

// Product Components Health Status Statistic
type ProductComponentsHealthStatusStatisticRecord struct {
	// Health Status
	Type HealthStatus `json:"type"`
	// Count
	Count int `json:"count"`
}

// Product components Slice
type ProductComponentsSlice struct {
	// Product app edges
	Edges []*ProductComponentEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProductComponentsSlice) IsSlice() {}

// Product Edge
type ProductEdge struct {
	// Node contains the actual Product data
	Node *Product `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProductEdge) IsEdge() {}

// Product Environment Statistic item
type ProductEnvironmentStatistic struct {
	// Entity db id
	EnvID string `json:"envId"`
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// Kind of environment
	ComponentsAmount int `json:"componentsAmount"`
	// Position of environment
	Position int `json:"position"`
}

// Args to filter Product
type ProductFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Environments names
	Environments []*string `json:"environments,omitempty"`
	// Filter by user favorite
	Favorite *bool `json:"favorite,omitempty"`
}

// Product Git Trigger Selector
type ProductGitTriggerSelector struct {
	// Key
	Key ProductGitTrigger `json:"key"`
	// Operator
	Operator MatchExpressionOperator `json:"operator"`
	// Values
	Values []string `json:"values"`
}

// Product Promotion Flow Selectors
type ProductPromotionFlowSelectors struct {
	// Entity db id
	Name string `json:"name"`
	// Group name
	GitTriggerSelectors []*ProductGitTriggerSelector `json:"gitTriggerSelectors"`
}

// Product release payload
type ProductReleaseEventPayload struct {
	// Product release id
	ID string `json:"id"`
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
}

func (ProductReleaseEventPayload) IsCommonEntityEventPayload() {}

// Product Slice
type ProductSlice struct {
	// Product edges
	Edges []*ProductEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProductSlice) IsSlice() {}

// Product sorting arguments
type ProductSortArg struct {
	// Field for sorting
	Field ProductSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// Product Statistic item
type ProductStatistic struct {
	// Entity db id
	ID string `json:"id"`
	// Group name
	Name string `json:"name"`
	// Entironments
	Environments []*ProductEnvironmentStatistic `json:"environments"`
}

// Project entity
type Project struct {
	// Project name
	Name string `json:"name"`
	// Project description
	Description *string `json:"description,omitempty"`
}

func (Project) IsEntity() {}

// Project Edge
type ProjectEdge struct {
	// Node contains the actual project data
	Node *Project `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ProjectEdge) IsEdge() {}

// ProjectReadModelEventPayload type
type ProjectReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (ProjectReadModelEventPayload) IsReadModelEventPayload() {}

// Project Slice
type ProjectSlice struct {
	// Project edges
	Edges []*ProjectEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ProjectSlice) IsSlice() {}

// PromotionFlow entity
type PromotionFlow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Relations between parents and child applications in tree
	AppsRelations *AppsRelations `json:"appsRelations,omitempty"`
	// ReadPermission of related git source
	ReadPermission *bool `json:"readPermission,omitempty"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Db entity id
	ID *string `json:"id,omitempty"`
	// Updated At
	UpdatedAt *string `json:"updatedAt,omitempty"`
	// Trigger Environment
	TriggerEnvironment string `json:"triggerEnvironment"`
	// Post Trigger
	PostTrigger *string `json:"postTrigger,omitempty"`
	// Promotion flow steps
	Steps []*FlowStep `json:"steps"`
}

func (PromotionFlow) IsGitopsEntity() {}

func (PromotionFlow) IsBaseEntity() {}

func (PromotionFlow) IsProjectBasedEntity() {}

// Promotion flow Edge
type PromotionFlowEdge struct {
	// Node contains the actual promotion flow data
	Node *PromotionFlow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

// Promotion flow Slice
type PromotionFlowSlice struct {
	// Promotion flow edges
	Edges []*PromotionFlowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

// PromotionPolicy entity
type PromotionPolicy struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// History
	History *GitOpsSlice `json:"history"`
	// Version of the entity (generation)
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest bool `json:"latest"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Product and Environment selector
	Selector *PromotionPolicySelector `json:"selector,omitempty"`
	// Policy
	Policy *PromotionPolicyDefinition `json:"policy"`
	// Number that represents the priority of the promotion policy when multiple policies can be applied. The higher the number, the higher the priority. The default value is 0.
	Priority float64 `json:"priority"`
}

func (PromotionPolicy) IsGitopsEntity() {}

func (PromotionPolicy) IsBaseEntity() {}

func (PromotionPolicy) IsEntity() {}

// Promotion policy definition
type PromotionPolicyDefinition struct {
	// Pre action workflowTemplate name
	PreAction *string `json:"preAction,omitempty"`
	// Post action workflowTemplate name
	PostAction *string `json:"postAction,omitempty"`
	// Action Type
	Action *PromotionPolicyAction `json:"action,omitempty"`
}

// PromotionPolicy Edge
type PromotionPolicyEdge struct {
	// Node
	Node *PromotionPolicy `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PromotionPolicyEdge) IsEdge() {}

// Promotion policy environment selector
type PromotionPolicyEnvironmentSelector struct {
	// Environment names
	Names []string `json:"names,omitempty"`
	// Environment types
	Types []EnvironmentKind `json:"types,omitempty"`
	// Environment tags
	Tags []string `json:"tags,omitempty"`
}

// Args to filter Promotion Policy
type PromotionPolicyFilterArgs struct {
	// Partial name (case insensitive)
	PartialName *string `json:"partialName,omitempty"`
	// Pre-action (case insensitive)
	PreActionNames []string `json:"preActionNames,omitempty"`
	// Post-action (case insensitive)
	PostActionNames []string `json:"postActionNames,omitempty"`
	// Action
	Action *PromotionPolicyAction `json:"action,omitempty"`
}

// Promotion Policy filter values
type PromotionPolicyFilterValues struct {
	// Pre-action
	PreActions []string `json:"preActions"`
	// Post-action
	PostActions []string `json:"postActions"`
}

// Promotion policy product selector
type PromotionPolicyProductSelector struct {
	// Product names
	Names []string `json:"names,omitempty"`
	// Products tags
	Tags []string `json:"tags,omitempty"`
}

// Promotion policy selector
type PromotionPolicySelector struct {
	// Product selector
	Product *PromotionPolicyProductSelector `json:"product,omitempty"`
	// Environment selector
	TargetEnvironment *PromotionPolicyEnvironmentSelector `json:"targetEnvironment,omitempty"`
}

// PromotionPolicy Slice
type PromotionPolicySlice struct {
	// PromotionPolicy edges
	Edges []*PromotionPolicyEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PromotionPolicySlice) IsSlice() {}

// Promotion Policy sorting arguments
type PromotionPolicySortArg struct {
	// Field for sorting
	Field PromotionPolicySortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// PromotionSource entity
type PromotionSource struct {
	// File path
	Glob string `json:"glob"`
	// JSON paths to the values in the file
	JSONPaths []string `json:"jsonPaths"`
}

// PromotionTemplate entity
type PromotionTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this entity
	References []BaseEntity `json:"references,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Version Source
	VersionSource *FileSource `json:"versionSource"`
	// Promotion array of PromotionSource
	Promotion []*PromotionSource `json:"promotion"`
}

func (PromotionTemplate) IsBaseEntity() {}

func (PromotionTemplate) IsPromotionTemplateFields() {}

func (PromotionTemplate) IsEntity() {}

// Application Set Edge
type PromotionTemplateEdge struct {
	// Node contains the actual application configuration data
	Node *PromotionTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (PromotionTemplateEdge) IsEdge() {}

// PromotionTemplate Short entity
type PromotionTemplateShort struct {
	// Version Source
	VersionSource *FileSource `json:"versionSource"`
	// Promotion array of PromotionSource
	Promotion []*PromotionSource `json:"promotion"`
}

func (PromotionTemplateShort) IsPromotionTemplateFields() {}

// PromotionTemplate Slice
type PromotionTemplateSlice struct {
	// Application edges
	Edges []*PromotionTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (PromotionTemplateSlice) IsSlice() {}

// Pull request
type PullRequest struct {
	// Pull request repo name
	Repo string `json:"repo"`
	// Pull request id
	ID int `json:"id"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Pull request title
	Title string `json:"title"`
	// Pull request url
	URL string `json:"url"`
	// Pull request author
	Author string `json:"author"`
	// Pull request author avatar url
	AvatarURL string `json:"avatarUrl"`
	// Pull request created at
	CreatedAt string `json:"createdAt"`
}

// Pull request args
type PullRequestArgs struct {
	// Pull request repo name
	Repo string `json:"repo"`
	// Pull request id
	ID int `json:"id"`
	// Pull request url
	URL string `json:"url"`
	// Pull request title
	Title string `json:"title"`
	// Pull request description
	Description *string `json:"description,omitempty"`
	// Pull request author
	Author string `json:"author"`
	// Pull request author avatar url
	AvatarURL string `json:"avatarUrl"`
	// Pull request created at
	CreatedAt string `json:"createdAt"`
}

// PullRequestCommitter
type PullRequestCommitter struct {
	// userName
	UserName string `json:"userName"`
	// avatar
	Avatar *string `json:"avatar,omitempty"`
}

// PullRequest value
type PullRequestValue struct {
	// url
	URL string `json:"url"`
	// title
	Title string `json:"title"`
	// committers
	Committers []*PullRequestCommitter `json:"committers"`
	// commits
	Commits []*Commits `json:"commits,omitempty"`
	// id
	ID *string `json:"id,omitempty"`
}

// Query root
type Query struct {
}

// ReadModelEventResponse
type ReadModelEventResponse struct {
	// Account ID
	AccountID string `json:"accountId"`
	// Time of event
	Time string `json:"time"`
	// Payload of event
	Payload ReadModelEventPayload `json:"payload,omitempty"`
}

// Registry
type Registry struct {
	// Domain
	Domain string `json:"domain"`
	// Registry type
	Type ImageRegistryType `json:"type"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix,omitempty"`
	// Original Repository Prefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix,omitempty"`
}

// RegistryInput
type RegistryInput struct {
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix,omitempty"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix,omitempty"`
}

// RegistryOutput
type RegistryOutput struct {
	// Id
	ID *string `json:"id,omitempty"`
	// Domain
	Domain string `json:"domain"`
	// Repository prefix derived from image name: `domain + repository/prefix[/any] + imageName
	RepositoryPrefix *string `json:"repositoryPrefix,omitempty"`
	// OriginalRepositoryPrefix
	OriginalRepositoryPrefix *string `json:"originalRepositoryPrefix,omitempty"`
}

// Release Entity - represents a Codefresh runtime release
type Release struct {
	// Runtime version (backward compatability, not used anywhere)
	Version string `json:"version"`
	// Runtime version
	RuntimeVersion string `json:"runtimeVersion"`
	// Chart version (only exists in helm runtime)
	ChartVersion *string `json:"chartVersion,omitempty"`
	// Has security vulnerabilities
	HasSecurityVulnerabilities *bool `json:"hasSecurityVulnerabilities,omitempty"`
}

// Rollout Rollout State
type ReleaseRolloutState struct {
	// Name
	Name string `json:"name"`
	// UID
	UID *string `json:"uid,omitempty"`
	// Revision
	CurrentRevision int `json:"currentRevision"`
	// Disable rollout access on ui
	Disabled *ReleaseRolloutDisabledReasons `json:"disabled,omitempty"`
	// Status of the process
	Phase RolloutPhases `json:"phase"`
	// Health message
	Message *string `json:"message,omitempty"`
	// Name of current strategy
	CurrentStrategyName RolloutStrategyNames `json:"currentStrategyName"`
	// Number of steps
	Steps *int `json:"steps,omitempty"`
	// Current step index
	CurrentStepIndex *int `json:"currentStepIndex,omitempty"`
	// Current step spec
	CurrentStepSpec *string `json:"currentStepSpec,omitempty"`
	// Services
	Services []*string `json:"services"`
	// Status of PrePromotion analysis
	PrePromotionAnalysisRunStatus *RolloutAnalysisStatus `json:"prePromotionAnalysisRunStatus,omitempty"`
	// Status of postPromotion analysis
	PostPromotionAnalysisRunStatus *RolloutAnalysisStatus `json:"postPromotionAnalysisRunStatus,omitempty"`
	// Status of inline analyses
	StepsAnalysisRunStatuses []*RolloutAnalysisStatus `json:"stepsAnalysisRunStatuses,omitempty"`
	// Status of background status
	BackgroundAnalysisRunStatus *RolloutAnalysisStatus `json:"backgroundAnalysisRunStatus,omitempty"`
	// Revision info
	RevisionInfo *RevisionInfo `json:"revisionInfo"`
	// Is rollout complete
	IsComplete bool `json:"isComplete"`
	// Is rollout paused (taken from status.paused)
	Paused *bool `json:"paused,omitempty"`
	// Set to true only when analysis run status become inconclusive
	PausedInconclusive *bool `json:"pausedInconclusive,omitempty"`
}

// ReleaseServiceState Entity
type ReleaseServiceState struct {
	// Images
	Images []*Images `json:"images,omitempty"`
	// SyncStatus
	SyncStatus *SyncStatus `json:"syncStatus,omitempty"`
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
	// Available Replicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
}

// "response for renew access token
type RenewAccessTokenResponse struct {
	// The access token to use for the next requests
	NewAccessToken *string `json:"newAccessToken,omitempty"`
}

// ReplicaSet entity
type ReplicaSet struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the application
	History *GitOpsSlice `json:"history"`
	// Image
	Image string `json:"image"`
	// Replicas
	Replicas int `json:"replicas"`
	// Ready Replicas
	ReadyReplicas int `json:"readyReplicas"`
	// Current Replicas
	CurrentReplicas int `json:"currentReplicas"`
	// Available Replicas
	AvailableReplicas int `json:"availableReplicas"`
	// Updated Replicas
	UpdatedReplicas int `json:"updatedReplicas"`
	// Actual manifest
	ActualManifest string `json:"actualManifest"`
}

func (ReplicaSet) IsBaseEntity() {}

func (ReplicaSet) IsEntity() {}

// ReplicaSet Edge
type ReplicaSetEdge struct {
	// Node contains the actual ReplicaSet data
	Node *ReplicaSet `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ReplicaSetEdge) IsEdge() {}

// ReplicaSet Slice
type ReplicaSetSlice struct {
	// ReplicaSet edges
	Edges []*ReplicaSetEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ReplicaSetSlice) IsSlice() {}

// RepoBitbucketCloudFilterArgs
type RepoBitbucketCloudFilterArgs struct {
	// Repo owner
	Owner string `json:"owner"`
	// Repo projectKey
	ProjectKey string `json:"projectKey"`
	// Repo name
	RepositorySlug string `json:"repositorySlug"`
}

// RepoBitbucketCloudFilterArgs
type RepoBitbucketCloudFilterArgsInput struct {
	// Repo owner
	Owner string `json:"owner"`
	// Repo projectKey
	ProjectKey string `json:"projectKey"`
	// Repo name
	RepositorySlug string `json:"repositorySlug"`
}

// Runtime Errors Report Arguments
type ReportRuntimeErrorsArgs struct {
	// Name of the Runtime
	Runtime string `json:"runtime"`
	// Errors
	Errors []*HealthErrorInput `json:"errors"`
}

// Result of the promotion policy resolution. Action is required.
type ResolvedPromotionPolicy struct {
	// Resolved preAction
	PreAction *ResolvedPromotionPolicyItem `json:"preAction,omitempty"`
	// Resolved postAction
	PostAction *ResolvedPromotionPolicyItem `json:"postAction,omitempty"`
	// Resolved action
	Action *ResolvedPromotionPolicyItem `json:"action"`
}

// Value and origin of the resolved PP field
type ResolvedPromotionPolicyItem struct {
	// Value
	Value string `json:"value"`
	// Origin of the value
	Origin *PromotionPolicy `json:"origin"`
}

// Resource event
type ResourceEvent struct {
	// Name
	Name string `json:"name"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace string `json:"namespace"`
}

func (ResourceEvent) IsEvent() {}

// Resource manifest
type ResourceManifest struct {
	// Full filename with path
	Filename *string `json:"filename,omitempty"`
	// Status: created, updated, deleted
	Status *string `json:"status,omitempty"`
	// K8s kind
	Kind string `json:"kind"`
	// File contents
	Content string `json:"content"`
	// Old file contents
	OldContent *string `json:"oldContent,omitempty"`
	// Git commit sha
	Revision *string `json:"revision,omitempty"`
	// Entities referenced by this resource
	ReferencedBy []*BaseReference `json:"referencedBy,omitempty"`
}

// ResourcesRequests
type ResourcesRequests struct {
	// CPU
	CPU *string `json:"cpu,omitempty"`
	// Memory
	Memory *string `json:"memory,omitempty"`
}

// RestrictedGitSource entity
type RestrictedGitSource struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// The generated AppProject's sourceNamespace
	SourceNamespace string `json:"sourceNamespace"`
	// The generated AppProject's destinations array
	Destinations []*AppProjectDestination `json:"destinations"`
	// The generated AppProject's sourceRepos array
	SourceRepos []string `json:"sourceRepos,omitempty"`
}

func (RestrictedGitSource) IsBaseEntity() {}

func (RestrictedGitSource) IsEntity() {}

// Restricted Git Source details
type RestrictedGitSourceDetails struct {
	// The generated AppProject's sourceNamespace
	SourceNamespace string `json:"sourceNamespace"`
	// The generated AppProject's destinations array
	Destinations []*AppProjectDestination `json:"destinations"`
	// The generated AppProject's sourceRepos array
	SourceRepos []string `json:"sourceRepos,omitempty"`
}

// RestrictedGitSource Edge
type RestrictedGitSourceEdge struct {
	// Node contains the actual restricted gitsource data
	Node *RestrictedGitSource `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RestrictedGitSourceEdge) IsEdge() {}

// RestrictedGitSource Slice
type RestrictedGitSourceSlice struct {
	// Restricted git source edges
	Edges []*RestrictedGitSourceEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RestrictedGitSourceSlice) IsSlice() {}

// Revision Info Entity
type RevisionInfo struct {
	// Image Name
	Image string `json:"image"`
	// Image details
	ImageDetails *RolloutImageDetails `json:"imageDetails,omitempty"`
	// Current traffic weight directed to this revision
	Weight int `json:"weight"`
	// Current replicas
	Replicas *int `json:"replicas,omitempty"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas,omitempty"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas,omitempty"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
	// Current unavailable replicas
	UnavailableReplicas *int `json:"unavailableReplicas,omitempty"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas,omitempty"`
}

// Rollback Availability Info
type RollbackAvailabilityInfo struct {
	// Is rollback allowed for this rollout
	Allowed bool `json:"allowed"`
	// Is this rollout is latest one or not
	IsLatestRollout bool `json:"isLatestRollout"`
	// Is this rollout replicaset resource still exists in cluster as per history settings
	InRevisionsHistory bool `json:"inRevisionsHistory"`
	// Current revision history limit which is set in latest rollout of the application
	RevisionHistoryLimitSettings int `json:"revisionHistoryLimitSettings"`
	// Revision of latest rollout
	LatestRevision int `json:"latestRevision"`
}

// "Rollout Entity
type Rollout struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// History of the entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Spec
	Spec *RolloutSpec `json:"spec"`
	// Status
	Status *RolloutStatus `json:"status"`
	// Performed Actions (from codefresh)
	PerformedActions *RolloutPerformedActions `json:"performedActions,omitempty"`
	// Rollback info
	RollbackAvailability *RollbackAvailabilityInfo `json:"rollbackAvailability,omitempty"`
}

func (Rollout) IsProjectBasedEntity() {}

func (Rollout) IsGitopsEntity() {}

func (Rollout) IsBaseEntity() {}

func (Rollout) IsEntity() {}

// Rollout Analysis Run Status
type RolloutAnalysisRunStatus struct {
	// Number of erroneous measurments
	Name string `json:"name"`
	// Status
	Status AnalysisPhases `json:"status"`
	// Message
	Message *string `json:"message,omitempty"`
}

// Rollout Analysis Status
type RolloutAnalysisStatus struct {
	// Number of erroneous measurments
	Error int `json:"error"`
	// Number of failed measurments
	Failed int `json:"failed"`
	// Number of inconclusive measurments
	Inconclusive int `json:"inconclusive"`
	// Name of the analysis
	Name string `json:"name"`
	// The summary state of the analysis, taking into account defined limits
	Phase string `json:"phase"`
	// Number of successful measurments
	Successful int `json:"successful"`
}

// Rollout Set Canary Scale Step
type RolloutCanaryInlineAnalysisStep struct {
	// Replicas
	Templates []*RolloutInlineAnalysisTemplate `json:"templates"`
	// Name value args list
	Args []*NameValueOutput `json:"args,omitempty"`
}

// Rollout Canary Pause Step
type RolloutCanaryPauseStep struct {
	// Duration settings
	Duration *string `json:"duration,omitempty"`
}

// Rollout Set Canary Scale Step
type RolloutCanarySetScaleStep struct {
	// Replicas
	Replicas *int `json:"replicas,omitempty"`
	// Weight
	Weight *int `json:"weight,omitempty"`
	// Match Traffic Weight
	MatchTrafficWeight *bool `json:"matchTrafficWeight,omitempty"`
}

// Rollout Canary Status
type RolloutCanaryStatus struct {
	// Status of current step analysis
	CurrentStepAnalysisRunStatus *RolloutAnalysisRunStatus `json:"currentStepAnalysisRunStatus,omitempty"`
	// Status of background status
	BackgroundAnalysisRunStatus *RolloutAnalysisRunStatus `json:"backgroundAnalysisRunStatus,omitempty"`
}

// Rollout Canary Step
type RolloutCanaryStep struct {
	// Set weight
	SetWeight *int `json:"setWeight,omitempty"`
	// Pause settings
	Pause *RolloutCanaryPauseStep `json:"pause,omitempty"`
	// Set canary scal
	SetCanaryScale *RolloutCanarySetScaleStep `json:"setCanaryScale,omitempty"`
	// Inline analysis
	Analysis *RolloutCanaryInlineAnalysisStep `json:"analysis,omitempty"`
	// Inline experiment
	Experiment *RolloutInlineExperimentTemplate `json:"experiment,omitempty"`
	// Related Analysis Runs array
	AnalysisRuns []*AnalysisRun `json:"analysisRuns,omitempty"`
}

// Rollout Edge
type RolloutEdge struct {
	// Node contains the actual rollout data
	Node *Rollout `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RolloutEdge) IsEdge() {}

// Rollout filter arguments
type RolloutFilterArgs struct {
	// Filter rollouts from a specific project
	Project *string `json:"project,omitempty"`
	// Filter rollouts from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter rollouts by group
	Group *string `json:"group,omitempty"`
	// Filter rollouts by version
	Version *string `json:"version,omitempty"`
	// Filter rollouts from a specific cluster url
	Cluster *string `json:"cluster,omitempty"`
}

// Rollout Image Details
type RolloutImageDetails struct {
	// Image name
	Image string `json:"image"`
	// Image repository name
	RepositoryName string `json:"repositoryName"`
	// Image binary id
	BinaryID string `json:"binaryId"`
	// Workflow name
	WorkflowName *string `json:"workflowName,omitempty"`
	// Workflow url
	WorkflowURL *string `json:"workflowUrl,omitempty"`
	// CI provider
	CiProvider *string `json:"ciProvider,omitempty"`
}

// Rollout Set Canary Scale Step
type RolloutInlineAnalysisTemplate struct {
	// Template name
	TemplateName string `json:"templateName"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentAnalyses struct {
	// Name
	Name string `json:"name"`
	// Template name
	TemplateName string `json:"templateName"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentTemplate struct {
	// Duration
	Duration *string `json:"duration,omitempty"`
	// Templates
	Templates []*RolloutInlineExperimentTemplates `json:"templates"`
	// Analyses
	Analyses []*RolloutInlineExperimentAnalyses `json:"analyses,omitempty"`
}

// Rollout Set Canary Scale Step
type RolloutInlineExperimentTemplates struct {
	// Name
	Name string `json:"name"`
	// Spec ref
	SpecRef string `json:"specRef"`
}

// Rollout Performed Actions
type RolloutPerformedActions struct {
	// Skipped Steps
	SkippedSteps []*RolloutSkippedStep `json:"skippedSteps,omitempty"`
	// Promote full details
	PromoteFull *RolloutPromoteFullDetails `json:"promoteFull,omitempty"`
}

// Rollout Promote Full Details
type RolloutPromoteFullDetails struct {
	// Date when action was performed
	PerformedAt string `json:"performedAt"`
	// Canary step index (0+)
	FromStep *int `json:"fromStep,omitempty"`
}

// Rollout Promote Full Details Input
type RolloutPromoteFullDetailsInput struct {
	// Date when action was performed
	PerformedAt string `json:"performedAt"`
	// Canary step index (0+)
	FromStep *int `json:"fromStep,omitempty"`
}

// Rollout Rollback Revisions Comparence Response
type RolloutRollbackRevisionsComparenceResponse struct {
	// Rollout
	Rollout *Rollout `json:"rollout"`
	// Actual/current rollout manifest
	ActualManifest string `json:"actualManifest"`
	// State in case of rollback
	RollbackManifest *string `json:"rollbackManifest,omitempty"`
}

// Rollout Skipped Step
type RolloutSkippedStep struct {
	// Step index (0+)
	Index int `json:"index"`
	// Date when action was performed
	PerformedAt string `json:"performedAt"`
}

// Rollout Skipped Step Input
type RolloutSkippedStepInput struct {
	// Step index (0+)
	Index int `json:"index"`
	// Date when action was performed
	PerformedAt string `json:"performedAt"`
}

// Rollout Slice
type RolloutSlice struct {
	// Rollout edges
	Edges []*RolloutEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RolloutSlice) IsSlice() {}

// Rollout Spec
type RolloutSpec struct {
	// Strategy
	Strategy *RolloutStrategy `json:"strategy"`
	// Desired replicas
	DesiredReplicas int `json:"desiredReplicas"`
	// Revision History Limit
	RevisionHistoryLimit int `json:"revisionHistoryLimit"`
}

// Rollout Status
type RolloutStatus struct {
	// Index of the current step that is being executed
	CurrentStepIndex *int `json:"currentStepIndex,omitempty"`
	// Status of the process
	Phase string `json:"phase"`
	// Health message
	Message *string `json:"message,omitempty"`
	// Current ready replicas
	ReadyReplicas *int `json:"readyReplicas,omitempty"`
	// Current total replicas
	CurrentReplicas *int `json:"currentReplicas,omitempty"`
	// Current available replicas
	AvailableReplicas *int `json:"availableReplicas,omitempty"`
	// Updated replicas
	UpdatedReplicas *int `json:"updatedReplicas,omitempty"`
	// Current traffic weight of the new version
	WeightOfNew int `json:"weightOfNew"`
	// Is the rollout aborted
	Abort *bool `json:"abort,omitempty"`
	// Is the rollout paused
	Paused *bool `json:"paused,omitempty"`
	// Is the rollout fully promoted
	PromoteFull *bool `json:"promoteFull,omitempty"`
	// Canary status
	Canary *RolloutCanaryStatus `json:"canary,omitempty"`
}

// Rollout Step Details
type RolloutStepDetails struct {
	// Step status
	Status *RolloutStepStatus `json:"status,omitempty"`
}

// Rollout Strategy
type RolloutStrategy struct {
	// Name
	Name string `json:"name"`
	// Rollout new image
	NewImage string `json:"newImage"`
	// Rollout new image details
	NewImageRegistry *ImageRegistry `json:"newImageRegistry,omitempty"`
	// Steps
	Steps []*RolloutCanaryStep `json:"steps,omitempty"`
	// The name of the service pointing to the old version
	CurrentService *string `json:"currentService,omitempty"`
	// The name of the service pointing to the new version
	NewService *string `json:"newService,omitempty"`
	// Canary background analysis run details
	BackgroundAnalysisRun *AnalysisRun `json:"backgroundAnalysisRun,omitempty"`
	// Canary background analysis starting step
	BackgoundAnalysisSpec *string `json:"backgoundAnalysisSpec,omitempty"`
	// Blue-green pre promotion analysis run details
	PrePromotionAnalysisRun *AnalysisRun `json:"prePromotionAnalysisRun,omitempty"`
	// Blue-green post promotion analysis run details
	PostPromotionAnalysisRun *AnalysisRun `json:"postPromotionAnalysisRun,omitempty"`
}

// RolloutTransition Entity
type RolloutTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseRolloutState `json:"from,omitempty"`
	// To
	To *ReleaseRolloutState `json:"to,omitempty"`
	// Rollbacks
	Rollbacks []*RolloutTransition `json:"rollbacks"`
}

// Runtime entity
type Runtime struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Self entity reference for the real k8s entity in case of codefresh logical entity
	Self *GenericEntity `json:"self,omitempty"`
	// History of the runtime
	History *CompositeSlice `json:"history"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// K8s cluster where the runtime is running
	Cluster *string `json:"cluster,omitempty"`
	// Type of installation CLI|HELM|HOSTED
	InstallationType InstallationType `json:"installationType"`
	// Runtime is managed
	Managed bool `json:"managed"`
	// Ignore security and git token updates users
	IgnoreSecurityAndGitTokenUpdatesUsers []string `json:"ignoreSecurityAndGitTokenUpdatesUsers,omitempty"`
	// At least one remote cluster is connected (for managed runtimes)
	IsRemoteClusterConnected bool `json:"isRemoteClusterConnected"`
	// Ingress host of the runtime
	IngressHost *string `json:"ingressHost,omitempty"`
	// Internal Ingress host of the runtime - for app proxy usage only
	InternalIngressHost *string `json:"internalIngressHost,omitempty"`
	// Ingress class of the runtime
	IngressClass *string `json:"ingressClass,omitempty"`
	// Ingress controller of the runtime
	IngressController *string `json:"ingressController,omitempty"`
	// Gateway name
	GatewayName *string `json:"gatewayName,omitempty"`
	// Gateway namespace
	GatewayNamespace *string `json:"gatewayNamespace,omitempty"`
	// Runtime version
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// Chart version
	ChartVersion *string `json:"chartVersion,omitempty"`
	// Runtime release information
	RuntimeRelease *Release `json:"runtimeRelease"`
	// Last Updated
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Installation Status
	InstallationStatus InstallationStatus `json:"installationStatus"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo,omitempty"`
	// Clusters managed by this runtime
	ManagedClusters []*Cluster `json:"managedClusters"`
	// Total number of clusters managed by this runtime
	ManagedClustersNum int `json:"managedClustersNum"`
	// Runtime features
	Features []*RuntimeFeature `json:"features"`
	// The git provider of the installation repo
	GitProvider *GitProviders `json:"gitProvider,omitempty"`
	// The access mode to the runtime - INGRESS|TUNNEL
	AccessMode AccessMode `json:"accessMode"`
	// Flag for managed runtime to indicate if ISC was initialized
	IscInitialized *bool `json:"iscInitialized,omitempty"`
	// True if lastHeartbeat was recent than some cutoff (if no lastHeartbeat available, checks updatedAt instead)
	Available bool `json:"available"`
	// Status
	Status *RuntimeStatus `json:"status"`
	// True if the runtime is a configuration runtime
	IsConfigurationRuntime bool `json:"isConfigurationRuntime"`
}

func (Runtime) IsBaseEntity() {}

func (Runtime) IsProjectBasedEntity() {}

func (Runtime) IsK8sLogicEntity() {}

func (Runtime) IsEntity() {}

// Response for creating a runtime
type RuntimeCreationResponse struct {
	// The runtime access token that will be used for requests from the runtime
	NewAccessToken string `json:"newAccessToken"`
	// The name of the newly created runtime
	Name string `json:"name"`
}

// Runtime Edge
type RuntimeEdge struct {
	// Node contains the actual runtime data
	Node *Runtime `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (RuntimeEdge) IsEdge() {}

// Runtime Feature
type RuntimeFeature struct {
	// Runtime feature name
	Name string `json:"name"`
	// Is feature supported
	Supported bool `json:"supported"`
	// Minimal runtime version supporting the feature
	RequiredVersion *string `json:"requiredVersion,omitempty"`
}

// RuntimeInfo
type RuntimeInfo struct {
	// Name
	Name *string `json:"name,omitempty"`
}

// Runtime Installation Arguments
type RuntimeInstallationArgs struct {
	// Name of the Runtime
	RuntimeName string `json:"runtimeName"`
	// Namespace of the Runtime
	RuntimeNamespace *string `json:"runtimeNamespace,omitempty"`
	// Cluster
	Cluster string `json:"cluster"`
	// Type of installation CLI|HELM|HOSTED
	InstallationType *InstallationType `json:"installationType,omitempty"`
	// Managed runtime (default false)
	Managed *bool `json:"managed,omitempty"`
	// The git provider of the installation repo
	GitProvider *GitProviders `json:"gitProvider,omitempty"`
	// Runtime Version
	RuntimeVersion string `json:"runtimeVersion"`
	// Chart Version
	ChartVersion *string `json:"chartVersion,omitempty"`
	// The names of the components to be installed as placeholders
	ComponentNames []string `json:"componentNames"`
	// Ingress Host
	IngressHost *string `json:"ingressHost,omitempty"`
	// Internal Ingress Host
	InternalIngressHost *string `json:"internalIngressHost,omitempty"`
	// Ingress class name
	IngressClass *string `json:"ingressClass,omitempty"`
	// Ingress controller name
	IngressController *string `json:"ingressController,omitempty"`
	// Gateway name
	GatewayName *string `json:"gatewayName,omitempty"`
	// Gateway namespace
	GatewayNamespace *string `json:"gatewayNamespace,omitempty"`
	// Repo URL with optional path and branch info
	Repo *string `json:"repo,omitempty"`
	// Does runtime installed from an existing repo
	Recover *bool `json:"recover,omitempty"`
	// The access mode to the runtime - INGRESS|TUNNEL
	AccessMode *AccessMode `json:"accessMode,omitempty"`
}

// Runtime Integarion Response
type RuntimeIntegration struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
	// Config Name
	Config *NamedResource `json:"config,omitempty"`
	// Secret Name
	Secret *NamedResource `json:"secret,omitempty"`
}

// Runtume Notification
type RuntimeNotification struct {
	// Metadata object of the k8s entity
	Metadata *ObjectMeta `json:"metadata"`
	// Action type
	Action *NotificationActionType `json:"action,omitempty"`
	// Notification unique id
	ID string `json:"id"`
	// Account id
	AccountID string `json:"accountId"`
	// Text of error or warning message
	Text *string `json:"text,omitempty"`
	// Notification kind
	Kind string `json:"kind"`
	// State of notification
	State *NotificationState `json:"state,omitempty"`
	// Timestamp of notification
	Timestamp string `json:"timestamp"`
	// Notification type
	NotificationType NotificationType `json:"notificationType"`
}

func (RuntimeNotification) IsNotification() {}

func (RuntimeNotification) IsArgoCDNotification() {}

// IntegrationGenerationInput
type RuntimeOperation struct {
	// Runtime
	Runtime string `json:"runtime"`
	// Runtime
	Name string `json:"name"`
	// Runtime
	Action RuntimeOperationAction `json:"action"`
}

// RuntimeReadModelEventPayload type
type RuntimeReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (RuntimeReadModelEventPayload) IsReadModelEventPayload() {}

// Runtime Slice
type RuntimeSlice struct {
	// Runtime edges
	Edges []*RuntimeEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (RuntimeSlice) IsSlice() {}

// RuntimeStatus
type RuntimeStatus struct {
	// App-Proxy Started
	AppProxyStarted *AppProxyInfo `json:"appProxyStarted"`
	// Default Git Integration
	DefaultGitIntegration *AppProxyInfo `json:"defaultGitIntegration"`
	// Encryption Key
	EncryptionKey *AppProxyInfo `json:"encryptionKey"`
	// Encryption IV
	EncryptionIv *AppProxyInfo `json:"encryptionIv"`
	// Event-Reporter Argo-CD Token
	EventReporterArgoCDToken *AppProxyInfo `json:"eventReporterArgoCDToken"`
	// ISC
	Isc *AppProxyInfo `json:"isc"`
	// Runtime Git Token
	RuntimeGitToken *AppProxyInfo `json:"runtimeGitToken"`
	// Runtime Sync Mode
	SyncMode RuntimeSyncMode `json:"syncMode"`
}

// Runtimes statistics
type RuntimesStatistics struct {
	// Total runtimes number
	Total int `json:"total"`
	// Number of unhealthy runtimes
	Unhealthy int `json:"unhealthy"`
}

// SSOArgs
type SSOArgs struct {
	// Id
	ID *string `json:"id,omitempty"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName *string `json:"clientName,omitempty"`
	// Display name
	DisplayName string `json:"displayName"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Entry point
	EntryPoint *string `json:"entryPoint,omitempty"`
	// Callback url
	CallbackURL *string `json:"callbackUrl,omitempty"`
	// Cert
	Cert *string `json:"cert,omitempty"`
	// Provider
	Provider *string `json:"provider,omitempty"`
	// Keyfile
	Keyfile *string `json:"keyfile,omitempty"`
	// Subject
	Subject *string `json:"subject,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// SyncField
	SyncField *string `json:"syncField,omitempty"`
	// App Id
	AppID *string `json:"appId,omitempty"`
	// Tenant
	Tenant *string `json:"tenant,omitempty"`
	// Password
	Password *string `json:"password,omitempty"`
	// URL
	URL *string `json:"url,omitempty"`
	// Distinguished name
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// Search base
	SearchBase *string `json:"searchBase,omitempty"`
	// Search filter
	SearchFilter *string `json:"searchFilter,omitempty"`
	// Certificate
	Certificate *string `json:"certificate,omitempty"`
	// Allowed groups for sync
	AllowedGroupsForSync *string `json:"allowedGroupsForSync,omitempty"`
	// Search base for sync
	SearchBaseForSync *string `json:"searchBaseForSync,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// API client id
	APIClientID *string `json:"apiClientId,omitempty"`
	// API client id
	APIClientSecret *string `json:"apiClientSecret,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Host
	Host *string `json:"host,omitempty"`
	// Realm
	Realm *string `json:"realm,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
	// Sync mirror accounts
	SyncMirrorAccounts []*string `json:"syncMirrorAccounts,omitempty"`
	// Remove deactivated users after sync
	RemoveDeactivatedUsers *bool `json:"removeDeactivatedUsers,omitempty"`
}

// SamlSSO
type SamlSso struct {
	// ID
	ID string `json:"id"`
	// Client type
	ClientType string `json:"clientType"`
	// Client name
	ClientName string `json:"clientName"`
	// Display name
	DisplayName string `json:"displayName"`
	// Accounts
	Accounts []*string `json:"accounts,omitempty"`
	// Access token
	AccessToken *string `json:"accessToken,omitempty"`
	// Client Id, appId in Azure
	ClientID *string `json:"clientId,omitempty"`
	// Client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Onprem default IDP
	OnpremDefaultIdp *bool `json:"onpremDefaultIdp,omitempty"`
	// Redirect url
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// Redirect ui url
	RedirectUIURL *string `json:"redirectUiUrl,omitempty"`
	// Login url
	LoginURL *string `json:"loginUrl,omitempty"`
	// Default
	Default *bool `json:"default,omitempty"`
	// Entry point
	EntryPoint *string `json:"entryPoint,omitempty"`
	// Callback url
	CallbackURL *string `json:"callbackUrl,omitempty"`
	// Cert
	Cert *string `json:"cert,omitempty"`
	// Provider
	Provider *string `json:"provider,omitempty"`
	// Keyfile
	Keyfile *string `json:"keyfile,omitempty"`
	// Subject
	Subject *string `json:"subject,omitempty"`
	// Auto group sync
	AutoGroupSync *bool `json:"autoGroupSync,omitempty"`
	// Sync interval
	SyncInterval *string `json:"syncInterval,omitempty"`
	// Sync interval
	SyncIntervalType *string `json:"syncIntervalType,omitempty"`
	// SyncField
	SyncField *string `json:"syncField,omitempty"`
	// Client host
	ClientHost *string `json:"clientHost,omitempty"`
	// Application ID
	AppID *string `json:"appId,omitempty"`
	// Activate user after sync
	ActivateUserAfterSync *bool `json:"activateUserAfterSync,omitempty"`
}

func (SamlSso) IsIDP() {}

// SecretData
type SecretData struct {
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace string `json:"namespace"`
	// Path
	Path *SecretPath `json:"path"`
}

// GitAuthConfig form spec
type SecretDataInput struct {
	// Secret name
	Name string `json:"name"`
	// Secret namespace
	Namespace *string `json:"namespace,omitempty"`
	// Secret filed paths
	Path *SecretFieldPaths `json:"path"`
}

// SecretFieldPaths
type SecretFieldPaths struct {
	// AppId
	AppID string `json:"appId"`
	// ClientId
	ClientID string `json:"clientId"`
	// ClientSecret
	ClientSecret string `json:"clientSecret"`
	// Url
	URL string `json:"url"`
}

// SecretKeySelector selects a key of a Secret.
type SecretKeySelector struct {
	// Name of the referent.
	Name string `json:"name"`
	// The key of the secret to select from. Must be a valid secret key.
	Key string `json:"key"`
}

// SecretPath
type SecretPath struct {
	// AppId
	AppID string `json:"appId"`
	// ClientId
	ClientID string `json:"clientId"`
	// ClientSecret
	ClientSecret string `json:"clientSecret"`
	// Url
	URL string `json:"url"`
}

// Security info for account
type SecurityInfo struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold,omitempty"`
}

// Args to set security for account
type SecurityInfoArgs struct {
	// Security duration limit in minutes, before inactive user will be logged out of the app
	InactivityThreshold *int `json:"inactivityThreshold,omitempty"`
}

// Sensor entity
type Sensor struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the sensor
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
}

func (Sensor) IsGitopsEntity() {}

func (Sensor) IsBaseEntity() {}

func (Sensor) IsProjectBasedEntity() {}

func (Sensor) IsEntity() {}

// Sensor Edge
type SensorEdge struct {
	// Node contains the actual sensor data
	Node *Sensor `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (SensorEdge) IsEdge() {}

// SensorReadModelEventPayload type
type SensorReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (SensorReadModelEventPayload) IsReadModelEventPayload() {}

// Sensor Slice
type SensorSlice struct {
	// Sensor edges
	Edges []*SensorEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (SensorSlice) IsSlice() {}

// Service entity
type ServiceEntity struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the generic entity
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// ServiceSpec
	Spec *ServiceSpec `json:"spec"`
	// ServiceStatus
	Status *ServiceStatus `json:"status"`
	// Deployment Spec Part
	Deployments []*DeploymentSpecPart `json:"deployments,omitempty"`
}

func (ServiceEntity) IsGitopsEntity() {}

func (ServiceEntity) IsBaseEntity() {}

func (ServiceEntity) IsProjectBasedEntity() {}

func (ServiceEntity) IsEntity() {}

// Service Entity Edge
type ServiceEntityEdge struct {
	// Node contains the actual Service data
	Node *ServiceEntity `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (ServiceEntityEdge) IsEdge() {}

// Service Slice
type ServiceEntitySlice struct {
	// Service edges
	Edges []*ServiceEntityEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (ServiceEntitySlice) IsSlice() {}

// Service Item Entity
type ServiceItem struct {
	// Name
	Name *string `json:"name,omitempty"`
}

// ServicePort
type ServicePort struct {
	// AppProtocol
	AppProtocol *string `json:"appProtocol,omitempty"`
	// Name
	Name *string `json:"name,omitempty"`
	// NodePort
	NodePort *int `json:"nodePort,omitempty"`
	// Port
	Port *int `json:"port,omitempty"`
	// Protocol
	Protocol *string `json:"protocol,omitempty"`
	// TargetPort
	TargetPort *string `json:"targetPort,omitempty"`
}

// ServiceReadModelEventPayload type
type ServiceReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Runtime
	Runtime *string `json:"runtime,omitempty"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (ServiceReadModelEventPayload) IsReadModelEventPayload() {}

// Service sorting arguments
type ServiceSortArg struct {
	// Field for sorting
	Field ServiceSortingField `json:"field"`
	// Order
	Order SortingOrder `json:"order"`
}

// ServiceSpec
type ServiceSpec struct {
	// AllocateLoadBalancerNodePorts
	AllocateLoadBalancerNodePorts *bool `json:"allocateLoadBalancerNodePorts,omitempty"`
	// ClusterIP
	ClusterIP *string `json:"clusterIP,omitempty"`
	// ClusterIPs
	ClusterIPs []*string `json:"clusterIPs,omitempty"`
	// ExternalIPs
	ExternalIPs []*string `json:"externalIPs,omitempty"`
	// ExternalName
	ExternalName *string `json:"externalName,omitempty"`
	// ExternalTrafficPolicy
	ExternalTrafficPolicy *string `json:"externalTrafficPolicy,omitempty"`
	// HealthCheckNodePort
	HealthCheckNodePort *int `json:"healthCheckNodePort,omitempty"`
	// InternalTrafficPolicy
	InternalTrafficPolicy *string `json:"internalTrafficPolicy,omitempty"`
	// IpFamilies
	IPFamilies []*string `json:"ipFamilies,omitempty"`
	// IpFamilyPolicy
	IPFamilyPolicy *string `json:"ipFamilyPolicy,omitempty"`
	// LoadBalancerClass
	LoadBalancerClass *string `json:"loadBalancerClass,omitempty"`
	// LoadBalancerIP
	LoadBalancerIP *string `json:"loadBalancerIP,omitempty"`
	// LoadBalancerSourceRanges
	LoadBalancerSourceRanges []*string `json:"loadBalancerSourceRanges,omitempty"`
	// Ports
	Ports []*ServicePort `json:"ports,omitempty"`
	// PublishNotReadyAddresses
	PublishNotReadyAddresses *bool `json:"publishNotReadyAddresses,omitempty"`
	// Selector
	Selector []*StringPair `json:"selector,omitempty"`
	// SessionAffinity
	SessionAffinity *string `json:"sessionAffinity,omitempty"`
	// SessionAffinityConfig
	SessionAffinityConfig *SessionAffinityConfig `json:"sessionAffinityConfig,omitempty"`
	// Type
	Type *ServiceType `json:"type,omitempty"`
}

// ServiceStatus
type ServiceStatus struct {
	// LoadBalancer
	LoadBalancer *LoadBalancer `json:"loadBalancer,omitempty"`
}

// ServiceTransition Entity
type ServiceTransition struct {
	// Name
	Name string `json:"name"`
	// From
	From *ReleaseServiceState `json:"from,omitempty"`
	// To
	To *ReleaseServiceState `json:"to,omitempty"`
}

// ServiceUser
type ServiceUser struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin,omitempty"`
	// The accounts the this user have access to
	Accounts []*Account `json:"accounts,omitempty"`
	// Register date
	RegisterDate *string `json:"registerDate,omitempty"`
	// Is service
	IsService *bool `json:"isService,omitempty"`
	// Is disabled
	IsDisabled *bool `json:"isDisabled,omitempty"`
	// Service user teams
	Teams []*ServiceUserTeam `json:"teams"`
	// Service user api keys
	APIKeys []*APIKey `json:"apiKeys"`
}

// ServiceUserArgs
type ServiceUserArgs struct {
	// The user name
	UserName string `json:"userName"`
	// Team ids
	TeamIds []string `json:"teamIds,omitempty"`
	// Assign admin role
	AssignAdminRole *bool `json:"assignAdminRole,omitempty"`
}

// ServiceUserFilter
type ServiceUserFilter struct {
	// The partial service user name
	PartialName *string `json:"partialName,omitempty"`
	// The team IDs
	TeamIds []string `json:"teamIds,omitempty"`
}

// ServiceUserTeam
type ServiceUserTeam struct {
	// The team id
	ID string `json:"id"`
	// The team name
	Name string `json:"name"`
	// The team account ID
	Account string `json:"account"`
	// The team userIds
	Users []*string `json:"users"`
	// The team tags
	Tags []*string `json:"tags"`
	// The team type
	Type *string `json:"type,omitempty"`
	// The team create time
	CreatedAt *string `json:"createdAt,omitempty"`
	// The team update time
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Services filter arguments
type ServicesFilterArgs struct {
	// Filter services from a specific project
	Project *string `json:"project,omitempty"`
	// Filter services from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter services from a specific namespaces
	Namespace []string `json:"namespace,omitempty"`
	// Filter services by groups
	Groups []string `json:"groups,omitempty"`
	// Filter services by versions
	Versions []string `json:"versions,omitempty"`
	// Filter services from a specific application
	Application *string `json:"application,omitempty"`
	// Filter services with a specific health statuses
	HealthStatus []HealthStatus `json:"healthStatus,omitempty"`
	// Filter services by name fragment
	ServiceName *string `json:"serviceName,omitempty"`
	// Filter services by cluster URL
	Cluster *string `json:"cluster,omitempty"`
}

// SessionAffinityConfig
type SessionAffinityConfig struct {
	// ClientIP
	ClientIP *ClientIP `json:"clientIP,omitempty"`
}

// Args to set allowed domains for account
type SetAccountAllowedDomainsArgs struct {
	// Controls if this account can edit its allowedDomains
	EnabledAllowedDomains *bool `json:"enabledAllowedDomains,omitempty"`
	// All allowed domains for this account
	AllowedDomains []string `json:"allowedDomains,omitempty"`
}

// Args to set the permissions of a specific user to a git-source
type SetGitSourcePermissionArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace,omitempty"`
	// The new permission to set
	Permission *PermissionInput `json:"permission"`
}

// Single dependency item
type SingleComponentDependency struct {
	// Name of dependency
	Name string `json:"name"`
	// Version
	Version string `json:"version"`
}

// Information about current slice
type SliceInfo struct {
	// Cursor for the first result in the slice
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last result in the slice
	EndCursor *string `json:"endCursor,omitempty"`
	// Indicate if there is next slice
	HasNextPage bool `json:"hasNextPage"`
	// Indicate if there is previous slice
	HasPrevPage bool `json:"hasPrevPage"`
}

// Pagination arguments to request slice
type SlicePaginationArgs struct {
	// Returns entities after the provided cursor
	After *string `json:"after,omitempty"`
	// Returns entities before the provided cursor
	Before *string `json:"before,omitempty"`
	// Returns the first X entities
	First *int `json:"first,omitempty"`
	// Returns the last X entities
	Last *int `json:"last,omitempty"`
}

// Object of specific trigger conditions
type SpecificTriggerConditions struct {
	// Github trigger conditions
	Github []*GithubTriggerConditions `json:"github,omitempty"`
	// Gitlab trigger conditions
	Gitlab []*GitlabTriggerConditions `json:"gitlab,omitempty"`
	// BitbucketServer trigger conditions
	Bitbucketserver []*BitbucketServerTriggerConditions `json:"bitbucketserver,omitempty"`
	// BitbucketCloud trigger conditions
	Bitbucket []*BitbucketCloudTriggerConditions `json:"bitbucket,omitempty"`
	// Calendar trigger conditions
	Calendar []*CalendarTriggerConditions `json:"calendar,omitempty"`
}

// Object of specific trigger conditions
type SpecificTriggerConditionsArgs struct {
	// Github trigger conditions
	Github []*GithubTriggerConditionsArgs `json:"github,omitempty"`
	// Gitlab trigger conditions
	Gitlab []*GitlabTriggerConditionsArgs `json:"gitlab,omitempty"`
	// BitbucketServer trigger conditions
	Bitbucketserver []*BitbucketServerTriggerConditionsArgs `json:"bitbucketserver,omitempty"`
	// BitbucketCloud trigger conditions
	Bitbucket []*BitbucketCloudTriggerConditionsArgs `json:"bitbucket,omitempty"`
	// Calendar trigger conditions
	Calendar []*CalendarTriggerConditionsArgs `json:"calendar,omitempty"`
}

// Sso
type Sso struct {
	// The sso id
	ID string `json:"id"`
	// Client type name
	ClientType *string `json:"clientType,omitempty"`
	// Display name
	DisplayName *string `json:"displayName,omitempty"`
}

// Statistics Date Range Filter
type StatisticsDateRangeFilterWithTz struct {
	// Start Date From
	StartDateFrom string `json:"startDateFrom"`
	// Start Date To
	StartDateTo string `json:"startDateTo"`
	// Client Time zone
	Timezone string `json:"timezone"`
}

// Statistics time period meta data
type StatsTimePeriodData struct {
	// Granularity for the graph X Axis
	Granularity *string `json:"granularity,omitempty"`
	// Date range for the statistics
	DateRange []*string `json:"dateRange,omitempty"`
	// Prev data range
	PrevDateRange []*string `json:"prevDateRange,omitempty"`
}

// Workflow status history item
type StatusHistoryItem struct {
	// The time the status started
	Since string `json:"since"`
	// Phase
	Phase WorkflowNodePhases `json:"phase"`
	// Message
	Message *string `json:"message,omitempty"`
}

// Label
type StringPair struct {
	// Key
	Key string `json:"key"`
	// Value
	Value string `json:"value"`
}

// Stripe
type Stripe struct {
	// Name
	HardCodedPlan *bool `json:"hardCodedPlan,omitempty"`
	// Plan id
	PlanID *string `json:"planId,omitempty"`
	// Subscription id
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// Customer id
	CustomerID *string `json:"customerId,omitempty"`
}

// Subscription
type Subscription struct {
}

// Event filter
type SupportedEventMapping struct {
	// Logic name
	Key string `json:"key"`
	// Human friendly name
	Name string `json:"name"`
	// Mappings between the var name and the path to the value in event payload
	Mappings []*Mapping `json:"mappings"`
}

// "response for request to switch account
type SwitchAccountResponse struct {
	// The token to use for the next requests
	NewAccessToken *string `json:"newAccessToken,omitempty"`
}

// Sync Error
type SyncError struct {
	// Level
	Level ErrorLevels `json:"level"`
	// Title
	Title string `json:"title"`
	// Message
	Message string `json:"message"`
	// Suggestion
	Suggestion *string `json:"suggestion,omitempty"`
	// The entity related to this error
	Object BaseEntity `json:"object,omitempty"`
	// Error code
	Code SyncErrorCodes `json:"code"`
	// Last time this error has been seen
	LastSeen string `json:"lastSeen"`
	// Error gitops context
	Context *ErrorContext `json:"context,omitempty"`
}

func (SyncError) IsError() {}

// Aplication SyncResultResource
type SyncResultResource struct {
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Name
	Name string `json:"name"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
	// Message
	Message *string `json:"message,omitempty"`
	// Sync Action On Resource
	SyncActionOnResource *SyncActionOnResource `json:"syncActionOnResource,omitempty"`
	// Status
	Status *SyncResultCode `json:"status,omitempty"`
	// Sync Phase
	SyncPhase *SyncPhase `json:"syncPhase,omitempty"`
	// Hook Phase
	HookPhase *SyncOperationPhase `json:"hookPhase,omitempty"`
	// Hook Type
	HookType *SyncHookType `json:"hookType,omitempty"`
}

// SystemTypeOutput
type SystemTypeOutput struct {
	// SystemType
	SystemType SystemType `json:"systemType"`
}

// Team
type Team struct {
	// Team name
	Name string `json:"name"`
	// Team ID
	ID string `json:"id"`
	// Account ID
	Account *string `json:"account,omitempty"`
	// List of users in team
	Users []*User `json:"users,omitempty"`
	// Team tags
	Tags []*string `json:"tags,omitempty"`
	// Team type
	Type *TeamType `json:"type,omitempty"`
	// Team ref id
	RefID *string `json:"refId,omitempty"`
	// Team source
	Source *TeamSource `json:"source,omitempty"`
}

// Time Series Data Record
type TimeSeriesDataRecord struct {
	// Time
	Time string `json:"time"`
	// Value
	Value int `json:"value"`
}

// To State Entity
type ToState struct {
	// Services - for Deployments
	Services []*ServiceItem `json:"services"`
	// Rollouts
	Rollouts []*ReleaseRolloutState `json:"rollouts"`
}

// Transition Entity
type Transition struct {
	// Services
	Services []*ServiceTransition `json:"services"`
	// Rollouts
	Rollouts []*RolloutTransition `json:"rollouts"`
}

// Trial
type Trial struct {
	// Trialing
	Trialing *bool `json:"trialing,omitempty"`
	// IsRuntimePaying
	IsRuntimePaying *bool `json:"isRuntimePaying,omitempty"`
	// TrialWillEndNotified
	TrialWillEndNotified *bool `json:"trialWillEndNotified,omitempty"`
	// TrialEndedNotified
	TrialEndedNotified *bool `json:"trialEndedNotified,omitempty"`
	// Type
	Type *string `json:"type,omitempty"`
	// PreviousSegment
	PreviousSegment *string `json:"previousSegment,omitempty"`
	// TrialEnd
	TrialEnd *string `json:"trialEnd,omitempty"`
}

// Differentiated DataFilters
type TriggerConditionDataFilters struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilter `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilter `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilter `json:"predefined"`
}

// Differentiated DataFilters
type TriggerConditionDataFiltersArgs struct {
	// Implicit filters are derived from Event Type (push.heads, pull_request.merge etc)
	Implicit []*DataFilterArgs `json:"implicit"`
	// Custom are just regular data filters added by the user
	Custom []*DataFilterArgs `json:"custom"`
	// Predefinded are the filters like by branch, by repo etc
	Predefined []*PredefinedFilterArgs `json:"predefined"`
}

// TriggerConditions filters object
type TriggerConditionFilters struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFilters `json:"data"`
}

// TriggerConditions filters object
type TriggerConditionFiltersArgs struct {
	// Data are DataFilters from argo events
	Data *TriggerConditionDataFiltersArgs `json:"data"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameter struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation,omitempty"`
}

// Parameters choosen for each event type (push, pull_request...)
type TriggerConditionParameterArgs struct {
	// Corresponding name of the workflow parameter on sensor to be injected instead
	Name string `json:"name"`
	// String containing gotemplate
	DataTemplate string `json:"dataTemplate"`
	// Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it
	Operation *string `json:"operation,omitempty"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditions struct {
	// Conditions
	Conditions *SpecificTriggerConditions `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflow `json:"workflow"`
}

// Trigger Conditions that tell how a pipeline is being triggered
type TriggerConditionsArgs struct {
	// Sensor name
	SensorName string `json:"sensorName"`
	// Trigger name
	TriggerName string `json:"triggerName"`
	// Ingress host (SET ON BACKEND)
	IngressHost *string `json:"ingressHost,omitempty"`
	// Conditions
	Conditions *SpecificTriggerConditionsArgs `json:"conditions"`
	// Submitted workflow configuration
	Workflow *TriggerConditionsWorkflowArgs `json:"workflow"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflow struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint,omitempty"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameter `json:"parameters"`
}

// Submitted workflow template configuration and default parameters
type TriggerConditionsWorkflowArgs struct {
	// Name of the referenced WorkflowTemplate
	Name string `json:"name"`
	// Entrypoint template of the referenced WorkflowTemplate (can be set just on the WorkflowTemplate, so may be null here)
	Entrypoint *string `json:"entrypoint,omitempty"`
	// Default workflow parameters to be passed from sensor
	Parameters []*WorkflowParameterArgs `json:"parameters"`
}

// Reference Entity by uid
type UIDReferenceInput struct {
	// GVK/group
	Group string `json:"group"`
	// GVK/version
	Version string `json:"version"`
	// GVK/kind
	Kind string `json:"kind"`
	// Unique ID
	UID string `json:"uid"`
}

// Calendar event payload data
type UnknownEventPayloadData struct {
	// Event payload type
	Type PayloadDataTypes `json:"type"`
	// Event uid
	UID string `json:"uid"`
	// Event source name
	EventSource *string `json:"eventSource,omitempty"`
	// The relevant event name in the event source
	EventName *string `json:"eventName,omitempty"`
	// Event name
	Event string `json:"event"`
}

func (UnknownEventPayloadData) IsEventPayloadData() {}

// Update Environment Input
type UpdateEnvironmentArgs struct {
	// Id of the environment
	ID string `json:"id"`
	// Environment name
	Name string `json:"name"`
	// Kind of environment
	Kind EnvironmentKind `json:"kind"`
	// List of clusters that belong to this environment
	Clusters []*EnvironmentClusterInput `json:"clusters"`
}

// Args to update the permissions of a git-source
type UpdateGitSourcePermissionsArgs struct {
	// The name of the git-source the update is for
	GitSource string `json:"gitSource"`
	// The namespace of the git-source
	Namespace *string `json:"namespace,omitempty"`
	// The set of permissions
	Permissions []*PermissionInput `json:"permissions"`
}

// Update Product Input
type UpdateProductArgs struct {
	// Id of the Product
	ID string `json:"id"`
	// Product name
	Name string `json:"name"`
	// Tags list
	Tags []*string `json:"tags"`
}

// User
type User struct {
	// The user id
	ID string `json:"id"`
	// The user name
	Name string `json:"name"`
	// The user email
	Email string `json:"email"`
	// User image url
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// Is the user have system admin permission
	IsAdmin *bool `json:"isAdmin,omitempty"`
	// The accounts the this user have acsess to
	Accounts []*Account `json:"accounts,omitempty"`
	// The default account for this user
	ActiveAccount *Account `json:"activeAccount,omitempty"`
	// The customers that this user is in
	Customers []Customer `json:"customers,omitempty"`
	// The current status of this user
	Status string `json:"status"`
	// Register date
	RegisterDate *string `json:"registerDate,omitempty"`
	// Last time user logged in to the system
	LastLoginDate *string `json:"lastLoginDate,omitempty"`
	// User chosen sso of active account
	Sso *string `json:"sso,omitempty"`
	// User settings
	Settings *UserSettings `json:"settings,omitempty"`
	// GitOps settings
	GitOpsSettings []*GitOpsSettings `json:"gitOpsSettings,omitempty"`
	// Runtime name
	RuntimeName *string `json:"runtimeName,omitempty"`
}

// Args to edit user details
type UserDetailsArgs struct {
	// User settings
	Settings *UserSettingsArgs `json:"settings,omitempty"`
}

// User settings
type UserSettings struct {
	// Allow admin to login
	AllowAdminToLogin *bool `json:"allowAdminToLogin,omitempty"`
	// Display welcome screen
	DisplayWelcomeScreen *bool `json:"displayWelcomeScreen,omitempty"`
}

// Args to edit settings user details
type UserSettingsArgs struct {
	// Allow admin to login
	AllowAdminToLogin *bool `json:"allowAdminToLogin,omitempty"`
}

// Workflow entity
type Workflow struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
	// Workflow status
	Status *WorkflowStatus `json:"status"`
	// Initiator of the workflow
	Initiator *WorkflowInitiator `json:"initiator,omitempty"`
	// Events payload Data
	EventsPayloadData []EventPayloadData `json:"eventsPayloadData"`
	// Events payload references
	EventsPayload []string `json:"eventsPayload"`
	// Pipeline reference
	Pipeline *Pipeline `json:"pipeline,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Workflow URL. Maybe empty if the runtime was deleted.
	URL *string `json:"url,omitempty"`
	// Workflow's runtime ingress host. Maybe empty if the runtime was deleted.
	IngressHost *string `json:"ingressHost,omitempty"`
	// Workflow's runtime version. Maybe empty if the runtime was deleted.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
	// Indicates that workflow was created by platform/app-proxy and the value shows the flow that caused the creation
	OriginatedFrom *string `json:"originatedFrom,omitempty"`
	// Workflows which executed by this workflow
	ChildWorkflows []*ChildWorkflowRef `json:"childWorkflows,omitempty"`
	// Parent workflow that executed this workflow
	ParentWorkflow *ParentWorkflowRef `json:"parentWorkflow,omitempty"`
	// Image details that was created from report image workflow execution.
	ImageDetails *ImageDetails `json:"imageDetails,omitempty"`
}

func (Workflow) IsProjectBasedEntity() {}

func (Workflow) IsBaseEntity() {}

func (Workflow) IsK8sStandardEntity() {}

func (Workflow) IsEntity() {}

// WorkflowArguments
type WorkflowArguments struct {
	// Workflow parameters
	Parameters []*WorkflowParameter `json:"parameters,omitempty"`
}

// Classic Pipeline filter arguments
type WorkflowClassicStatisticsFilterArgs struct {
	// Date range filter
	DateRange *StatisticsDateRangeFilterWithTz `json:"dateRange"`
	// build status
	Status []string `json:"status,omitempty"`
	// Pipeline Id
	PipelineID []string `json:"pipelineId,omitempty"`
	// Project Id
	ProjectID []string `json:"projectId,omitempty"`
	// Pipeline Tags
	PipelineTagID []string `json:"pipelineTagId,omitempty"`
	// IsFavorites
	IsFavorites *bool `json:"isFavorites,omitempty"`
}

// WorkflowConcurrency
type WorkflowConcurrency struct {
	// Concurrency
	Concurrency *WorkflowConcurrencyInfo `json:"concurrency,omitempty"`
}

// WorkflowConcurrency
type WorkflowConcurrencyInfo struct {
	// Price
	Price *BasePrice `json:"price,omitempty"`
	// Amount
	Amount *int `json:"amount,omitempty"`
	// Absorb
	Absorb *int `json:"absorb,omitempty"`
	// Min
	Min *int `json:"min,omitempty"`
	// Max
	Max *int `json:"max,omitempty"`
	// AllowUnlimited
	AllowUnlimited *bool `json:"allowUnlimited,omitempty"`
}

// Workflow conditions
type WorkflowConditions struct {
	// Type
	Type *string `json:"type,omitempty"`
	// Status
	Status *string `json:"status,omitempty"`
}

// Workflow step
type WorkflowContainerSpec struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Image
	Image *string `json:"image,omitempty"`
	// Command array
	Command []*string `json:"command,omitempty"`
	// Args
	Args []*string `json:"args,omitempty"`
	// Env map
	Env []*StringPair `json:"env,omitempty"`
}

// Workflow container template
type WorkflowContainerTemplate struct {
	// Name
	Name string `json:"name"`
	// Daemon
	Daemon *bool `json:"daemon,omitempty"`
	// Container
	Container *WorkflowContainerSpec `json:"container,omitempty"`
}

func (WorkflowContainerTemplate) IsWorkflowSpecTemplate() {}

// Workflow DAG task
type WorkflowDAGTask struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName,omitempty"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef,omitempty"`
}

// Workflow DAG template
type WorkflowDAGTemplate struct {
	// Name
	Name string `json:"name"`
	// Tasks
	Tasks []*WorkflowDAGTask `json:"tasks"`
	// Fail on first failed task
	FailFast *bool `json:"failFast,omitempty"`
}

func (WorkflowDAGTemplate) IsWorkflowSpecTemplate() {}

// Workflow Edge
type WorkflowEdge struct {
	// Node contains the actual workflow data
	Node *Workflow `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowEdge) IsEdge() {}

// If the workflow created through the wt playground it will contain username and avatar URL of codefresh user.
// If the workflow was triggered by some GIT event it will contain username and avatar URL of git user.
// Otherwise this field will be empty.
type WorkflowInitiator struct {
	// Initiator name
	Name string `json:"name"`
	// Initiator avatar URL
	AvatarURL *string `json:"avatarURL,omitempty"`
}

// Workflow last execution object
type WorkflowLastExecution struct {
	// Arguments
	Arguments *WorkflowArguments `json:"arguments,omitempty"`
}

// Workflow Parameter object
type WorkflowParameter struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value,omitempty"`
	// Default value
	Default *string `json:"default,omitempty"`
}

// Workflow Parameter object
type WorkflowParameterArgs struct {
	// Name
	Name string `json:"name"`
	// Value
	Value *string `json:"value,omitempty"`
	// Default value
	Default *string `json:"default,omitempty"`
}

// WorkflowReadModelEventPayload type
type WorkflowReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (WorkflowReadModelEventPayload) IsReadModelEventPayload() {}

// "Repository data for workflows
type WorkflowRepository struct {
	// Repository name
	Name string `json:"name"`
	// Repository owner
	Owner string `json:"owner"`
	// Repository name in format {owner}/{name}
	FullName string `json:"fullName"`
	// Repository URL
	URL string `json:"url"`
}

// Workflow Resource template
type WorkflowResourceTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowResourceTemplate) IsWorkflowSpecTemplate() {}

// Workflow resources duration
type WorkflowResourcesDuration struct {
	// Cpu
	CPU *int `json:"cpu,omitempty"`
	// Memory
	Memory *int `json:"memory,omitempty"`
}

// Workflow script template
type WorkflowScriptTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowScriptTemplate) IsWorkflowSpecTemplate() {}

// Workflow Slice
type WorkflowSlice struct {
	// Workflow edges
	Edges []*WorkflowEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowSlice) IsSlice() {}

// Workflow spec
type WorkflowSpec struct {
	// Entrypoint
	Entrypoint *string `json:"entrypoint,omitempty"`
	// Templates
	Templates []WorkflowSpecTemplate `json:"templates,omitempty"`
	// Workflow template reference
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef,omitempty"`
}

// Workflow spec name only template
type WorkflowSpecNameOnlyTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSpecNameOnlyTemplate) IsWorkflowSpecTemplate() {}

// Pipeline filter arguments
type WorkflowStatisticsFilterArgs struct {
	// Date range filter
	DateRange *StatisticsDateRangeFilterWithTz `json:"dateRange"`
	// Repository name
	RepoName []string `json:"repoName,omitempty"`
	// workflow status
	Status []WorkflowPhases `json:"status,omitempty"`
	// Git Event Type
	GitEventType []string `json:"gitEventType,omitempty"`
	// Initiator
	Initiator []string `json:"initiator,omitempty"`
	// Brnach Name
	Branch []string `json:"branch,omitempty"`
	// Pipeline Name
	PipelineName []string `json:"pipelineName,omitempty"`
	// Pipeline namespace
	PipelineNamespace []string `json:"pipelineNamespace,omitempty"`
	// Runtime
	Runtime []string `json:"runtime,omitempty"`
}

// Workflow status
type WorkflowStatus struct {
	// Start time
	StartedAt *string `json:"startedAt,omitempty"`
	// Finish time
	FinishedAt *string `json:"finishedAt,omitempty"`
	// Current workflow phase
	Phase WorkflowPhases `json:"phase"`
	// Progress
	Progress *string `json:"progress,omitempty"`
	// Current workflow nodes status
	Nodes []*NodeStatus `json:"nodes,omitempty"`
	// Message
	Message *string `json:"message,omitempty"`
	// Previous statuses
	Statuses []*StatusHistoryItem `json:"statuses,omitempty"`
	// Stored Templates
	StoredTemplates *string `json:"storedTemplates,omitempty"`
	// Stored workflow template spec
	StoredWorkflowTemplateSpec *string `json:"storedWorkflowTemplateSpec,omitempty"`
	// Conditions
	Conditions []*WorkflowConditions `json:"conditions,omitempty"`
	// Resources duration
	ResourcesDuration *WorkflowResourcesDuration `json:"resourcesDuration,omitempty"`
	// Amount of running pods
	RunningPodsCount int `json:"runningPodsCount"`
	// Name of the first running pod
	ActivePodName *string `json:"activePodName,omitempty"`
	// Current workflow failed nodes status
	FailedNodes []*NodeStatus `json:"failedNodes,omitempty"`
}

// Workflow step
type WorkflowStep struct {
	// Name
	Name string `json:"name"`
	// Template to execute
	TemplateName *string `json:"templateName,omitempty"`
	// Workflow template ref
	WorkflowTemplateRef *WorkflowTemplateRef `json:"workflowTemplateRef,omitempty"`
}

// Workflow steps template
type WorkflowStepsTemplate struct {
	// Name
	Name string `json:"name"`
	// Steps
	Steps [][]*WorkflowStep `json:"steps"`
}

func (WorkflowStepsTemplate) IsWorkflowSpecTemplate() {}

// Workflow Resource template
type WorkflowSuspendedTemplate struct {
	// Name
	Name string `json:"name"`
}

func (WorkflowSuspendedTemplate) IsWorkflowSpecTemplate() {}

// Workflow template entity
type WorkflowTemplate struct {
	// Object metadata
	Metadata *ObjectMeta `json:"metadata"`
	// Errors
	Errors []Error `json:"errors"`
	// Entities referencing this entity
	ReferencedBy []BaseEntity `json:"referencedBy,omitempty"`
	// Entities referenced by this enitity
	References []BaseEntity `json:"references,omitempty"`
	// History of the workflow-template
	History *GitOpsSlice `json:"history"`
	// Version of the entity
	Version *int `json:"version,omitempty"`
	// Is this the latest version of this entity
	Latest *bool `json:"latest,omitempty"`
	// Entity source
	Source *GitopsEntitySource `json:"source"`
	// Sync status
	SyncStatus SyncStatus `json:"syncStatus"`
	// Health status
	HealthStatus *HealthStatus `json:"healthStatus,omitempty"`
	// Health message
	HealthMessage *string `json:"healthMessage,omitempty"`
	// Desired manifest
	DesiredManifest *string `json:"desiredManifest,omitempty"`
	// Actual manifest
	ActualManifest *string `json:"actualManifest,omitempty"`
	// Projects
	Projects []string `json:"projects,omitempty"`
	// Workflow spec
	Spec *WorkflowSpec `json:"spec"`
}

func (WorkflowTemplate) IsGitopsEntity() {}

func (WorkflowTemplate) IsBaseEntity() {}

func (WorkflowTemplate) IsProjectBasedEntity() {}

func (WorkflowTemplate) IsEntity() {}

// Workflow template Edge
type WorkflowTemplateEdge struct {
	// Node contains the actual workflow template data
	Node *WorkflowTemplate `json:"node"`
	// Cursor
	Cursor string `json:"cursor"`
}

func (WorkflowTemplateEdge) IsEdge() {}

// WorkflowTemplateReadModelEventPayload type
type WorkflowTemplateReadModelEventPayload struct {
	// Type of DB entity
	EntityType string `json:"entityType"`
	// Type of DB event upsert/delete
	EventType string `json:"eventType"`
	// Reference to entity
	Item *EntityReference `json:"item,omitempty"`
}

func (WorkflowTemplateReadModelEventPayload) IsReadModelEventPayload() {}

// Workflow template ref
type WorkflowTemplateRef struct {
	// Name
	Name *string `json:"name,omitempty"`
	// Group
	Group string `json:"group"`
	// Version
	Version string `json:"version"`
	// Kind
	Kind string `json:"kind"`
	// Namespace
	Namespace *string `json:"namespace,omitempty"`
}

// WorkflowTemplate Slice
type WorkflowTemplateSlice struct {
	// Workflow template edges
	Edges []*WorkflowTemplateEdge `json:"edges"`
	// Slice information
	PageInfo *SliceInfo `json:"pageInfo"`
}

func (WorkflowTemplateSlice) IsSlice() {}

// Workflow template filter arguments
type WorkflowTemplatesFilterArgs struct {
	// Filter WorkflowTemplates from a specific project
	Project *string `json:"project,omitempty"`
	// Filter WorkflowTemplates from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter WorkflowTemplates from a specific cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Filter WorkflowTemplates by name
	Name *string `json:"name,omitempty"`
	// Filter WorkflowTemplates by namespace
	Namespace *string `json:"namespace,omitempty"`
	// Filter WorkflowTemplates by group
	Groups []*string `json:"groups,omitempty"`
	// Filter WorkflowTemplates by version
	Versions []*string `json:"versions,omitempty"`
	// Filter WorkflowTemplates by git source
	GitSource *string `json:"gitSource,omitempty"`
	// Filter WorkflowTemplates that are related to promotions
	PromotionRelated *bool `json:"promotionRelated,omitempty"`
}

// Workflow filter arguments
type WorkflowsFilterArgs struct {
	// Filter workflows from a specific project
	Project *string `json:"project,omitempty"`
	// Filter workflows from a specific runtime
	Runtime *string `json:"runtime,omitempty"`
	// Filter workflows from a specific namespace
	Namespace *string `json:"namespace,omitempty"`
	// Filter workflows by groups
	Groups []string `json:"groups,omitempty"`
	// Filter workflows by versions
	Versions []string `json:"versions,omitempty"`
	// Filter workflows from a specific cluster URL
	Cluster *string `json:"cluster,omitempty"`
	// Filter workflows filer by pipelines
	Pipelines *NamespacedFindManyArgs `json:"pipelines,omitempty"`
	// Filter workflows from a specific repositories
	Repositories []string `json:"repositories,omitempty"`
	// Filter workflows from a specific branches
	Branches []string `json:"branches,omitempty"`
	// Filter workflows from a specific event types
	EventTypes []string `json:"eventTypes,omitempty"`
	// Filter workflows from a specific initiators
	Initiators []string `json:"initiators,omitempty"`
	// Filter workflows from a specific statuses
	Statuses []WorkflowPhases `json:"statuses,omitempty"`
	// Filter workflows from a specific start date
	StartDateFrom *string `json:"startDateFrom,omitempty"`
	// Filter workflows to a specific start date
	StartDateTo *string `json:"startDateTo,omitempty"`
	// Filter workflows by workflowTemplate
	WorkflowTemplate *string `json:"workflowTemplate,omitempty"`
	// Filter workflows created by platform/app-proxy, the value should be the name of the flow that caused the creation
	OriginatedFrom []WorkflowOrigins `json:"originatedFrom,omitempty"`
	// Filter workflows by workflowTemplate clusterScope
	WorkflowTemplateClusterScope *bool `json:"workflowTemplateClusterScope,omitempty"`
	// Application names
	AppNames []*string `json:"appNames,omitempty"`
	// Product names array
	Products []*string `json:"products,omitempty"`
	// Environments names array
	Environments []*string `json:"environments,omitempty"`
}

// Access Mode
type AccessMode string

const (
	// standard installation using an ingress resource
	AccessModeIngress AccessMode = "INGRESS"
	// ingressless installation, using an FRP tunnel
	AccessModeTunnel AccessMode = "TUNNEL"
)

var AllAccessMode = []AccessMode{
	AccessModeIngress,
	AccessModeTunnel,
}

func (e AccessMode) IsValid() bool {
	switch e {
	case AccessModeIngress, AccessModeTunnel:
		return true
	}
	return false
}

func (e AccessMode) String() string {
	return string(e)
}

func (e *AccessMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessMode", str)
	}
	return nil
}

func (e AccessMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Analysis Metric Provider Types
type AnalysisMetricProviderTypes string

const (
	// CLOUD_WATCH
	AnalysisMetricProviderTypesCloudWatch AnalysisMetricProviderTypes = "CLOUD_WATCH"
	// DATADOG
	AnalysisMetricProviderTypesDatadog AnalysisMetricProviderTypes = "DATADOG"
	// JOB
	AnalysisMetricProviderTypesJob AnalysisMetricProviderTypes = "JOB"
	// KAYENTA
	AnalysisMetricProviderTypesKayenta AnalysisMetricProviderTypes = "KAYENTA"
	// NEW_RELIC
	AnalysisMetricProviderTypesNewRelic AnalysisMetricProviderTypes = "NEW_RELIC"
	// PROMETHEUS
	AnalysisMetricProviderTypesPrometheus AnalysisMetricProviderTypes = "PROMETHEUS"
	// UNKNOWN
	AnalysisMetricProviderTypesUnknown AnalysisMetricProviderTypes = "UNKNOWN"
	// WAVEFRONT
	AnalysisMetricProviderTypesWavefront AnalysisMetricProviderTypes = "WAVEFRONT"
	// WEB
	AnalysisMetricProviderTypesWeb AnalysisMetricProviderTypes = "WEB"
)

var AllAnalysisMetricProviderTypes = []AnalysisMetricProviderTypes{
	AnalysisMetricProviderTypesCloudWatch,
	AnalysisMetricProviderTypesDatadog,
	AnalysisMetricProviderTypesJob,
	AnalysisMetricProviderTypesKayenta,
	AnalysisMetricProviderTypesNewRelic,
	AnalysisMetricProviderTypesPrometheus,
	AnalysisMetricProviderTypesUnknown,
	AnalysisMetricProviderTypesWavefront,
	AnalysisMetricProviderTypesWeb,
}

func (e AnalysisMetricProviderTypes) IsValid() bool {
	switch e {
	case AnalysisMetricProviderTypesCloudWatch, AnalysisMetricProviderTypesDatadog, AnalysisMetricProviderTypesJob, AnalysisMetricProviderTypesKayenta, AnalysisMetricProviderTypesNewRelic, AnalysisMetricProviderTypesPrometheus, AnalysisMetricProviderTypesUnknown, AnalysisMetricProviderTypesWavefront, AnalysisMetricProviderTypesWeb:
		return true
	}
	return false
}

func (e AnalysisMetricProviderTypes) String() string {
	return string(e)
}

func (e *AnalysisMetricProviderTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnalysisMetricProviderTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnalysisMetricProviderTypes", str)
	}
	return nil
}

func (e AnalysisMetricProviderTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// AnalysisPhases
type AnalysisPhases string

const (
	// Error
	AnalysisPhasesError AnalysisPhases = "Error"
	// Failed
	AnalysisPhasesFailed AnalysisPhases = "Failed"
	// Inconclusive
	AnalysisPhasesInconclusive AnalysisPhases = "Inconclusive"
	// Pending
	AnalysisPhasesPending AnalysisPhases = "Pending"
	// Running
	AnalysisPhasesRunning AnalysisPhases = "Running"
	// Successful
	AnalysisPhasesSuccessful AnalysisPhases = "Successful"
)

var AllAnalysisPhases = []AnalysisPhases{
	AnalysisPhasesError,
	AnalysisPhasesFailed,
	AnalysisPhasesInconclusive,
	AnalysisPhasesPending,
	AnalysisPhasesRunning,
	AnalysisPhasesSuccessful,
}

func (e AnalysisPhases) IsValid() bool {
	switch e {
	case AnalysisPhasesError, AnalysisPhasesFailed, AnalysisPhasesInconclusive, AnalysisPhasesPending, AnalysisPhasesRunning, AnalysisPhasesSuccessful:
		return true
	}
	return false
}

func (e AnalysisPhases) String() string {
	return string(e)
}

func (e *AnalysisPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnalysisPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnalysisPhases", str)
	}
	return nil
}

func (e AnalysisPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncOperationPhase
type AppOperationType string

const (
	// Delete
	AppOperationTypeDelete AppOperationType = "Delete"
	// Sync
	AppOperationTypeSync AppOperationType = "Sync"
	// Unknown
	AppOperationTypeUnknown AppOperationType = "Unknown"
)

var AllAppOperationType = []AppOperationType{
	AppOperationTypeDelete,
	AppOperationTypeSync,
	AppOperationTypeUnknown,
}

func (e AppOperationType) IsValid() bool {
	switch e {
	case AppOperationTypeDelete, AppOperationTypeSync, AppOperationTypeUnknown:
		return true
	}
	return false
}

func (e AppOperationType) String() string {
	return string(e)
}

func (e *AppOperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppOperationType", str)
	}
	return nil
}

func (e AppOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// App-Proxy Status
type AppProxyStatus string

const (
	// FAILED
	AppProxyStatusFailed AppProxyStatus = "FAILED"
	// SUCCESSFUL
	AppProxyStatusSuccessful AppProxyStatus = "SUCCESSFUL"
	// UNKNOWN
	AppProxyStatusUnknown AppProxyStatus = "UNKNOWN"
)

var AllAppProxyStatus = []AppProxyStatus{
	AppProxyStatusFailed,
	AppProxyStatusSuccessful,
	AppProxyStatusUnknown,
}

func (e AppProxyStatus) IsValid() bool {
	switch e {
	case AppProxyStatusFailed, AppProxyStatusSuccessful, AppProxyStatusUnknown:
		return true
	}
	return false
}

func (e AppProxyStatus) String() string {
	return string(e)
}

func (e *AppProxyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppProxyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppProxyStatus", str)
	}
	return nil
}

func (e AppProxyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// App Sync Policies
type AppSyncPolicies string

const (
	// Automated
	AppSyncPoliciesAutomated AppSyncPolicies = "Automated"
	// Manual
	AppSyncPoliciesManual AppSyncPolicies = "Manual"
	// Unknown
	AppSyncPoliciesUnknown AppSyncPolicies = "Unknown"
)

var AllAppSyncPolicies = []AppSyncPolicies{
	AppSyncPoliciesAutomated,
	AppSyncPoliciesManual,
	AppSyncPoliciesUnknown,
}

func (e AppSyncPolicies) IsValid() bool {
	switch e {
	case AppSyncPoliciesAutomated, AppSyncPoliciesManual, AppSyncPoliciesUnknown:
		return true
	}
	return false
}

func (e AppSyncPolicies) String() string {
	return string(e)
}

func (e *AppSyncPolicies) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppSyncPolicies(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppSyncPolicies", str)
	}
	return nil
}

func (e AppSyncPolicies) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Groups Sorting field
type ApplicationGroupsSortingField string

const (
	// By name
	ApplicationGroupsSortingFieldName ApplicationGroupsSortingField = "name"
	// By updated at
	ApplicationGroupsSortingFieldUpdatedAt ApplicationGroupsSortingField = "updatedAt"
)

var AllApplicationGroupsSortingField = []ApplicationGroupsSortingField{
	ApplicationGroupsSortingFieldName,
	ApplicationGroupsSortingFieldUpdatedAt,
}

func (e ApplicationGroupsSortingField) IsValid() bool {
	switch e {
	case ApplicationGroupsSortingFieldName, ApplicationGroupsSortingFieldUpdatedAt:
		return true
	}
	return false
}

func (e ApplicationGroupsSortingField) String() string {
	return string(e)
}

func (e *ApplicationGroupsSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationGroupsSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationGroupsSortingField", str)
	}
	return nil
}

func (e ApplicationGroupsSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Tree Sorting field
type ApplicationTreeSortingField string

const (
	// healthStatus
	ApplicationTreeSortingFieldHealthStatus ApplicationTreeSortingField = "healthStatus"
	// kind
	ApplicationTreeSortingFieldKind ApplicationTreeSortingField = "kind"
	// last deployment date
	ApplicationTreeSortingFieldLastUpdated ApplicationTreeSortingField = "lastUpdated"
	// name
	ApplicationTreeSortingFieldName ApplicationTreeSortingField = "name"
	// runtime
	ApplicationTreeSortingFieldRuntime ApplicationTreeSortingField = "runtime"
	// syncStatus
	ApplicationTreeSortingFieldSyncStatus ApplicationTreeSortingField = "syncStatus"
)

var AllApplicationTreeSortingField = []ApplicationTreeSortingField{
	ApplicationTreeSortingFieldHealthStatus,
	ApplicationTreeSortingFieldKind,
	ApplicationTreeSortingFieldLastUpdated,
	ApplicationTreeSortingFieldName,
	ApplicationTreeSortingFieldRuntime,
	ApplicationTreeSortingFieldSyncStatus,
}

func (e ApplicationTreeSortingField) IsValid() bool {
	switch e {
	case ApplicationTreeSortingFieldHealthStatus, ApplicationTreeSortingFieldKind, ApplicationTreeSortingFieldLastUpdated, ApplicationTreeSortingFieldName, ApplicationTreeSortingFieldRuntime, ApplicationTreeSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e ApplicationTreeSortingField) String() string {
	return string(e)
}

func (e *ApplicationTreeSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationTreeSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationTreeSortingField", str)
	}
	return nil
}

func (e ApplicationTreeSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ConnectionState contains information about remote resource connection state, currently used for clusters and repositories
type ClusterConnectionStatus string

const (
	// ConnectionStatusFailed indicates that a connection attempt has failed
	ClusterConnectionStatusFailed ClusterConnectionStatus = "Failed"
	// ConnectionStatusSuccessful indicates that a connection has been successfully established
	ClusterConnectionStatusSuccessful ClusterConnectionStatus = "Successful"
	// ConnectionStatusUnknown indicates that the connection status could not be reliably determined
	ClusterConnectionStatusUnknown ClusterConnectionStatus = "Unknown"
)

var AllClusterConnectionStatus = []ClusterConnectionStatus{
	ClusterConnectionStatusFailed,
	ClusterConnectionStatusSuccessful,
	ClusterConnectionStatusUnknown,
}

func (e ClusterConnectionStatus) IsValid() bool {
	switch e {
	case ClusterConnectionStatusFailed, ClusterConnectionStatusSuccessful, ClusterConnectionStatusUnknown:
		return true
	}
	return false
}

func (e ClusterConnectionStatus) String() string {
	return string(e)
}

func (e *ClusterConnectionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterConnectionStatus", str)
	}
	return nil
}

func (e ClusterConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Cluster connection status input
type ClusterConnectionStatusInput string

const (
	// Indicates that a connection attempt has failed
	ClusterConnectionStatusInputFailed ClusterConnectionStatusInput = "Failed"
	// Indicates that a connection has been successfully established
	ClusterConnectionStatusInputSuccessful ClusterConnectionStatusInput = "Successful"
	// Indicates that the connection status could not be reliably determined
	ClusterConnectionStatusInputUnknown ClusterConnectionStatusInput = "Unknown"
)

var AllClusterConnectionStatusInput = []ClusterConnectionStatusInput{
	ClusterConnectionStatusInputFailed,
	ClusterConnectionStatusInputSuccessful,
	ClusterConnectionStatusInputUnknown,
}

func (e ClusterConnectionStatusInput) IsValid() bool {
	switch e {
	case ClusterConnectionStatusInputFailed, ClusterConnectionStatusInputSuccessful, ClusterConnectionStatusInputUnknown:
		return true
	}
	return false
}

func (e ClusterConnectionStatusInput) String() string {
	return string(e)
}

func (e *ClusterConnectionStatusInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterConnectionStatusInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterConnectionStatusInput", str)
	}
	return nil
}

func (e ClusterConnectionStatusInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Deployment Statistics Status
type DeploymentStatisticsStatus string

const (
	DeploymentStatisticsStatusAll                 DeploymentStatisticsStatus = "ALL"
	DeploymentStatisticsStatusDegraded            DeploymentStatisticsStatus = "DEGRADED"
	DeploymentStatisticsStatusDegradedAndRollback DeploymentStatisticsStatus = "DEGRADED_AND_ROLLBACK"
	DeploymentStatisticsStatusHealthy             DeploymentStatisticsStatus = "HEALTHY"
	DeploymentStatisticsStatusRollback            DeploymentStatisticsStatus = "ROLLBACK"
)

var AllDeploymentStatisticsStatus = []DeploymentStatisticsStatus{
	DeploymentStatisticsStatusAll,
	DeploymentStatisticsStatusDegraded,
	DeploymentStatisticsStatusDegradedAndRollback,
	DeploymentStatisticsStatusHealthy,
	DeploymentStatisticsStatusRollback,
}

func (e DeploymentStatisticsStatus) IsValid() bool {
	switch e {
	case DeploymentStatisticsStatusAll, DeploymentStatisticsStatusDegraded, DeploymentStatisticsStatusDegradedAndRollback, DeploymentStatisticsStatusHealthy, DeploymentStatisticsStatusRollback:
		return true
	}
	return false
}

func (e DeploymentStatisticsStatus) String() string {
	return string(e)
}

func (e *DeploymentStatisticsStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentStatisticsStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentStatisticsStatus", str)
	}
	return nil
}

func (e DeploymentStatisticsStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Duration Name
type DurationName string

const (
	DurationNameDelayDuration              DurationName = "DELAY_DURATION"
	DurationNameInitializingDuration       DurationName = "INITIALIZING_DURATION"
	DurationNamePendingApprovalDuration    DurationName = "PENDING_APPROVAL_DURATION"
	DurationNamePendingConcurrencyDuration DurationName = "PENDING_CONCURRENCY_DURATION"
	DurationNameRunningDuration            DurationName = "RUNNING_DURATION"
	DurationNameTotalDuration              DurationName = "TOTAL_DURATION"
)

var AllDurationName = []DurationName{
	DurationNameDelayDuration,
	DurationNameInitializingDuration,
	DurationNamePendingApprovalDuration,
	DurationNamePendingConcurrencyDuration,
	DurationNameRunningDuration,
	DurationNameTotalDuration,
}

func (e DurationName) IsValid() bool {
	switch e {
	case DurationNameDelayDuration, DurationNameInitializingDuration, DurationNamePendingApprovalDuration, DurationNamePendingConcurrencyDuration, DurationNameRunningDuration, DurationNameTotalDuration:
		return true
	}
	return false
}

func (e DurationName) String() string {
	return string(e)
}

func (e *DurationName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DurationName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DurationName", str)
	}
	return nil
}

func (e DurationName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Kind of environment
type EnvironmentKind string

const (
	EnvironmentKindNonProd EnvironmentKind = "NON_PROD"
	EnvironmentKindProd    EnvironmentKind = "PROD"
)

var AllEnvironmentKind = []EnvironmentKind{
	EnvironmentKindNonProd,
	EnvironmentKindProd,
}

func (e EnvironmentKind) IsValid() bool {
	switch e {
	case EnvironmentKindNonProd, EnvironmentKindProd:
		return true
	}
	return false
}

func (e EnvironmentKind) String() string {
	return string(e)
}

func (e *EnvironmentKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentKind", str)
	}
	return nil
}

func (e EnvironmentKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// "Relative position of the moved environment in relation to the target environment"
type EnvironmentRelativePos string

const (
	EnvironmentRelativePosAfter  EnvironmentRelativePos = "AFTER"
	EnvironmentRelativePosBefore EnvironmentRelativePos = "BEFORE"
)

var AllEnvironmentRelativePos = []EnvironmentRelativePos{
	EnvironmentRelativePosAfter,
	EnvironmentRelativePosBefore,
}

func (e EnvironmentRelativePos) IsValid() bool {
	switch e {
	case EnvironmentRelativePosAfter, EnvironmentRelativePosBefore:
		return true
	}
	return false
}

func (e EnvironmentRelativePos) String() string {
	return string(e)
}

func (e *EnvironmentRelativePos) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentRelativePos(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentRelativePos", str)
	}
	return nil
}

func (e EnvironmentRelativePos) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error severity levels
type ErrorLevels string

const (
	// Error - The resource will not function correctly
	ErrorLevelsError ErrorLevels = "ERROR"
	// Warning - The resource may not function correctly
	ErrorLevelsWarning ErrorLevels = "WARNING"
)

var AllErrorLevels = []ErrorLevels{
	ErrorLevelsError,
	ErrorLevelsWarning,
}

func (e ErrorLevels) IsValid() bool {
	switch e {
	case ErrorLevelsError, ErrorLevelsWarning:
		return true
	}
	return false
}

func (e ErrorLevels) String() string {
	return string(e)
}

func (e *ErrorLevels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorLevels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorLevels", str)
	}
	return nil
}

func (e ErrorLevels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// GitAuthMode
type GitAuthMode string

const (
	// CODEFRESH mode
	GitAuthModeCodefresh GitAuthMode = "CODEFRESH"
	// CUSTOM mode
	GitAuthModeCustom GitAuthMode = "CUSTOM"
	// PAT mode
	GitAuthModePat GitAuthMode = "PAT"
)

var AllGitAuthMode = []GitAuthMode{
	GitAuthModeCodefresh,
	GitAuthModeCustom,
	GitAuthModePat,
}

func (e GitAuthMode) IsValid() bool {
	switch e {
	case GitAuthModeCodefresh, GitAuthModeCustom, GitAuthModePat:
		return true
	}
	return false
}

func (e GitAuthMode) String() string {
	return string(e)
}

func (e *GitAuthMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitAuthMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitAuthMode", str)
	}
	return nil
}

func (e GitAuthMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Git providers
type GitProviders string

const (
	// Bitbucket cloud
	GitProvidersBitbucket GitProviders = "BITBUCKET"
	// Bitbucket server
	GitProvidersBitbucketServer GitProviders = "BITBUCKET_SERVER"
	// Gerrit
	GitProvidersGerrit GitProviders = "GERRIT"
	// Github
	GitProvidersGithub GitProviders = "GITHUB"
	// Gitlab
	GitProvidersGitlab GitProviders = "GITLAB"
)

var AllGitProviders = []GitProviders{
	GitProvidersBitbucket,
	GitProvidersBitbucketServer,
	GitProvidersGerrit,
	GitProvidersGithub,
	GitProvidersGitlab,
}

func (e GitProviders) IsValid() bool {
	switch e {
	case GitProvidersBitbucket, GitProvidersBitbucketServer, GitProvidersGerrit, GitProvidersGithub, GitProvidersGitlab:
		return true
	}
	return false
}

func (e GitProviders) String() string {
	return string(e)
}

func (e *GitProviders) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitProviders(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitProviders", str)
	}
	return nil
}

func (e GitProviders) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of push event
type GitPushPayloadDataTypes string

const (
	GitPushPayloadDataTypesBranch GitPushPayloadDataTypes = "branch"
	GitPushPayloadDataTypesTag    GitPushPayloadDataTypes = "tag"
)

var AllGitPushPayloadDataTypes = []GitPushPayloadDataTypes{
	GitPushPayloadDataTypesBranch,
	GitPushPayloadDataTypesTag,
}

func (e GitPushPayloadDataTypes) IsValid() bool {
	switch e {
	case GitPushPayloadDataTypesBranch, GitPushPayloadDataTypesTag:
		return true
	}
	return false
}

func (e GitPushPayloadDataTypes) String() string {
	return string(e)
}

func (e *GitPushPayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitPushPayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitPushPayloadDataTypes", str)
	}
	return nil
}

func (e GitPushPayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Gitops Releases Sorting field
type GitopsReleasesSortingField string

const (
	// By date
	GitopsReleasesSortingFieldCreatedAt GitopsReleasesSortingField = "createdAt"
	// By health status
	GitopsReleasesSortingFieldHealthStatus GitopsReleasesSortingField = "healthStatus"
	// By history id (for chronological sorting)
	GitopsReleasesSortingFieldHistoryID GitopsReleasesSortingField = "historyId"
	// By sync status
	GitopsReleasesSortingFieldSyncStatus GitopsReleasesSortingField = "syncStatus"
)

var AllGitopsReleasesSortingField = []GitopsReleasesSortingField{
	GitopsReleasesSortingFieldCreatedAt,
	GitopsReleasesSortingFieldHealthStatus,
	GitopsReleasesSortingFieldHistoryID,
	GitopsReleasesSortingFieldSyncStatus,
}

func (e GitopsReleasesSortingField) IsValid() bool {
	switch e {
	case GitopsReleasesSortingFieldCreatedAt, GitopsReleasesSortingFieldHealthStatus, GitopsReleasesSortingFieldHistoryID, GitopsReleasesSortingFieldSyncStatus:
		return true
	}
	return false
}

func (e GitopsReleasesSortingField) String() string {
	return string(e)
}

func (e *GitopsReleasesSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitopsReleasesSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitopsReleasesSortingField", str)
	}
	return nil
}

func (e GitopsReleasesSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Error codes
type HealthErrorCodes string

const (
	// The resource has a reference to a non-existing resource
	HealthErrorCodesBrokenReference HealthErrorCodes = "BROKEN_REFERENCE"
	// The runtime is not active
	HealthErrorCodesInactiveRuntime HealthErrorCodes = "INACTIVE_RUNTIME"
	// The resource has insufficient resources
	HealthErrorCodesInsufficientResources HealthErrorCodes = "INSUFFICIENT_RESOURCES"
	// Runtime Installation error
	HealthErrorCodesRuntimeInstallationError HealthErrorCodes = "RUNTIME_INSTALLATION_ERROR"
	// Transitive health error that originates from one of referenced entities
	HealthErrorCodesTransitiveError HealthErrorCodes = "TRANSITIVE_ERROR"
	// Uknown sync error
	HealthErrorCodesUnknown HealthErrorCodes = "UNKNOWN"
)

var AllHealthErrorCodes = []HealthErrorCodes{
	HealthErrorCodesBrokenReference,
	HealthErrorCodesInactiveRuntime,
	HealthErrorCodesInsufficientResources,
	HealthErrorCodesRuntimeInstallationError,
	HealthErrorCodesTransitiveError,
	HealthErrorCodesUnknown,
}

func (e HealthErrorCodes) IsValid() bool {
	switch e {
	case HealthErrorCodesBrokenReference, HealthErrorCodesInactiveRuntime, HealthErrorCodesInsufficientResources, HealthErrorCodesRuntimeInstallationError, HealthErrorCodesTransitiveError, HealthErrorCodesUnknown:
		return true
	}
	return false
}

func (e HealthErrorCodes) String() string {
	return string(e)
}

func (e *HealthErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthErrorCodes", str)
	}
	return nil
}

func (e HealthErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health Status
type HealthStatus string

const (
	// resource status indicates failure
	HealthStatusDegraded HealthStatus = "DEGRADED"
	// resource is healthy
	HealthStatusHealthy HealthStatus = "HEALTHY"
	// resource is missing from the cluster
	HealthStatusMissing HealthStatus = "MISSING"
	// resource not yet healthy but has a chance to become healthy
	HealthStatusProgressing HealthStatus = "PROGRESSING"
	// resource is suspended (for example: cronjob)
	HealthStatusSuspended HealthStatus = "SUSPENDED"
	// CUSTOM status, used in case when resource update process was interrupted by new changes
	HealthStatusTerminated HealthStatus = "TERMINATED"
	// health assessment failed
	HealthStatusUnknown HealthStatus = "UNKNOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusDegraded,
	HealthStatusHealthy,
	HealthStatusMissing,
	HealthStatusProgressing,
	HealthStatusSuspended,
	HealthStatusTerminated,
	HealthStatusUnknown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusDegraded, HealthStatusHealthy, HealthStatusMissing, HealthStatusProgressing, HealthStatusSuspended, HealthStatusTerminated, HealthStatusUnknown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image pull policy
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated
type ImagePullPolicy string

const (
	ImagePullPolicyAlways       ImagePullPolicy = "Always"
	ImagePullPolicyIfNotPresent ImagePullPolicy = "IfNotPresent"
	ImagePullPolicyNever        ImagePullPolicy = "Never"
)

var AllImagePullPolicy = []ImagePullPolicy{
	ImagePullPolicyAlways,
	ImagePullPolicyIfNotPresent,
	ImagePullPolicyNever,
}

func (e ImagePullPolicy) IsValid() bool {
	switch e {
	case ImagePullPolicyAlways, ImagePullPolicyIfNotPresent, ImagePullPolicyNever:
		return true
	}
	return false
}

func (e ImagePullPolicy) String() string {
	return string(e)
}

func (e *ImagePullPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImagePullPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImagePullPolicy", str)
	}
	return nil
}

func (e ImagePullPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image registry domain types
type ImageRegistryType string

const (
	// Docker hub
	ImageRegistryTypeDockerHub ImageRegistryType = "DOCKER_HUB"
	// Amazon ECR
	ImageRegistryTypeEcr ImageRegistryType = "ECR"
	// Google container Registry
	ImageRegistryTypeGcr ImageRegistryType = "GCR"
	// Ghcr
	ImageRegistryTypeGhcr ImageRegistryType = "GHCR"
	// Jfrog
	ImageRegistryTypeJfrog ImageRegistryType = "JFROG"
	// Other type
	ImageRegistryTypeOther ImageRegistryType = "OTHER"
	// Quay
	ImageRegistryTypeQuay ImageRegistryType = "QUAY"
)

var AllImageRegistryType = []ImageRegistryType{
	ImageRegistryTypeDockerHub,
	ImageRegistryTypeEcr,
	ImageRegistryTypeGcr,
	ImageRegistryTypeGhcr,
	ImageRegistryTypeJfrog,
	ImageRegistryTypeOther,
	ImageRegistryTypeQuay,
}

func (e ImageRegistryType) IsValid() bool {
	switch e {
	case ImageRegistryTypeDockerHub, ImageRegistryTypeEcr, ImageRegistryTypeGcr, ImageRegistryTypeGhcr, ImageRegistryTypeJfrog, ImageRegistryTypeOther, ImageRegistryTypeQuay:
		return true
	}
	return false
}

func (e ImageRegistryType) String() string {
	return string(e)
}

func (e *ImageRegistryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRegistryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRegistryType", str)
	}
	return nil
}

func (e ImageRegistryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repo Tag Sorting field
type ImageRepoTagSortingField string

const (
	// Tag name
	ImageRepoTagSortingFieldTag ImageRepoTagSortingField = "tag"
)

var AllImageRepoTagSortingField = []ImageRepoTagSortingField{
	ImageRepoTagSortingFieldTag,
}

func (e ImageRepoTagSortingField) IsValid() bool {
	switch e {
	case ImageRepoTagSortingFieldTag:
		return true
	}
	return false
}

func (e ImageRepoTagSortingField) String() string {
	return string(e)
}

func (e *ImageRepoTagSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepoTagSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepoTagSortingField", str)
	}
	return nil
}

func (e ImageRepoTagSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Image Repository Sorting field
type ImageRepositorySortingField string

const (
	// Last Update
	ImageRepositorySortingFieldLastUpdate ImageRepositorySortingField = "lastUpdate"
	// Image repo name
	ImageRepositorySortingFieldName ImageRepositorySortingField = "name"
)

var AllImageRepositorySortingField = []ImageRepositorySortingField{
	ImageRepositorySortingFieldLastUpdate,
	ImageRepositorySortingFieldName,
}

func (e ImageRepositorySortingField) IsValid() bool {
	switch e {
	case ImageRepositorySortingFieldLastUpdate, ImageRepositorySortingFieldName:
		return true
	}
	return false
}

func (e ImageRepositorySortingField) String() string {
	return string(e)
}

func (e *ImageRepositorySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageRepositorySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageRepositorySortingField", str)
	}
	return nil
}

func (e ImageRepositorySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation Status
type InstallationStatus string

const (
	// installation is completed
	InstallationStatusCompleted InstallationStatus = "COMPLETED"
	// installation failed
	InstallationStatusFailed InstallationStatus = "FAILED"
	// installation is in progress
	InstallationStatusInProgress InstallationStatus = "IN_PROGRESS"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusCompleted,
	InstallationStatusFailed,
	InstallationStatusInProgress,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusCompleted, InstallationStatusFailed, InstallationStatusInProgress:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Installation type
type InstallationType string

const (
	// CLI
	InstallationTypeCli InstallationType = "CLI"
	// Helm
	InstallationTypeHelm InstallationType = "HELM"
	// Helm-Hosted
	InstallationTypeHelmHosted InstallationType = "HELM_HOSTED"
	// Hosted
	InstallationTypeHosted InstallationType = "HOSTED"
)

var AllInstallationType = []InstallationType{
	InstallationTypeCli,
	InstallationTypeHelm,
	InstallationTypeHelmHosted,
	InstallationTypeHosted,
}

func (e InstallationType) IsValid() bool {
	switch e {
	case InstallationTypeCli, InstallationTypeHelm, InstallationTypeHelmHosted, InstallationTypeHosted:
		return true
	}
	return false
}

func (e InstallationType) String() string {
	return string(e)
}

func (e *InstallationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationType", str)
	}
	return nil
}

func (e InstallationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Integration Consumer
type IntegrationConsumer string

const (
	// Jira Write Back
	IntegrationConsumerJiraWriteBack IntegrationConsumer = "JIRA_WRITE_BACK"
)

var AllIntegrationConsumer = []IntegrationConsumer{
	IntegrationConsumerJiraWriteBack,
}

func (e IntegrationConsumer) IsValid() bool {
	switch e {
	case IntegrationConsumerJiraWriteBack:
		return true
	}
	return false
}

func (e IntegrationConsumer) String() string {
	return string(e)
}

func (e *IntegrationConsumer) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationConsumer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationConsumer", str)
	}
	return nil
}

func (e IntegrationConsumer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// MatchExpressionOperator
type MatchExpressionOperator string

const (
	// DoesNotExist
	MatchExpressionOperatorDoesNotExist MatchExpressionOperator = "DoesNotExist"
	// Exists
	MatchExpressionOperatorExists MatchExpressionOperator = "Exists"
	// In
	MatchExpressionOperatorIn MatchExpressionOperator = "In"
	// NotIn
	MatchExpressionOperatorNotIn MatchExpressionOperator = "NotIn"
)

var AllMatchExpressionOperator = []MatchExpressionOperator{
	MatchExpressionOperatorDoesNotExist,
	MatchExpressionOperatorExists,
	MatchExpressionOperatorIn,
	MatchExpressionOperatorNotIn,
}

func (e MatchExpressionOperator) IsValid() bool {
	switch e {
	case MatchExpressionOperatorDoesNotExist, MatchExpressionOperatorExists, MatchExpressionOperatorIn, MatchExpressionOperatorNotIn:
		return true
	}
	return false
}

func (e MatchExpressionOperator) String() string {
	return string(e)
}

func (e *MatchExpressionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchExpressionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchExpressionOperator", str)
	}
	return nil
}

func (e MatchExpressionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Not k8s entity kind
type NotK8sEntityKind string

const (
	NotK8sEntityKindAppGroup    NotK8sEntityKind = "APP_GROUP"
	NotK8sEntityKindEnvironment NotK8sEntityKind = "ENVIRONMENT"
	NotK8sEntityKindProduct     NotK8sEntityKind = "PRODUCT"
)

var AllNotK8sEntityKind = []NotK8sEntityKind{
	NotK8sEntityKindAppGroup,
	NotK8sEntityKindEnvironment,
	NotK8sEntityKindProduct,
}

func (e NotK8sEntityKind) IsValid() bool {
	switch e {
	case NotK8sEntityKindAppGroup, NotK8sEntityKindEnvironment, NotK8sEntityKindProduct:
		return true
	}
	return false
}

func (e NotK8sEntityKind) String() string {
	return string(e)
}

func (e *NotK8sEntityKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotK8sEntityKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotK8sEntityKind", str)
	}
	return nil
}

func (e NotK8sEntityKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification action type
type NotificationActionType string

const (
	// Add action
	NotificationActionTypeAdded NotificationActionType = "ADDED"
	// Remove action
	NotificationActionTypeRemoved NotificationActionType = "REMOVED"
	// Update action
	NotificationActionTypeUpdate NotificationActionType = "UPDATE"
)

var AllNotificationActionType = []NotificationActionType{
	NotificationActionTypeAdded,
	NotificationActionTypeRemoved,
	NotificationActionTypeUpdate,
}

func (e NotificationActionType) IsValid() bool {
	switch e {
	case NotificationActionTypeAdded, NotificationActionTypeRemoved, NotificationActionTypeUpdate:
		return true
	}
	return false
}

func (e NotificationActionType) String() string {
	return string(e)
}

func (e *NotificationActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationActionType", str)
	}
	return nil
}

func (e NotificationActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification State
type NotificationState string

const (
	// Failed state
	NotificationStateFailed NotificationState = "FAILED"
	// In progress state
	NotificationStateInProgress NotificationState = "IN_PROGRESS"
	// Success state
	NotificationStateSuccess NotificationState = "SUCCESS"
)

var AllNotificationState = []NotificationState{
	NotificationStateFailed,
	NotificationStateInProgress,
	NotificationStateSuccess,
}

func (e NotificationState) IsValid() bool {
	switch e {
	case NotificationStateFailed, NotificationStateInProgress, NotificationStateSuccess:
		return true
	}
	return false
}

func (e NotificationState) String() string {
	return string(e)
}

func (e *NotificationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationState", str)
	}
	return nil
}

func (e NotificationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification Type
type NotificationType string

const (
	// Event that are coming from argo cd
	NotificationTypeArgoCdEvent NotificationType = "ARGO_CD_EVENT"
	// Event that are coming from argo events
	NotificationTypeArgoEventsEvent NotificationType = "ARGO_EVENTS_EVENT"
	// Generic Event
	NotificationTypeGenericEvent NotificationType = "GENERIC_EVENT"
)

var AllNotificationType = []NotificationType{
	NotificationTypeArgoCdEvent,
	NotificationTypeArgoEventsEvent,
	NotificationTypeGenericEvent,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeArgoCdEvent, NotificationTypeArgoEventsEvent, NotificationTypeGenericEvent:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of event payload
type PayloadDataTypes string

const (
	PayloadDataTypesCalendar PayloadDataTypes = "calendar"
	PayloadDataTypesGit      PayloadDataTypes = "git"
	PayloadDataTypesUnknown  PayloadDataTypes = "unknown"
)

var AllPayloadDataTypes = []PayloadDataTypes{
	PayloadDataTypesCalendar,
	PayloadDataTypesGit,
	PayloadDataTypesUnknown,
}

func (e PayloadDataTypes) IsValid() bool {
	switch e {
	case PayloadDataTypesCalendar, PayloadDataTypesGit, PayloadDataTypesUnknown:
		return true
	}
	return false
}

func (e PayloadDataTypes) String() string {
	return string(e)
}

func (e *PayloadDataTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayloadDataTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayloadDataTypes", str)
	}
	return nil
}

func (e PayloadDataTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline statistics sort by duration type
type PipelineClassicStatisticDurationMetricType string

const (
	PipelineClassicStatisticDurationMetricTypeAverageDuration PipelineClassicStatisticDurationMetricType = "AVERAGE_DURATION"
	PipelineClassicStatisticDurationMetricTypeP50Duration     PipelineClassicStatisticDurationMetricType = "P50_DURATION"
	PipelineClassicStatisticDurationMetricTypeP90Duration     PipelineClassicStatisticDurationMetricType = "P90_DURATION"
)

var AllPipelineClassicStatisticDurationMetricType = []PipelineClassicStatisticDurationMetricType{
	PipelineClassicStatisticDurationMetricTypeAverageDuration,
	PipelineClassicStatisticDurationMetricTypeP50Duration,
	PipelineClassicStatisticDurationMetricTypeP90Duration,
}

func (e PipelineClassicStatisticDurationMetricType) IsValid() bool {
	switch e {
	case PipelineClassicStatisticDurationMetricTypeAverageDuration, PipelineClassicStatisticDurationMetricTypeP50Duration, PipelineClassicStatisticDurationMetricTypeP90Duration:
		return true
	}
	return false
}

func (e PipelineClassicStatisticDurationMetricType) String() string {
	return string(e)
}

func (e *PipelineClassicStatisticDurationMetricType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineClassicStatisticDurationMetricType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineClassicStatisticDurationMetricType", str)
	}
	return nil
}

func (e PipelineClassicStatisticDurationMetricType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Pipeline statistics sort by measure
type PipelineStatisticsSortByMeasure string

const (
	PipelineStatisticsSortByMeasureAverageDuration PipelineStatisticsSortByMeasure = "AVERAGE_DURATION"
	PipelineStatisticsSortByMeasureExecutions      PipelineStatisticsSortByMeasure = "EXECUTIONS"
)

var AllPipelineStatisticsSortByMeasure = []PipelineStatisticsSortByMeasure{
	PipelineStatisticsSortByMeasureAverageDuration,
	PipelineStatisticsSortByMeasureExecutions,
}

func (e PipelineStatisticsSortByMeasure) IsValid() bool {
	switch e {
	case PipelineStatisticsSortByMeasureAverageDuration, PipelineStatisticsSortByMeasureExecutions:
		return true
	}
	return false
}

func (e PipelineStatisticsSortByMeasure) String() string {
	return string(e)
}

func (e *PipelineStatisticsSortByMeasure) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PipelineStatisticsSortByMeasure(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PipelineStatisticsSortByMeasure", str)
	}
	return nil
}

func (e PipelineStatisticsSortByMeasure) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Product Components Sorting field
type ProductComponentSortingField string

const (
	// By name
	ProductComponentSortingFieldName ProductComponentSortingField = "name"
	// By updated at
	ProductComponentSortingFieldUpdatedAt ProductComponentSortingField = "updatedAt"
)

var AllProductComponentSortingField = []ProductComponentSortingField{
	ProductComponentSortingFieldName,
	ProductComponentSortingFieldUpdatedAt,
}

func (e ProductComponentSortingField) IsValid() bool {
	switch e {
	case ProductComponentSortingFieldName, ProductComponentSortingFieldUpdatedAt:
		return true
	}
	return false
}

func (e ProductComponentSortingField) String() string {
	return string(e)
}

func (e *ProductComponentSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductComponentSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductComponentSortingField", str)
	}
	return nil
}

func (e ProductComponentSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Product Component types
type ProductComponentType string

const (
	// Argo application
	ProductComponentTypeArgoApplication ProductComponentType = "ARGO_APPLICATION"
	// Helm - not implemented yet
	ProductComponentTypeHelm ProductComponentType = "HELM"
)

var AllProductComponentType = []ProductComponentType{
	ProductComponentTypeArgoApplication,
	ProductComponentTypeHelm,
}

func (e ProductComponentType) IsValid() bool {
	switch e {
	case ProductComponentTypeArgoApplication, ProductComponentTypeHelm:
		return true
	}
	return false
}

func (e ProductComponentType) String() string {
	return string(e)
}

func (e *ProductComponentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductComponentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductComponentType", str)
	}
	return nil
}

func (e ProductComponentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ProductGitTrigger
type ProductGitTrigger string

const (
	// commitMessage
	ProductGitTriggerCommitMessage ProductGitTrigger = "commitMessage"
	// Git revision (branch | tag)
	ProductGitTriggerGitRevision ProductGitTrigger = "gitRevision"
)

var AllProductGitTrigger = []ProductGitTrigger{
	ProductGitTriggerCommitMessage,
	ProductGitTriggerGitRevision,
}

func (e ProductGitTrigger) IsValid() bool {
	switch e {
	case ProductGitTriggerCommitMessage, ProductGitTriggerGitRevision:
		return true
	}
	return false
}

func (e ProductGitTrigger) String() string {
	return string(e)
}

func (e *ProductGitTrigger) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductGitTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductGitTrigger", str)
	}
	return nil
}

func (e ProductGitTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Product Sorting field
type ProductSortingField string

const (
	// By name
	ProductSortingFieldName ProductSortingField = "name"
	// By updated at
	ProductSortingFieldUpdatedAt ProductSortingField = "updatedAt"
)

var AllProductSortingField = []ProductSortingField{
	ProductSortingFieldName,
	ProductSortingFieldUpdatedAt,
}

func (e ProductSortingField) IsValid() bool {
	switch e {
	case ProductSortingFieldName, ProductSortingFieldUpdatedAt:
		return true
	}
	return false
}

func (e ProductSortingField) String() string {
	return string(e)
}

func (e *ProductSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortingField", str)
	}
	return nil
}

func (e ProductSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Promotion policy possible actions
type PromotionPolicyAction string

const (
	// Action type is a commit
	PromotionPolicyActionCommit PromotionPolicyAction = "commit"
	// Action type is none
	PromotionPolicyActionNone PromotionPolicyAction = "none"
	// Action type is a PR
	PromotionPolicyActionPr PromotionPolicyAction = "pr"
)

var AllPromotionPolicyAction = []PromotionPolicyAction{
	PromotionPolicyActionCommit,
	PromotionPolicyActionNone,
	PromotionPolicyActionPr,
}

func (e PromotionPolicyAction) IsValid() bool {
	switch e {
	case PromotionPolicyActionCommit, PromotionPolicyActionNone, PromotionPolicyActionPr:
		return true
	}
	return false
}

func (e PromotionPolicyAction) String() string {
	return string(e)
}

func (e *PromotionPolicyAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionPolicyAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionPolicyAction", str)
	}
	return nil
}

func (e PromotionPolicyAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Product Policy sorting field
type PromotionPolicySortingField string

const (
	// By creation date
	PromotionPolicySortingFieldCreatedAt PromotionPolicySortingField = "createdAt"
	// By name
	PromotionPolicySortingFieldName PromotionPolicySortingField = "name"
	// By priority
	PromotionPolicySortingFieldPriority PromotionPolicySortingField = "priority"
)

var AllPromotionPolicySortingField = []PromotionPolicySortingField{
	PromotionPolicySortingFieldCreatedAt,
	PromotionPolicySortingFieldName,
	PromotionPolicySortingFieldPriority,
}

func (e PromotionPolicySortingField) IsValid() bool {
	switch e {
	case PromotionPolicySortingFieldCreatedAt, PromotionPolicySortingFieldName, PromotionPolicySortingFieldPriority:
		return true
	}
	return false
}

func (e PromotionPolicySortingField) String() string {
	return string(e)
}

func (e *PromotionPolicySortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromotionPolicySortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromotionPolicySortingField", str)
	}
	return nil
}

func (e PromotionPolicySortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Release Rollout Disabled Reasons
type ReleaseRolloutDisabledReasons string

const (
	// Happens only when new commit occured (non-image change) while Rollout was progressing
	ReleaseRolloutDisabledReasonsRestartedDueNewCommit ReleaseRolloutDisabledReasons = "RESTARTED_DUE_NEW_COMMIT"
)

var AllReleaseRolloutDisabledReasons = []ReleaseRolloutDisabledReasons{
	ReleaseRolloutDisabledReasonsRestartedDueNewCommit,
}

func (e ReleaseRolloutDisabledReasons) IsValid() bool {
	switch e {
	case ReleaseRolloutDisabledReasonsRestartedDueNewCommit:
		return true
	}
	return false
}

func (e ReleaseRolloutDisabledReasons) String() string {
	return string(e)
}

func (e *ReleaseRolloutDisabledReasons) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReleaseRolloutDisabledReasons(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReleaseRolloutDisabledReasons", str)
	}
	return nil
}

func (e ReleaseRolloutDisabledReasons) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource action
type ResourceAction string

const (
	// Added
	ResourceActionAdded ResourceAction = "ADDED"
	// Deleted
	ResourceActionDeleted ResourceAction = "DELETED"
	// Updated
	ResourceActionUpdated ResourceAction = "UPDATED"
)

var AllResourceAction = []ResourceAction{
	ResourceActionAdded,
	ResourceActionDeleted,
	ResourceActionUpdated,
}

func (e ResourceAction) IsValid() bool {
	switch e {
	case ResourceActionAdded, ResourceActionDeleted, ResourceActionUpdated:
		return true
	}
	return false
}

func (e ResourceAction) String() string {
	return string(e)
}

func (e *ResourceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAction", str)
	}
	return nil
}

func (e ResourceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ResourceOperation
type ResourceOperation string

const (
	// Create resources
	ResourceOperationCreate ResourceOperation = "CREATE"
	// Delete resources
	ResourceOperationDelete ResourceOperation = "DELETE"
	// Update resources
	ResourceOperationUpdate ResourceOperation = "UPDATE"
)

var AllResourceOperation = []ResourceOperation{
	ResourceOperationCreate,
	ResourceOperationDelete,
	ResourceOperationUpdate,
}

func (e ResourceOperation) IsValid() bool {
	switch e {
	case ResourceOperationCreate, ResourceOperationDelete, ResourceOperationUpdate:
		return true
	}
	return false
}

func (e ResourceOperation) String() string {
	return string(e)
}

func (e *ResourceOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceOperation", str)
	}
	return nil
}

func (e ResourceOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Phases
type RolloutPhases string

const (
	// Degraded
	RolloutPhasesDegraded RolloutPhases = "Degraded"
	// Healthy
	RolloutPhasesHealthy RolloutPhases = "Healthy"
	// Paused
	RolloutPhasesPaused RolloutPhases = "Paused"
	// Progressing
	RolloutPhasesProgressing RolloutPhases = "Progressing"
	// Terminated
	RolloutPhasesTerminated RolloutPhases = "Terminated"
	// Unknown
	RolloutPhasesUnknown RolloutPhases = "Unknown"
)

var AllRolloutPhases = []RolloutPhases{
	RolloutPhasesDegraded,
	RolloutPhasesHealthy,
	RolloutPhasesPaused,
	RolloutPhasesProgressing,
	RolloutPhasesTerminated,
	RolloutPhasesUnknown,
}

func (e RolloutPhases) IsValid() bool {
	switch e {
	case RolloutPhasesDegraded, RolloutPhasesHealthy, RolloutPhasesPaused, RolloutPhasesProgressing, RolloutPhasesTerminated, RolloutPhasesUnknown:
		return true
	}
	return false
}

func (e RolloutPhases) String() string {
	return string(e)
}

func (e *RolloutPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutPhases", str)
	}
	return nil
}

func (e RolloutPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Step Status
type RolloutStepStatus string

const (
	// ACTIVE
	RolloutStepStatusActive RolloutStepStatus = "ACTIVE"
	// FAILED
	RolloutStepStatusFailed RolloutStepStatus = "FAILED"
	// PASSED
	RolloutStepStatusPassed RolloutStepStatus = "PASSED"
	// PAUSED INCONCLUSIVE
	RolloutStepStatusPausedInconclusive RolloutStepStatus = "PAUSED_INCONCLUSIVE"
	// PAUSED INDEFINITE
	RolloutStepStatusPausedIndefinite RolloutStepStatus = "PAUSED_INDEFINITE"
	// PENDING
	RolloutStepStatusPending RolloutStepStatus = "PENDING"
	// TERMINATED
	RolloutStepStatusTerminated RolloutStepStatus = "TERMINATED"
)

var AllRolloutStepStatus = []RolloutStepStatus{
	RolloutStepStatusActive,
	RolloutStepStatusFailed,
	RolloutStepStatusPassed,
	RolloutStepStatusPausedInconclusive,
	RolloutStepStatusPausedIndefinite,
	RolloutStepStatusPending,
	RolloutStepStatusTerminated,
}

func (e RolloutStepStatus) IsValid() bool {
	switch e {
	case RolloutStepStatusActive, RolloutStepStatusFailed, RolloutStepStatusPassed, RolloutStepStatusPausedInconclusive, RolloutStepStatusPausedIndefinite, RolloutStepStatusPending, RolloutStepStatusTerminated:
		return true
	}
	return false
}

func (e RolloutStepStatus) String() string {
	return string(e)
}

func (e *RolloutStepStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStepStatus", str)
	}
	return nil
}

func (e RolloutStepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollout Strategy Names
type RolloutStrategyNames string

const (
	// BlueGreen
	RolloutStrategyNamesBlueGreen RolloutStrategyNames = "blueGreen"
	// Canary
	RolloutStrategyNamesCanary RolloutStrategyNames = "canary"
)

var AllRolloutStrategyNames = []RolloutStrategyNames{
	RolloutStrategyNamesBlueGreen,
	RolloutStrategyNamesCanary,
}

func (e RolloutStrategyNames) IsValid() bool {
	switch e {
	case RolloutStrategyNamesBlueGreen, RolloutStrategyNamesCanary:
		return true
	}
	return false
}

func (e RolloutStrategyNames) String() string {
	return string(e)
}

func (e *RolloutStrategyNames) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStrategyNames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStrategyNames", str)
	}
	return nil
}

func (e RolloutStrategyNames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RuntimeOperationAction
type RuntimeOperationAction string

const (
	// Delete resources from runtime
	RuntimeOperationActionDelete RuntimeOperationAction = "DELETE"
	// Upsert resources to runtime
	RuntimeOperationActionUpsert RuntimeOperationAction = "UPSERT"
)

var AllRuntimeOperationAction = []RuntimeOperationAction{
	RuntimeOperationActionDelete,
	RuntimeOperationActionUpsert,
}

func (e RuntimeOperationAction) IsValid() bool {
	switch e {
	case RuntimeOperationActionDelete, RuntimeOperationActionUpsert:
		return true
	}
	return false
}

func (e RuntimeOperationAction) String() string {
	return string(e)
}

func (e *RuntimeOperationAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeOperationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeOperationAction", str)
	}
	return nil
}

func (e RuntimeOperationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Runtime Sync Mode
type RuntimeSyncMode string

const (
	// GITOPS
	RuntimeSyncModeGitops RuntimeSyncMode = "GITOPS"
	// HELM
	RuntimeSyncModeHelm RuntimeSyncMode = "HELM"
	// UNKNOWN
	RuntimeSyncModeUnknown RuntimeSyncMode = "UNKNOWN"
)

var AllRuntimeSyncMode = []RuntimeSyncMode{
	RuntimeSyncModeGitops,
	RuntimeSyncModeHelm,
	RuntimeSyncModeUnknown,
}

func (e RuntimeSyncMode) IsValid() bool {
	switch e {
	case RuntimeSyncModeGitops, RuntimeSyncModeHelm, RuntimeSyncModeUnknown:
		return true
	}
	return false
}

func (e RuntimeSyncMode) String() string {
	return string(e)
}

func (e *RuntimeSyncMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeSyncMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeSyncMode", str)
	}
	return nil
}

func (e RuntimeSyncMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Integration Entity Type
type SecretType string

const (
	// External Secret
	SecretTypeExternalSecret SecretType = "EXTERNAL_SECRET"
	// Sealed Secret
	SecretTypeSealedSecret SecretType = "SEALED_SECRET"
)

var AllSecretType = []SecretType{
	SecretTypeExternalSecret,
	SecretTypeSealedSecret,
}

func (e SecretType) IsValid() bool {
	switch e {
	case SecretTypeExternalSecret, SecretTypeSealedSecret:
		return true
	}
	return false
}

func (e SecretType) String() string {
	return string(e)
}

func (e *SecretType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecretType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecretType", str)
	}
	return nil
}

func (e SecretType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service Sorting field
type ServiceSortingField string

const (
	// Last Update
	ServiceSortingFieldLastUpdate ServiceSortingField = "lastUpdate"
	// Service Name
	ServiceSortingFieldServiceName ServiceSortingField = "serviceName"
)

var AllServiceSortingField = []ServiceSortingField{
	ServiceSortingFieldLastUpdate,
	ServiceSortingFieldServiceName,
}

func (e ServiceSortingField) IsValid() bool {
	switch e {
	case ServiceSortingFieldLastUpdate, ServiceSortingFieldServiceName:
		return true
	}
	return false
}

func (e ServiceSortingField) String() string {
	return string(e)
}

func (e *ServiceSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceSortingField", str)
	}
	return nil
}

func (e ServiceSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ServiceType
type ServiceType string

const (
	ServiceTypeClusterIP    ServiceType = "ClusterIP"
	ServiceTypeExternalName ServiceType = "ExternalName"
	ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
	ServiceTypeNodePort     ServiceType = "NodePort"
)

var AllServiceType = []ServiceType{
	ServiceTypeClusterIP,
	ServiceTypeExternalName,
	ServiceTypeLoadBalancer,
	ServiceTypeNodePort,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeClusterIP, ServiceTypeExternalName, ServiceTypeLoadBalancer, ServiceTypeNodePort:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sorting order
type SortingOrder string

const (
	// ascending
	SortingOrderAsc SortingOrder = "asc"
	// descending
	SortingOrderDesc SortingOrder = "desc"
)

var AllSortingOrder = []SortingOrder{
	SortingOrderAsc,
	SortingOrderDesc,
}

func (e SortingOrder) IsValid() bool {
	switch e {
	case SortingOrderAsc, SortingOrderDesc:
		return true
	}
	return false
}

func (e SortingOrder) String() string {
	return string(e)
}

func (e *SortingOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortingOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortingOrder", str)
	}
	return nil
}

func (e SortingOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Granularity options for statistics
type StatisticsGranularity string

const (
	StatisticsGranularityDay   StatisticsGranularity = "day"
	StatisticsGranularityHour  StatisticsGranularity = "hour"
	StatisticsGranularityMonth StatisticsGranularity = "month"
	StatisticsGranularityWeek  StatisticsGranularity = "week"
)

var AllStatisticsGranularity = []StatisticsGranularity{
	StatisticsGranularityDay,
	StatisticsGranularityHour,
	StatisticsGranularityMonth,
	StatisticsGranularityWeek,
}

func (e StatisticsGranularity) IsValid() bool {
	switch e {
	case StatisticsGranularityDay, StatisticsGranularityHour, StatisticsGranularityMonth, StatisticsGranularityWeek:
		return true
	}
	return false
}

func (e StatisticsGranularity) String() string {
	return string(e)
}

func (e *StatisticsGranularity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatisticsGranularity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatisticsGranularity", str)
	}
	return nil
}

func (e StatisticsGranularity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported CI Tools
type SupportedCITools string

const (
	// CLASSIC
	SupportedCIToolsClassic SupportedCITools = "classic"
	// GITHUB_ACTIONS
	SupportedCIToolsGithubActions SupportedCITools = "github_actions"
	// JENKINS
	SupportedCIToolsJenkins SupportedCITools = "jenkins"
)

var AllSupportedCITools = []SupportedCITools{
	SupportedCIToolsClassic,
	SupportedCIToolsGithubActions,
	SupportedCIToolsJenkins,
}

func (e SupportedCITools) IsValid() bool {
	switch e {
	case SupportedCIToolsClassic, SupportedCIToolsGithubActions, SupportedCIToolsJenkins:
		return true
	}
	return false
}

func (e SupportedCITools) String() string {
	return string(e)
}

func (e *SupportedCITools) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SupportedCITools(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SupportedCITools", str)
	}
	return nil
}

func (e SupportedCITools) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncResourceAction
type SyncActionOnResource string

const (
	// Configured / updated
	SyncActionOnResourceConfigured SyncActionOnResource = "Configured"
	// Created
	SyncActionOnResourceCreated SyncActionOnResource = "Created"
	// Pruned
	SyncActionOnResourcePruned SyncActionOnResource = "Pruned"
	// Prune Skipped
	SyncActionOnResourcePruneSkipped SyncActionOnResource = "PruneSkipped"
	// Sync Failed
	SyncActionOnResourceSyncFailed SyncActionOnResource = "SyncFailed"
	// Unchanged
	SyncActionOnResourceUnchanged SyncActionOnResource = "Unchanged"
	// Unknown
	SyncActionOnResourceUnknown SyncActionOnResource = "Unknown"
)

var AllSyncActionOnResource = []SyncActionOnResource{
	SyncActionOnResourceConfigured,
	SyncActionOnResourceCreated,
	SyncActionOnResourcePruned,
	SyncActionOnResourcePruneSkipped,
	SyncActionOnResourceSyncFailed,
	SyncActionOnResourceUnchanged,
	SyncActionOnResourceUnknown,
}

func (e SyncActionOnResource) IsValid() bool {
	switch e {
	case SyncActionOnResourceConfigured, SyncActionOnResourceCreated, SyncActionOnResourcePruned, SyncActionOnResourcePruneSkipped, SyncActionOnResourceSyncFailed, SyncActionOnResourceUnchanged, SyncActionOnResourceUnknown:
		return true
	}
	return false
}

func (e SyncActionOnResource) String() string {
	return string(e)
}

func (e *SyncActionOnResource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncActionOnResource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncActionOnResource", str)
	}
	return nil
}

func (e SyncActionOnResource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync Error codes
type SyncErrorCodes string

const (
	// The resource desired state has an invalid state and cannot be synced to the cluster
	SyncErrorCodesInvalidSpec SyncErrorCodes = "INVALID_SPEC"
	// Sync error for cases when sync operation lasts more than X minutes
	SyncErrorCodesLongSync SyncErrorCodes = "LONG_SYNC"
	// Sync in impossible due to missing rollouts components
	SyncErrorCodesMissingRolloutsComponent SyncErrorCodes = "MISSING_ROLLOUTS_COMPONENT"
	// Uknown sync error
	SyncErrorCodesUnknown SyncErrorCodes = "UNKNOWN"
)

var AllSyncErrorCodes = []SyncErrorCodes{
	SyncErrorCodesInvalidSpec,
	SyncErrorCodesLongSync,
	SyncErrorCodesMissingRolloutsComponent,
	SyncErrorCodesUnknown,
}

func (e SyncErrorCodes) IsValid() bool {
	switch e {
	case SyncErrorCodesInvalidSpec, SyncErrorCodesLongSync, SyncErrorCodesMissingRolloutsComponent, SyncErrorCodesUnknown:
		return true
	}
	return false
}

func (e SyncErrorCodes) String() string {
	return string(e)
}

func (e *SyncErrorCodes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncErrorCodes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncErrorCodes", str)
	}
	return nil
}

func (e SyncErrorCodes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncHookType
type SyncHookType string

const (
	// PostSync
	SyncHookTypePostSync SyncHookType = "PostSync"
	// PreSync
	SyncHookTypePreSync SyncHookType = "PreSync"
	// Skip
	SyncHookTypeSkip SyncHookType = "Skip"
	// Sync
	SyncHookTypeSync SyncHookType = "Sync"
	// SyncFail
	SyncHookTypeSyncFail SyncHookType = "SyncFail"
)

var AllSyncHookType = []SyncHookType{
	SyncHookTypePostSync,
	SyncHookTypePreSync,
	SyncHookTypeSkip,
	SyncHookTypeSync,
	SyncHookTypeSyncFail,
}

func (e SyncHookType) IsValid() bool {
	switch e {
	case SyncHookTypePostSync, SyncHookTypePreSync, SyncHookTypeSkip, SyncHookTypeSync, SyncHookTypeSyncFail:
		return true
	}
	return false
}

func (e SyncHookType) String() string {
	return string(e)
}

func (e *SyncHookType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncHookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncHookType", str)
	}
	return nil
}

func (e SyncHookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncOperationPhase
type SyncOperationPhase string

const (
	// Error
	SyncOperationPhaseError SyncOperationPhase = "Error"
	// Failed
	SyncOperationPhaseFailed SyncOperationPhase = "Failed"
	// Running
	SyncOperationPhaseRunning SyncOperationPhase = "Running"
	// Succeeded
	SyncOperationPhaseSucceeded SyncOperationPhase = "Succeeded"
	// Terminating
	SyncOperationPhaseTerminating SyncOperationPhase = "Terminating"
	// Unknown
	SyncOperationPhaseUnknown SyncOperationPhase = "Unknown"
)

var AllSyncOperationPhase = []SyncOperationPhase{
	SyncOperationPhaseError,
	SyncOperationPhaseFailed,
	SyncOperationPhaseRunning,
	SyncOperationPhaseSucceeded,
	SyncOperationPhaseTerminating,
	SyncOperationPhaseUnknown,
}

func (e SyncOperationPhase) IsValid() bool {
	switch e {
	case SyncOperationPhaseError, SyncOperationPhaseFailed, SyncOperationPhaseRunning, SyncOperationPhaseSucceeded, SyncOperationPhaseTerminating, SyncOperationPhaseUnknown:
		return true
	}
	return false
}

func (e SyncOperationPhase) String() string {
	return string(e)
}

func (e *SyncOperationPhase) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncOperationPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncOperationPhase", str)
	}
	return nil
}

func (e SyncOperationPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncPhase
type SyncPhase string

const (
	// PostSync
	SyncPhasePostSync SyncPhase = "PostSync"
	// PreSync
	SyncPhasePreSync SyncPhase = "PreSync"
	// Sync
	SyncPhaseSync SyncPhase = "Sync"
	// SyncFail
	SyncPhaseSyncFail SyncPhase = "SyncFail"
)

var AllSyncPhase = []SyncPhase{
	SyncPhasePostSync,
	SyncPhasePreSync,
	SyncPhaseSync,
	SyncPhaseSyncFail,
}

func (e SyncPhase) IsValid() bool {
	switch e {
	case SyncPhasePostSync, SyncPhasePreSync, SyncPhaseSync, SyncPhaseSyncFail:
		return true
	}
	return false
}

func (e SyncPhase) String() string {
	return string(e)
}

func (e *SyncPhase) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncPhase", str)
	}
	return nil
}

func (e SyncPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SyncResultCode
type SyncResultCode string

const (
	// Pruned
	SyncResultCodePruned SyncResultCode = "Pruned"
	// PruneSkipped
	SyncResultCodePruneSkipped SyncResultCode = "PruneSkipped"
	// Synced
	SyncResultCodeSynced SyncResultCode = "Synced"
	// SyncFailed
	SyncResultCodeSyncFailed SyncResultCode = "SyncFailed"
	// Unknown
	SyncResultCodeUnknown SyncResultCode = "Unknown"
)

var AllSyncResultCode = []SyncResultCode{
	SyncResultCodePruned,
	SyncResultCodePruneSkipped,
	SyncResultCodeSynced,
	SyncResultCodeSyncFailed,
	SyncResultCodeUnknown,
}

func (e SyncResultCode) IsValid() bool {
	switch e {
	case SyncResultCodePruned, SyncResultCodePruneSkipped, SyncResultCodeSynced, SyncResultCodeSyncFailed, SyncResultCodeUnknown:
		return true
	}
	return false
}

func (e SyncResultCode) String() string {
	return string(e)
}

func (e *SyncResultCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncResultCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncResultCode", str)
	}
	return nil
}

func (e SyncResultCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync status
type SyncStatus string

const (
	// Out of sync
	SyncStatusOutOfSync SyncStatus = "OUT_OF_SYNC"
	// Synced
	SyncStatusSynced SyncStatus = "SYNCED"
	// Syncing
	SyncStatusSyncing SyncStatus = "SYNCING"
	// Unknown
	SyncStatusUnknown SyncStatus = "UNKNOWN"
)

var AllSyncStatus = []SyncStatus{
	SyncStatusOutOfSync,
	SyncStatusSynced,
	SyncStatusSyncing,
	SyncStatusUnknown,
}

func (e SyncStatus) IsValid() bool {
	switch e {
	case SyncStatusOutOfSync, SyncStatusSynced, SyncStatusSyncing, SyncStatusUnknown:
		return true
	}
	return false
}

func (e SyncStatus) String() string {
	return string(e)
}

func (e *SyncStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncStatus", str)
	}
	return nil
}

func (e SyncStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sync success/failure
type SyncSuccess string

const (
	// FAILURE - when SyncStatus is OUT_OF_SYNC or UNKNOWN
	SyncSuccessFailure SyncSuccess = "FAILURE"
	// SUCCESS - when SyncStatus is SYNCED
	SyncSuccessSuccess SyncSuccess = "SUCCESS"
)

var AllSyncSuccess = []SyncSuccess{
	SyncSuccessFailure,
	SyncSuccessSuccess,
}

func (e SyncSuccess) IsValid() bool {
	switch e {
	case SyncSuccessFailure, SyncSuccessSuccess:
		return true
	}
	return false
}

func (e SyncSuccess) String() string {
	return string(e)
}

func (e *SyncSuccess) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SyncSuccess(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SyncSuccess", str)
	}
	return nil
}

func (e SyncSuccess) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of system type
type SystemType string

const (
	SystemTypeClassic          SystemType = "CLASSIC"
	SystemTypeGitops           SystemType = "GITOPS"
	SystemTypeGitopsAndClassic SystemType = "GITOPS_AND_CLASSIC"
	SystemTypeProjectOne       SystemType = "PROJECT_ONE"
)

var AllSystemType = []SystemType{
	SystemTypeClassic,
	SystemTypeGitops,
	SystemTypeGitopsAndClassic,
	SystemTypeProjectOne,
}

func (e SystemType) IsValid() bool {
	switch e {
	case SystemTypeClassic, SystemTypeGitops, SystemTypeGitopsAndClassic, SystemTypeProjectOne:
		return true
	}
	return false
}

func (e SystemType) String() string {
	return string(e)
}

func (e *SystemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemType", str)
	}
	return nil
}

func (e SystemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Team sources
type TeamSource string

const (
	// auth0
	TeamSourceAuth0 TeamSource = "AUTH0"
	// azure
	TeamSourceAzure TeamSource = "AZURE"
	// github
	TeamSourceGithub TeamSource = "GITHUB"
	// google
	TeamSourceGoogle TeamSource = "GOOGLE"
	// keycloak
	TeamSourceKeycloak TeamSource = "KEYCLOAK"
	// ldap
	TeamSourceLdap TeamSource = "LDAP"
	// okta
	TeamSourceOkta TeamSource = "OKTA"
	// onelogin
	TeamSourceOnelogin TeamSource = "ONELOGIN"
)

var AllTeamSource = []TeamSource{
	TeamSourceAuth0,
	TeamSourceAzure,
	TeamSourceGithub,
	TeamSourceGoogle,
	TeamSourceKeycloak,
	TeamSourceLdap,
	TeamSourceOkta,
	TeamSourceOnelogin,
}

func (e TeamSource) IsValid() bool {
	switch e {
	case TeamSourceAuth0, TeamSourceAzure, TeamSourceGithub, TeamSourceGoogle, TeamSourceKeycloak, TeamSourceLdap, TeamSourceOkta, TeamSourceOnelogin:
		return true
	}
	return false
}

func (e TeamSource) String() string {
	return string(e)
}

func (e *TeamSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamSource", str)
	}
	return nil
}

func (e TeamSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of team
type TeamType string

const (
	// admin
	TeamTypeAdmin TeamType = "ADMIN"
	// default
	TeamTypeDefault TeamType = "DEFAULT"
)

var AllTeamType = []TeamType{
	TeamTypeAdmin,
	TeamTypeDefault,
}

func (e TeamType) IsValid() bool {
	switch e {
	case TeamTypeAdmin, TeamTypeDefault:
		return true
	}
	return false
}

func (e TeamType) String() string {
	return string(e)
}

func (e *TeamType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamType", str)
	}
	return nil
}

func (e TeamType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ToggleSystemType Input
type ToggleSystemTypeInput string

const (
	// New experience
	ToggleSystemTypeInputNew ToggleSystemTypeInput = "new"
	// Old experience
	ToggleSystemTypeInputOld ToggleSystemTypeInput = "old"
)

var AllToggleSystemTypeInput = []ToggleSystemTypeInput{
	ToggleSystemTypeInputNew,
	ToggleSystemTypeInputOld,
}

func (e ToggleSystemTypeInput) IsValid() bool {
	switch e {
	case ToggleSystemTypeInputNew, ToggleSystemTypeInputOld:
		return true
	}
	return false
}

func (e ToggleSystemTypeInput) String() string {
	return string(e)
}

func (e *ToggleSystemTypeInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ToggleSystemTypeInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ToggleSystemTypeInput", str)
	}
	return nil
}

func (e ToggleSystemTypeInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow nodes WorkflowPhases
type WorkflowNodePhases string

const (
	// Error
	WorkflowNodePhasesError WorkflowNodePhases = "Error"
	// Failed
	WorkflowNodePhasesFailed WorkflowNodePhases = "Failed"
	// Omitted
	WorkflowNodePhasesOmitted WorkflowNodePhases = "Omitted"
	// Pending
	WorkflowNodePhasesPending WorkflowNodePhases = "Pending"
	// Running
	WorkflowNodePhasesRunning WorkflowNodePhases = "Running"
	// Skipped
	WorkflowNodePhasesSkipped WorkflowNodePhases = "Skipped"
	// Succeeded
	WorkflowNodePhasesSucceeded WorkflowNodePhases = "Succeeded"
)

var AllWorkflowNodePhases = []WorkflowNodePhases{
	WorkflowNodePhasesError,
	WorkflowNodePhasesFailed,
	WorkflowNodePhasesOmitted,
	WorkflowNodePhasesPending,
	WorkflowNodePhasesRunning,
	WorkflowNodePhasesSkipped,
	WorkflowNodePhasesSucceeded,
}

func (e WorkflowNodePhases) IsValid() bool {
	switch e {
	case WorkflowNodePhasesError, WorkflowNodePhasesFailed, WorkflowNodePhasesOmitted, WorkflowNodePhasesPending, WorkflowNodePhasesRunning, WorkflowNodePhasesSkipped, WorkflowNodePhasesSucceeded:
		return true
	}
	return false
}

func (e WorkflowNodePhases) String() string {
	return string(e)
}

func (e *WorkflowNodePhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowNodePhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowNodePhases", str)
	}
	return nil
}

func (e WorkflowNodePhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Name of the flows that can be the workflow origins
type WorkflowOrigins string

const (
	// workflow was created as a result of image reporting/enrichment by unknown source
	WorkflowOriginsCiEnrichment WorkflowOrigins = "CI_ENRICHMENT"
	// workflow was created as a result of image reporting/enrichment by github-action plugin
	WorkflowOriginsCiEnrichmentCodefreshClassic WorkflowOrigins = "CI_ENRICHMENT_CODEFRESH_CLASSIC"
	// workflow was created as a result of image reporting/enrichment by github-action plugin
	WorkflowOriginsCiEnrichmentGa WorkflowOrigins = "CI_ENRICHMENT_GA"
	// workflow was created as a result of image reporting/enrichment by jenkins plugin
	WorkflowOriginsCiEnrichmentJenkins WorkflowOrigins = "CI_ENRICHMENT_JENKINS"
	// workflow without specific origin, regular pipeline workflow
	WorkflowOriginsCommon WorkflowOrigins = "COMMON"
	// workflow was create as a result of running the workflow template
	WorkflowOriginsPlayground WorkflowOrigins = "PLAYGROUND"
)

var AllWorkflowOrigins = []WorkflowOrigins{
	WorkflowOriginsCiEnrichment,
	WorkflowOriginsCiEnrichmentCodefreshClassic,
	WorkflowOriginsCiEnrichmentGa,
	WorkflowOriginsCiEnrichmentJenkins,
	WorkflowOriginsCommon,
	WorkflowOriginsPlayground,
}

func (e WorkflowOrigins) IsValid() bool {
	switch e {
	case WorkflowOriginsCiEnrichment, WorkflowOriginsCiEnrichmentCodefreshClassic, WorkflowOriginsCiEnrichmentGa, WorkflowOriginsCiEnrichmentJenkins, WorkflowOriginsCommon, WorkflowOriginsPlayground:
		return true
	}
	return false
}

func (e WorkflowOrigins) String() string {
	return string(e)
}

func (e *WorkflowOrigins) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowOrigins(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowOrigins", str)
	}
	return nil
}

func (e WorkflowOrigins) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Workflow WorkflowPhases
type WorkflowPhases string

const (
	// Error
	WorkflowPhasesError WorkflowPhases = "Error"
	// Failed
	WorkflowPhasesFailed WorkflowPhases = "Failed"
	// Pending
	WorkflowPhasesPending WorkflowPhases = "Pending"
	// Running
	WorkflowPhasesRunning WorkflowPhases = "Running"
	// Succeeded
	WorkflowPhasesSucceeded WorkflowPhases = "Succeeded"
	// Unknown
	WorkflowPhasesUnknown WorkflowPhases = "Unknown"
)

var AllWorkflowPhases = []WorkflowPhases{
	WorkflowPhasesError,
	WorkflowPhasesFailed,
	WorkflowPhasesPending,
	WorkflowPhasesRunning,
	WorkflowPhasesSucceeded,
	WorkflowPhasesUnknown,
}

func (e WorkflowPhases) IsValid() bool {
	switch e {
	case WorkflowPhasesError, WorkflowPhasesFailed, WorkflowPhasesPending, WorkflowPhasesRunning, WorkflowPhasesSucceeded, WorkflowPhasesUnknown:
		return true
	}
	return false
}

func (e WorkflowPhases) String() string {
	return string(e)
}

func (e *WorkflowPhases) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowPhases(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowPhases", str)
	}
	return nil
}

func (e WorkflowPhases) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
